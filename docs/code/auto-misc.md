# ğŸ“¦ Miscellaneous

> ğŸ¤– ì´ ë¬¸ì„œëŠ” ìë™ìœ¼ë¡œ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤. ìˆ˜ì • ì‹œ ë‹¤ìŒ ìƒì„±ì—ì„œ ë®ì–´ì“°ì—¬ì§‘ë‹ˆë‹¤.

## ğŸ“š ëª©ì°¨

- [page.tsx](#page-tsx)
- [page.tsx](#page-tsx)
- [page.tsx](#page-tsx)
- [page.tsx](#page-tsx)
- [page.tsx](#page-tsx)
- [page.tsx](#page-tsx)
- [page.tsx](#page-tsx)
- [page.tsx](#page-tsx)
- [page.tsx](#page-tsx)
- [page.tsx](#page-tsx)
- [page.tsx](#page-tsx)
- [page.tsx](#page-tsx)
- [page.tsx](#page-tsx)
- [page.tsx](#page-tsx)
- [page.tsx](#page-tsx)
- [layout.tsx](#layout-tsx)
- [page.tsx](#page-tsx)
- [page.tsx](#page-tsx)
- [page.tsx](#page-tsx)
- [page.tsx](#page-tsx)
- [page.tsx](#page-tsx)
- [page.tsx](#page-tsx)
- [page.tsx](#page-tsx)
- [page.tsx](#page-tsx)
- [page.tsx](#page-tsx)
- [page.tsx](#page-tsx)
- [page.tsx](#page-tsx)
- [page.tsx](#page-tsx)
- [page.tsx](#page-tsx)
- [ab-test-manager.ts](#ab-test-manager-ts)
- [documentation-automation.ts](#documentation-automation-ts)
- [workflow-automation.ts](#workflow-automation-ts)
- [vercel.tsx](#vercel-tsx)
- [api-client.ts](#api-client-ts)
- [auth.ts](#auth-ts)
- [automated-backup.ts](#automated-backup-ts)
- [backup-manager.ts](#backup-manager-ts)
- [backup-scheduler.ts](#backup-scheduler-ts)
- [database-backup.ts](#database-backup-ts)
- [file-backup.ts](#file-backup-ts)
- [recovery-manager.ts](#recovery-manager-ts)
- [memory-cache.ts](#memory-cache-ts)
- [calendar.ts](#calendar-ts)
- [environment.ts](#environment-ts)
- [connection-manager.ts](#connection-manager-ts)
- [connection-pool-v2.ts](#connection-pool-v2-ts)
- [connection-pool.ts](#connection-pool-ts)
- [dev-prisma.ts](#dev-prisma-ts)
- [optimized-queries.ts](#optimized-queries-ts)
- [prisma-client.ts](#prisma-client-ts)
- [query-optimizer.ts](#query-optimizer-ts)
- [db-performance.ts](#db-performance-ts)
- [db-utils.ts](#db-utils-ts)
- [parser.ts](#parser-ts)
- [patterns.ts](#patterns-ts)
- [service.ts](#service-ts)
- [email-intelligence.ts](#email-intelligence-ts)
- [error-handler.ts](#error-handler-ts)
- [error-logger.ts](#error-logger-ts)
- [gmail-analytics.ts](#gmail-analytics-ts)
- [gmail-middleware.ts](#gmail-middleware-ts)
- [gmail.ts](#gmail-ts)
- [i18n.ts](#i18n-ts)
- [performance.ts](#performance-ts)
- [alerts-v2.ts](#alerts-v2-ts)
- [alerts.ts](#alerts-ts)
- [logger.ts](#logger-ts)
- [metrics-collector-v2.ts](#metrics-collector-v2-ts)
- [metrics-collector.ts](#metrics-collector-ts)
- [monitoring-init.ts](#monitoring-init-ts)
- [sentry.ts](#sentry-ts)
- [monitoring.ts](#monitoring-ts)
- [alert-manager.ts](#alert-manager-ts)
- [visa-alerts.ts](#visa-alerts-ts)
- [notifications.ts](#notifications-ts)
- [offline-api-client.ts](#offline-api-client-ts)
- [offline-storage.ts](#offline-storage-ts)
- [api-cache.ts](#api-cache-ts)
- [database-optimizer.ts](#database-optimizer-ts)
- [dynamic-imports.ts](#dynamic-imports-ts)
- [resource-optimization.ts](#resource-optimization-ts)
- [prisma.ts](#prisma-ts)
- [schengen-calculator.ts](#schengen-calculator-ts)
- [api-security.ts](#api-security-ts)
- [auth-middleware.ts](#auth-middleware-ts)
- [auth-security.ts](#auth-security-ts)
- [csrf-protection.ts](#csrf-protection-ts)
- [env-validator.ts](#env-validator-ts)
- [input-sanitizer.ts](#input-sanitizer-ts)
- [input-validation.ts](#input-validation-ts)
- [rate-limiter.ts](#rate-limiter-ts)
- [security.ts](#security-ts)
- [travel-manager.ts](#travel-manager-ts)
- [utils.ts](#utils-ts)
- [visa-requirements.ts](#visa-requirements-ts)
- [email.ts](#email-ts)
- [global.ts](#global-ts)
- [gmail.ts](#gmail-ts)
- [gtag.d.ts](#gtag-d-ts)
- [next-auth.d.ts](#next-auth-d-ts)
- [notification.ts](#notification-ts)

## page.tsx

**íŒŒì¼ ê²½ë¡œ:** `app/(dashboard)/integrations/page.tsx`

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 25827 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 687
- ğŸ”§ í•¨ìˆ˜: 9ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 2ê°œ

**Exports:**

- `IntegrationsPage`

### ğŸ”§ Functions

#### `WireframeGmailAnalyzer`

#### `startAnalysis`

**íŠ¹ì„±:** `async`

#### `WireframeCalendarSync`

#### `startSync`

**íŠ¹ì„±:** `async`

#### `IntegrationsPage`

#### `checkConnections`

**íŠ¹ì„±:** `async`

#### `handleGmailAnalysisComplete`

#### `handleCalendarSyncComplete`

#### `resetFlow`

### ğŸ”— Interfaces

#### `ConnectionStatus`

#### `IntegrationStats`

## page.tsx

**íŒŒì¼ ê²½ë¡œ:** `app/admin/analytics/page.tsx`

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 915 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 32
- ğŸ”§ í•¨ìˆ˜: 1ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 0ê°œ

**Exports:**

- `metadata`
- `async`

### ğŸ”§ Functions

#### `AdminAnalyticsPage`

**íŠ¹ì„±:** `async`

## page.tsx

**íŒŒì¼ ê²½ë¡œ:** `app/admin/backup/page.tsx`

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 14684 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 436
- ğŸ”§ í•¨ìˆ˜: 4ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 1ê°œ

**Exports:**

- `BackupManagement`

### ğŸ”§ Functions

#### `BackupManagement`

#### `fetchBackupInfo`

**íŠ¹ì„±:** `async`

#### `createBackup`

**íŠ¹ì„±:** `async`

#### `testRecovery`

**íŠ¹ì„±:** `async`

### ğŸ”— Interfaces

#### `BackupInfo`

## page.tsx

**íŒŒì¼ ê²½ë¡œ:** `app/admin/metrics/page.tsx`

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 1014 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 37
- ğŸ”§ í•¨ìˆ˜: 1ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 0ê°œ

**Exports:**

- `metadata`
- `async`

### ğŸ”§ Functions

#### `AdminMetricsPage`

**íŠ¹ì„±:** `async`

## page.tsx

**íŒŒì¼ ê²½ë¡œ:** `app/admin/monitoring/page.tsx`

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 20671 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 611
- ğŸ”§ í•¨ìˆ˜: 6ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 4ê°œ

**Exports:**

- `MonitoringDashboard`

### ğŸ”§ Functions

#### `MonitoringDashboard`

#### `fetchHealth`

**íŠ¹ì„±:** `async`

#### `fetchMetrics`

**íŠ¹ì„±:** `async`

#### `fetchLogs`

**íŠ¹ì„±:** `async`

#### `checkAlerts`

#### `loadData`

**íŠ¹ì„±:** `async`

### ğŸ”— Interfaces

#### `HealthCheck`

#### `MetricsData`

#### `LogEntry`

#### `LogsData`

## page.tsx

**íŒŒì¼ ê²½ë¡œ:** `app/admin/performance/page.tsx`

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 925 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 32
- ğŸ”§ í•¨ìˆ˜: 1ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 0ê°œ

**Exports:**

- `metadata`
- `async`

### ğŸ”§ Functions

#### `AdminPerformancePage`

**íŠ¹ì„±:** `async`

## page.tsx

**íŒŒì¼ ê²½ë¡œ:** `app/ai/page.tsx`

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 4392 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 128
- ğŸ”§ í•¨ìˆ˜: 1ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 0ê°œ

**Exports:**

- `AIPage`

### ğŸ”§ Functions

#### `AIPage`

## page.tsx

**íŒŒì¼ ê²½ë¡œ:** `app/analytics/page.tsx`

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 8812 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 222
- ğŸ”§ í•¨ìˆ˜: 2ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 0ê°œ

**Exports:**

- `AnalyticsPage`

### ğŸ”§ Functions

#### `AnalyticsPage`

#### `loadStats`

**íŠ¹ì„±:** `async`

## page.tsx

**íŒŒì¼ ê²½ë¡œ:** `app/auth/error/page.tsx`

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 4698 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 163
- ğŸ”§ í•¨ìˆ˜: 3ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 0ê°œ

**Exports:**

- `AuthErrorPage`

### ğŸ”§ Functions

#### `AuthErrorContent`

#### `getErrorMessage`

#### `AuthErrorPage`

## page.tsx

**íŒŒì¼ ê²½ë¡œ:** `app/auth/signin/page.tsx`

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 5252 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 192
- ğŸ”§ í•¨ìˆ˜: 3ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 0ê°œ

**Exports:**

- `SignInPage`

### ğŸ”§ Functions

#### `SignInContent`

#### `handleGoogleSignIn`

**íŠ¹ì„±:** `async`

#### `SignInPage`

## page.tsx

**íŒŒì¼ ê²½ë¡œ:** `app/billing/success/page.tsx`

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 4272 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 136
- ğŸ”§ í•¨ìˆ˜: 2ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 1ê°œ

**Exports:**

- `metadata`
- `BillingSuccessPage`

### ğŸ”§ Functions

#### `BillingSuccessPage`

#### `getPlanName`

### ğŸ”— Interfaces

#### `PageProps`

## page.tsx

**íŒŒì¼ ê²½ë¡œ:** `app/calendar/page.tsx`

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 21503 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 548
- ğŸ”§ í•¨ìˆ˜: 4ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 1ê°œ

**Exports:**

- `CalendarPage`

### ğŸ”§ Functions

#### `CalendarPage`

#### `loadTravelInfos`

**íŠ¹ì„±:** `async`

#### `loadCalendarStats`

**íŠ¹ì„±:** `async`

#### `handleSyncComplete`

### ğŸ”— Interfaces

#### `CalendarStats`

## page.tsx

**íŒŒì¼ ê²½ë¡œ:** `app/dashboard/monitoring/page.tsx`

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 3923 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 108
- ğŸ”§ í•¨ìˆ˜: 1ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 0ê°œ

**Exports:**

- `metadata`
- `async`

### ğŸ”§ Functions

#### `MonitoringPage`

**íŠ¹ì„±:** `async`

## page.tsx

**íŒŒì¼ ê²½ë¡œ:** `app/dashboard/page.tsx`

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 9016 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 269
- ğŸ”§ í•¨ìˆ˜: 3ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 0ê°œ

**Exports:**

- `DashboardPage`

### ğŸ”§ Functions

#### `DashboardPage`

#### `loadDashboardData`

**íŠ¹ì„±:** `async`

#### `handleLogout`

**íŠ¹ì„±:** `async`

## page.tsx

**íŒŒì¼ ê²½ë¡œ:** `app/gmail/page.tsx`

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 19375 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 485
- ğŸ”§ í•¨ìˆ˜: 4ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 0ê°œ

**Exports:**

- `GmailPage`

### ğŸ”§ Functions

#### `WireframeGmailIntegration`

#### `checkConnection`

**íŠ¹ì„±:** `async`

#### `analyzeTravelEmails`

**íŠ¹ì„±:** `async`

#### `GmailPage`

## layout.tsx

**íŒŒì¼ ê²½ë¡œ:** `app/layout.tsx`

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 9563 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 274
- ğŸ”§ í•¨ìˆ˜: 3ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 0ê°œ

**Exports:**

- `viewport`
- `metadata`
- `RootLayout`

### ğŸ”§ Functions

#### `RootLayout`

#### `gtag`

#### `preloadCritical`

## page.tsx

**íŒŒì¼ ê²½ë¡œ:** `app/legal/faq/page.tsx`

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 6905 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 207
- ğŸ”§ í•¨ìˆ˜: 1ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 0ê°œ

**Exports:**

- `metadata`
- `FAQ`

### ğŸ”§ Functions

#### `FAQ`

## page.tsx

**íŒŒì¼ ê²½ë¡œ:** `app/legal/privacy/page.tsx`

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 11135 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 251
- ğŸ”§ í•¨ìˆ˜: 1ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 0ê°œ

**Exports:**

- `metadata`
- `PrivacyPolicy`

### ğŸ”§ Functions

#### `PrivacyPolicy`

## page.tsx

**íŒŒì¼ ê²½ë¡œ:** `app/legal/terms/page.tsx`

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 5564 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 140
- ğŸ”§ í•¨ìˆ˜: 1ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 0ê°œ

**Exports:**

- `metadata`
- `TermsOfService`

### ğŸ”§ Functions

#### `TermsOfService`

## page.tsx

**íŒŒì¼ ê²½ë¡œ:** `app/logout/page.tsx`

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 1271 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 48
- ğŸ”§ í•¨ìˆ˜: 1ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 0ê°œ

**Exports:**

- `LogoutPage`

### ğŸ”§ Functions

#### `LogoutPage`

## page.tsx

**íŒŒì¼ ê²½ë¡œ:** `app/monitoring/page.tsx`

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 15786 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 474
- ğŸ”§ í•¨ìˆ˜: 7ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 2ê°œ

**Exports:**

- `MonitoringPage`

### ğŸ”§ Functions

#### `SimpleChart`

#### `MetricCard`

#### `getStatusColor`

#### `MonitoringPage`

#### `loadMonitoringData`

**íŠ¹ì„±:** `async`

#### `formatUptime`

#### `formatBytes`

### ğŸ”— Interfaces

#### `SystemMetrics`

#### `MonitoringData`

## page.tsx

**íŒŒì¼ ê²½ë¡œ:** `app/notifications/page.tsx`

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 23275 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 672
- ğŸ”§ í•¨ìˆ˜: 12ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 0ê°œ

**Exports:**

- `NotificationsPage`

### ğŸ”§ Functions

#### `WireframeNotificationList`

#### `loadNotifications`

#### `markAsRead`

#### `markAllAsRead`

#### `deleteNotification`

#### `getNotificationIcon`

#### `formatTime`

#### `WireframeNotificationSettings`

#### `handleSave`

**íŠ¹ì„±:** `async`

#### `handleRequestPermission`

**íŠ¹ì„±:** `async`

#### `NotificationsPage`

#### `handleSaveSettings`

**íŠ¹ì„±:** `async`

## page.tsx

**íŒŒì¼ ê²½ë¡œ:** `app/offline/page.tsx`

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 4129 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 134
- ğŸ”§ í•¨ìˆ˜: 5ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 0ê°œ

**Exports:**

- `OfflinePage`

### ğŸ”§ Functions

#### `OfflinePage`

#### `updateOnlineStatus`

#### `getLastSync`

#### `handleRetry`

#### `handleViewCached`

## page.tsx

**íŒŒì¼ ê²½ë¡œ:** `app/page.tsx`

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 2272 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 80
- ğŸ”§ í•¨ìˆ˜: 1ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 0ê°œ

**Exports:**

- `HomePage`

### ğŸ”§ Functions

#### `HomePage`

## page.tsx

**íŒŒì¼ ê²½ë¡œ:** `app/pricing/page.tsx`

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 3344 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 93
- ğŸ”§ í•¨ìˆ˜: 1ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 0ê°œ

**Exports:**

- `metadata`
- `PricingPage`

### ğŸ”§ Functions

#### `PricingPage`

## page.tsx

**íŒŒì¼ ê²½ë¡œ:** `app/schengen/page.tsx`

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 7788 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 217
- ğŸ”§ í•¨ìˆ˜: 2ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 0ê°œ

**Exports:**

- `SchengenPage`

### ğŸ”§ Functions

#### `SchengenPage`

#### `loadSchengenData`

**íŠ¹ì„±:** `async`

## page.tsx

**íŒŒì¼ ê²½ë¡œ:** `app/simple/page.tsx`

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 6773 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 184
- ğŸ”§ í•¨ìˆ˜: 2ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 0ê°œ

**Exports:**

- `SimplePage`

### ğŸ”§ Functions

#### `SimplePage`

#### `handleExport`

## page.tsx

**íŒŒì¼ ê²½ë¡œ:** `app/trips/page.tsx`

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 8027 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 244
- ğŸ”§ í•¨ìˆ˜: 8ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 0ê°œ

**Exports:**

- `TripsPage`

### ğŸ”§ Functions

#### `TripsPage`

#### `loadTrips`

**íŠ¹ì„±:** `async`

#### `handleAddTrip`

#### `handleEditTrip`

#### `handleFormSuccess`

**íŠ¹ì„±:** `async`

#### `handleFormCancel`

#### `handleDeleteTrip`

**íŠ¹ì„±:** `async`

#### `getFilteredTrips`

## page.tsx

**íŒŒì¼ ê²½ë¡œ:** `app/visa-check/page.tsx`

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 2777 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 77
- ğŸ”§ í•¨ìˆ˜: 1ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 0ê°œ

**Exports:**

- `VisaCheckPage`

### ğŸ”§ Functions

#### `VisaCheckPage`

## ab-test-manager.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/ab-testing/ab-test-manager.ts`

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 7612 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 317
- ğŸ”§ í•¨ìˆ˜: 0ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 1ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 3ê°œ

**Exports:**

- `ABTest`
- `ABVariant`
- `ABTestResult`
- `ABTestManager`
- `export`

### ğŸ“¦ Classes

#### `ABTestManager`

**íŠ¹ì„±:** `exported`

### ğŸ”— Interfaces

#### `ABTest`

**íŠ¹ì„±:** `exported`

#### `ABVariant`

**íŠ¹ì„±:** `exported`

#### `ABTestResult`

**íŠ¹ì„±:** `exported`

## documentation-automation.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/ai/documentation-automation.ts`

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 11120 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 364
- ğŸ”§ í•¨ìˆ˜: 0ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 1ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 2ê°œ

**Exports:**

- `DocumentationContext`
- `GeneratedDocumentation`
- `DocumentationAutomation`
- `documentationEngine`

### ğŸ“¦ Classes

#### `DocumentationAutomation`

**íŠ¹ì„±:** `exported`

### ğŸ”— Interfaces

#### `DocumentationContext`

**íŠ¹ì„±:** `exported`

#### `GeneratedDocumentation`

**íŠ¹ì„±:** `exported`

## workflow-automation.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/ai/workflow-automation.ts`

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 7959 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 307
- ğŸ”§ í•¨ìˆ˜: 0ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 1ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 4ê°œ

**Exports:**

- `WorkflowTrigger`
- `WorkflowAction`
- `AutomatedWorkflow`
- `WorkflowResult`
- `WorkflowAutomationEngine`
- `workflowEngine`

### ğŸ“¦ Classes

#### `WorkflowAutomationEngine`

**íŠ¹ì„±:** `exported`

### ğŸ”— Interfaces

#### `WorkflowTrigger`

**íŠ¹ì„±:** `exported`

#### `WorkflowAction`

**íŠ¹ì„±:** `exported`

#### `AutomatedWorkflow`

**íŠ¹ì„±:** `exported`

#### `WorkflowResult`

**íŠ¹ì„±:** `exported`

## vercel.tsx

**íŒŒì¼ ê²½ë¡œ:** `lib/analytics/vercel.tsx`

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 3286 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 108
- ğŸ”§ í•¨ìˆ˜: 4ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 0ê°œ

**Exports:**

- `trackEvent`
- `trackPageView`
- `trackingEvents`
- `AnalyticsWrapper`
- `reportWebVitals`
- `performanceThresholds`

### ğŸ”§ Functions

#### `trackEvent`

**íŠ¹ì„±:** `exported`

#### `trackPageView`

**íŠ¹ì„±:** `exported`

#### `AnalyticsWrapper`

**íŠ¹ì„±:** `exported`

#### `reportWebVitals`

**íŠ¹ì„±:** `exported`

## api-client.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/api-client.ts`

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 9022 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 326
- ğŸ”§ í•¨ìˆ˜: 3ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 1ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 2ê°œ

**Exports:**

- `ApiResponse`
- `TripFormData`
- `ApiClient`
- `async`
- `formatApiDate`
- `parseApiDate`

### ğŸ”§ Functions

#### `handleApiError`

**íŠ¹ì„±:** `exported`, `async`

#### `formatApiDate`

**íŠ¹ì„±:** `exported`

#### `parseApiDate`

**íŠ¹ì„±:** `exported`

### ğŸ“¦ Classes

#### `ApiClient`

**íŠ¹ì„±:** `exported`

### ğŸ”— Interfaces

#### `ApiResponse`

**íŠ¹ì„±:** `exported`

#### `TripFormData`

**íŠ¹ì„±:** `exported`

## auth.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/auth.ts`

**ì„¤ëª…:** PURPOSE: NextAuth.js ì¸ì¦ ì„¤ì • - Google OAuth 2.0 ì „ìš©

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 4576 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 175
- ğŸ”§ í•¨ìˆ˜: 0ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 0ê°œ

**Exports:**

- `authOptions`

## automated-backup.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/backup/automated-backup.ts`

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 7144 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 268
- ğŸ”§ í•¨ìˆ˜: 0ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 1ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 1ê°œ

**Exports:**

- `AutomatedBackupService`
- `backupService`

### ğŸ“¦ Classes

#### `AutomatedBackupService`

**íŠ¹ì„±:** `exported`

### ğŸ”— Interfaces

#### `BackupConfig`

## backup-manager.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/backup/backup-manager.ts`

**ì„¤ëª…:** Database Backup and Recovery System
ë°ì´í„°ë² ì´ìŠ¤ ë°±ì—… ë° ë³µêµ¬ ì‹œìŠ¤í…œ

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 11028 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 403
- ğŸ”§ í•¨ìˆ˜: 0ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 1ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 3ê°œ

**Exports:**

- `backupManager`
- `type`

### ğŸ“¦ Classes

#### `BackupManager`

### ğŸ”— Interfaces

#### `BackupMetadata`

#### `BackupOptions`

#### `RestoreOptions`

## backup-scheduler.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/backup/backup-scheduler.ts`

**ì„¤ëª…:** Backup Scheduler
Manages automated backup schedules

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 10156 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 396
- ğŸ”§ í•¨ìˆ˜: 0ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 1ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 1ê°œ

**Exports:**

- `BackupSchedule`
- `BackupScheduler`
- `backupScheduler`

### ğŸ“¦ Classes

#### `BackupScheduler`

**íŠ¹ì„±:** `exported`

### ğŸ”— Interfaces

#### `BackupSchedule`

**íŠ¹ì„±:** `exported`

## database-backup.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/backup/database-backup.ts`

**ì„¤ëª…:** Database Backup Management System
Handles automated database backups with versioning

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 10365 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 394
- ğŸ”§ í•¨ìˆ˜: 0ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 1ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 2ê°œ

**Exports:**

- `BackupOptions`
- `BackupResult`
- `DatabaseBackupManager`
- `dbBackupManager`

### ğŸ“¦ Classes

#### `DatabaseBackupManager`

**íŠ¹ì„±:** `exported`

### ğŸ”— Interfaces

#### `BackupOptions`

**íŠ¹ì„±:** `exported`

#### `BackupResult`

**íŠ¹ì„±:** `exported`

## file-backup.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/backup/file-backup.ts`

**ì„¤ëª…:** File System Backup Management
Handles backup of uploaded files and static assets

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 12627 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 483
- ğŸ”§ í•¨ìˆ˜: 0ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 1ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 2ê°œ

**Exports:**

- `FileBackupOptions`
- `FileBackupResult`
- `FileBackupManager`
- `fileBackupManager`

### ğŸ“¦ Classes

#### `FileBackupManager`

**íŠ¹ì„±:** `exported`

### ğŸ”— Interfaces

#### `FileBackupOptions`

**íŠ¹ì„±:** `exported`

#### `FileBackupResult`

**íŠ¹ì„±:** `exported`

## recovery-manager.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/backup/recovery-manager.ts`

**ì„¤ëª…:** Disaster Recovery Manager
Coordinates backup and recovery operations

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 15683 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 519
- ğŸ”§ í•¨ìˆ˜: 0ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 1ê°œ
- ğŸ·ï¸ íƒ€ì…: 1ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 3ê°œ

**Exports:**

- `RecoveryScenario`
- `RecoveryPlan`
- `RecoveryStep`
- `RecoveryResult`
- `DisasterRecoveryManager`
- `recoveryManager`

### ğŸ“¦ Classes

#### `DisasterRecoveryManager`

**íŠ¹ì„±:** `exported`

### ğŸ”— Interfaces

#### `RecoveryPlan`

**íŠ¹ì„±:** `exported`

#### `RecoveryStep`

**íŠ¹ì„±:** `exported`

#### `RecoveryResult`

**íŠ¹ì„±:** `exported`

### ğŸ·ï¸ Types

- `RecoveryScenario` (exported)

## memory-cache.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/cache/memory-cache.ts`

**ì„¤ëª…:** In-memory cache implementation with TTL support
Optimized for DiNoCal's 5-minute caching strategy

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 4376 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 209
- ğŸ”§ í•¨ìˆ˜: 1ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 1ê°œ
- ğŸ·ï¸ íƒ€ì…: 1ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 1ê°œ

**Exports:**

- `memoryCache`
- `async`
- `generateCacheKey`
- `CacheKeys`
- `CacheKeyType`

### ğŸ”§ Functions

#### `generateCacheKey`

In-memory cache implementation with TTL support
Optimized for DiNoCal's 5-minute caching strategy
/

interface CacheItem<T> {
data: T
expiry: number
created: number
}

class MemoryCache {
private cache = new Map<string, CacheItem<any>>()
private readonly defaultTTL = 5 _ 60 _ 1000 // 5 minutes in milliseconds
private cleanupInterval: NodeJS.Timeout

constructor() {
// Cleanup expired items every minute
this.cleanupInterval = setInterval(() => {
this.cleanup()
}, 60 \* 1000)
}

/\*\*
Store data in cache with optional TTL
/
set<T>(key: string, data: T, ttl?: number): void {
const expiry = Date.now() + (ttl || this.defaultTTL)
this.cache.set(key, {
data,
expiry,
created: Date.now()
})
}

/\*\*
Retrieve data from cache
/
get<T>(key: string): T | null {
const item = this.cache.get(key)

    if (!item) {
      return null
    }

    // Check if expired
    if (Date.now() > item.expiry) {
      this.cache.delete(key)
      return null
    }

    return item.data as T

}

/\*\*
Check if key exists and is not expired
/
has(key: string): boolean {
const item = this.cache.get(key)

    if (!item) {
      return false
    }

    // Check if expired
    if (Date.now() > item.expiry) {
      this.cache.delete(key)
      return false
    }

    return true

}

/\*\*
Delete a specific key
/
delete(key: string): boolean {
return this.cache.delete(key)
}

/\*\*
Clear all cache
/
clear(): void {
this.cache.clear()
}

/\*\*
Get cache statistics
/
getStats() {
const now = Date.now()
let validItems = 0
let expiredItems = 0

    for (const [key, item] of this.cache.entries()) {
      if (now > item.expiry) {
        expiredItems++
      } else {
        validItems++
      }
    }

    return {
      totalItems: this.cache.size,
      validItems,
      expiredItems,
      hitRate: validItems / (validItems + expiredItems) || 0
    }

}

/\*\*
Remove expired items
/
private cleanup(): void {
const now = Date.now()
const keysToDelete: string[] = []

    for (const [key, item] of this.cache.entries()) {
      if (now > item.expiry) {
        keysToDelete.push(key)
      }
    }

    keysToDelete.forEach(key => this.cache.delete(key))

}

/\*\*
Cleanup interval when done
/
destroy(): void {
if (this.cleanupInterval) {
clearInterval(this.cleanupInterval)
}
this.clear()
}
}

// Singleton instance
export const memoryCache = new MemoryCache()

/\*\*
Cache wrapper function for async operations
/
export async function withCache<T>(
key: string,
fetcher: () => Promise<T>,
ttl?: number
): Promise<T> {
// Try to get from cache first
const cached = memoryCache.get<T>(key)
if (cached !== null) {
return cached
}

// Fetch data and cache it
const data = await fetcher()
memoryCache.set(key, data, ttl)

return data
}

/\*\*
Generate cache key for API calls

**íŠ¹ì„±:** `exported`

### ğŸ“¦ Classes

#### `MemoryCache`

### ğŸ”— Interfaces

#### `CacheItem`

In-memory cache implementation with TTL support
Optimized for DiNoCal's 5-minute caching strategy

### ğŸ·ï¸ Types

- `CacheKeyType` (exported)

## calendar.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/calendar.ts`

**ì„¤ëª…:** Google Calendar API í†µí•© ë¼ì´ë¸ŒëŸ¬ë¦¬
Gmailì—ì„œ ì¶”ì¶œí•œ ì—¬í–‰ ì •ë³´ë¥¼ Google Calendarì— ë™ê¸°í™”

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 11124 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 419
- ğŸ”§ í•¨ìˆ˜: 8ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 2ê°œ

**Exports:**

- `CalendarEvent`
- `TravelCalendarEvent`
- `createCalendarClient`
- `async`
- `createTravelEvents`

### ğŸ”§ Functions

#### `createCalendarClient`

Google Calendar API í†µí•© ë¼ì´ë¸ŒëŸ¬ë¦¬
Gmailì—ì„œ ì¶”ì¶œí•œ ì—¬í–‰ ì •ë³´ë¥¼ Google Calendarì— ë™ê¸°í™”
/

import { google } from 'googleapis'
import { TravelInfo } from './gmail'
import { normalizeDateString } from './email-intelligence'

export interface CalendarEvent {
id?: string
summary: string
description?: string
start: {
dateTime?: string
date?: string
timeZone?: string
}
end: {
dateTime?: string
date?: string
timeZone?: string
}
location?: string
attendees?: { email: string }[]
reminders?: {
useDefault?: boolean
overrides?: Array<{
method: 'email' | 'popup'
minutes: number
}>
}
colorId?: string
source?: {
title: string
url: string
}
}

export interface TravelCalendarEvent extends CalendarEvent {
travelType: 'departure' | 'return' | 'stay'
flightNumber?: string
bookingReference?: string
confidence: number
originalEmailId: string
}

/\*\*
Google Calendar API í´ë¼ì´ì–¸íŠ¸ ìƒì„±

**íŠ¹ì„±:** `exported`

#### `checkCalendarConnection`

Google Calendar API í†µí•© ë¼ì´ë¸ŒëŸ¬ë¦¬
Gmailì—ì„œ ì¶”ì¶œí•œ ì—¬í–‰ ì •ë³´ë¥¼ Google Calendarì— ë™ê¸°í™”
/

import { google } from 'googleapis'
import { TravelInfo } from './gmail'
import { normalizeDateString } from './email-intelligence'

export interface CalendarEvent {
id?: string
summary: string
description?: string
start: {
dateTime?: string
date?: string
timeZone?: string
}
end: {
dateTime?: string
date?: string
timeZone?: string
}
location?: string
attendees?: { email: string }[]
reminders?: {
useDefault?: boolean
overrides?: Array<{
method: 'email' | 'popup'
minutes: number
}>
}
colorId?: string
source?: {
title: string
url: string
}
}

export interface TravelCalendarEvent extends CalendarEvent {
travelType: 'departure' | 'return' | 'stay'
flightNumber?: string
bookingReference?: string
confidence: number
originalEmailId: string
}

/\*\*
Google Calendar API í´ë¼ì´ì–¸íŠ¸ ìƒì„±
/
export function createCalendarClient(accessToken: string) {
const oauth2Client = new google.auth.OAuth2(
process.env.GOOGLE_CLIENT_ID,
process.env.GOOGLE_CLIENT_SECRET
)

oauth2Client.setCredentials({
access_token: accessToken
})

return google.calendar({ version: 'v3', auth: oauth2Client })
}

/\*\*
Calendar API ì—°ê²° ìƒíƒœ í™•ì¸

**íŠ¹ì„±:** `exported`, `async`

#### `getUserCalendars`

Google Calendar API í†µí•© ë¼ì´ë¸ŒëŸ¬ë¦¬
Gmailì—ì„œ ì¶”ì¶œí•œ ì—¬í–‰ ì •ë³´ë¥¼ Google Calendarì— ë™ê¸°í™”
/

import { google } from 'googleapis'
import { TravelInfo } from './gmail'
import { normalizeDateString } from './email-intelligence'

export interface CalendarEvent {
id?: string
summary: string
description?: string
start: {
dateTime?: string
date?: string
timeZone?: string
}
end: {
dateTime?: string
date?: string
timeZone?: string
}
location?: string
attendees?: { email: string }[]
reminders?: {
useDefault?: boolean
overrides?: Array<{
method: 'email' | 'popup'
minutes: number
}>
}
colorId?: string
source?: {
title: string
url: string
}
}

export interface TravelCalendarEvent extends CalendarEvent {
travelType: 'departure' | 'return' | 'stay'
flightNumber?: string
bookingReference?: string
confidence: number
originalEmailId: string
}

/\*\*
Google Calendar API í´ë¼ì´ì–¸íŠ¸ ìƒì„±
/
export function createCalendarClient(accessToken: string) {
const oauth2Client = new google.auth.OAuth2(
process.env.GOOGLE_CLIENT_ID,
process.env.GOOGLE_CLIENT_SECRET
)

oauth2Client.setCredentials({
access_token: accessToken
})

return google.calendar({ version: 'v3', auth: oauth2Client })
}

/\*\*
Calendar API ì—°ê²° ìƒíƒœ í™•ì¸
/
export async function checkCalendarConnection(accessToken: string): Promise<boolean> {
try {
const calendar = createCalendarClient(accessToken)

    // ìº˜ë¦°ë” ëª©ë¡ ìš”ì²­ìœ¼ë¡œ ì—°ê²° í…ŒìŠ¤íŠ¸
    await calendar.calendarList.list({
      maxResults: 1
    })

    return true

} catch (error) {
// Calendar connection failed
return false
}
}

/\*\*
ì‚¬ìš©ìì˜ ìº˜ë¦°ë” ëª©ë¡ ê°€ì ¸ì˜¤ê¸°

**íŠ¹ì„±:** `exported`, `async`

#### `createTravelEvents`

Google Calendar API í†µí•© ë¼ì´ë¸ŒëŸ¬ë¦¬
Gmailì—ì„œ ì¶”ì¶œí•œ ì—¬í–‰ ì •ë³´ë¥¼ Google Calendarì— ë™ê¸°í™”
/

import { google } from 'googleapis'
import { TravelInfo } from './gmail'
import { normalizeDateString } from './email-intelligence'

export interface CalendarEvent {
id?: string
summary: string
description?: string
start: {
dateTime?: string
date?: string
timeZone?: string
}
end: {
dateTime?: string
date?: string
timeZone?: string
}
location?: string
attendees?: { email: string }[]
reminders?: {
useDefault?: boolean
overrides?: Array<{
method: 'email' | 'popup'
minutes: number
}>
}
colorId?: string
source?: {
title: string
url: string
}
}

export interface TravelCalendarEvent extends CalendarEvent {
travelType: 'departure' | 'return' | 'stay'
flightNumber?: string
bookingReference?: string
confidence: number
originalEmailId: string
}

/\*\*
Google Calendar API í´ë¼ì´ì–¸íŠ¸ ìƒì„±
/
export function createCalendarClient(accessToken: string) {
const oauth2Client = new google.auth.OAuth2(
process.env.GOOGLE_CLIENT_ID,
process.env.GOOGLE_CLIENT_SECRET
)

oauth2Client.setCredentials({
access_token: accessToken
})

return google.calendar({ version: 'v3', auth: oauth2Client })
}

/\*\*
Calendar API ì—°ê²° ìƒíƒœ í™•ì¸
/
export async function checkCalendarConnection(accessToken: string): Promise<boolean> {
try {
const calendar = createCalendarClient(accessToken)

    // ìº˜ë¦°ë” ëª©ë¡ ìš”ì²­ìœ¼ë¡œ ì—°ê²° í…ŒìŠ¤íŠ¸
    await calendar.calendarList.list({
      maxResults: 1
    })

    return true

} catch (error) {
// Calendar connection failed
return false
}
}

/\*\*
ì‚¬ìš©ìì˜ ìº˜ë¦°ë” ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
/
export async function getUserCalendars(accessToken: string) {
try {
const calendar = createCalendarClient(accessToken)

    const response = await calendar.calendarList.list({
      maxResults: 50
    })

    return response.data.items?.map(cal => ({
      id: cal.id || '',
      name: cal.summary || '',
      description: cal.description,
      primary: cal.primary || false,
      accessRole: cal.accessRole,
      backgroundColor: cal.backgroundColor,
      foregroundColor: cal.foregroundColor
    })) || []

} catch (error) {
// Error fetching calendars
throw new Error('ìº˜ë¦°ë” ëª©ë¡ì„ ê°€ì ¸ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.')
}
}

/\*\*
ì—¬í–‰ ì •ë³´ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ìº˜ë¦°ë” ì´ë²¤íŠ¸ ìƒì„±

**íŠ¹ì„±:** `exported`

#### `createCalendarEvent`

Google Calendar API í†µí•© ë¼ì´ë¸ŒëŸ¬ë¦¬
Gmailì—ì„œ ì¶”ì¶œí•œ ì—¬í–‰ ì •ë³´ë¥¼ Google Calendarì— ë™ê¸°í™”
/

import { google } from 'googleapis'
import { TravelInfo } from './gmail'
import { normalizeDateString } from './email-intelligence'

export interface CalendarEvent {
id?: string
summary: string
description?: string
start: {
dateTime?: string
date?: string
timeZone?: string
}
end: {
dateTime?: string
date?: string
timeZone?: string
}
location?: string
attendees?: { email: string }[]
reminders?: {
useDefault?: boolean
overrides?: Array<{
method: 'email' | 'popup'
minutes: number
}>
}
colorId?: string
source?: {
title: string
url: string
}
}

export interface TravelCalendarEvent extends CalendarEvent {
travelType: 'departure' | 'return' | 'stay'
flightNumber?: string
bookingReference?: string
confidence: number
originalEmailId: string
}

/\*\*
Google Calendar API í´ë¼ì´ì–¸íŠ¸ ìƒì„±
/
export function createCalendarClient(accessToken: string) {
const oauth2Client = new google.auth.OAuth2(
process.env.GOOGLE_CLIENT_ID,
process.env.GOOGLE_CLIENT_SECRET
)

oauth2Client.setCredentials({
access_token: accessToken
})

return google.calendar({ version: 'v3', auth: oauth2Client })
}

/\*\*
Calendar API ì—°ê²° ìƒíƒœ í™•ì¸
/
export async function checkCalendarConnection(accessToken: string): Promise<boolean> {
try {
const calendar = createCalendarClient(accessToken)

    // ìº˜ë¦°ë” ëª©ë¡ ìš”ì²­ìœ¼ë¡œ ì—°ê²° í…ŒìŠ¤íŠ¸
    await calendar.calendarList.list({
      maxResults: 1
    })

    return true

} catch (error) {
// Calendar connection failed
return false
}
}

/\*\*
ì‚¬ìš©ìì˜ ìº˜ë¦°ë” ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
/
export async function getUserCalendars(accessToken: string) {
try {
const calendar = createCalendarClient(accessToken)

    const response = await calendar.calendarList.list({
      maxResults: 50
    })

    return response.data.items?.map(cal => ({
      id: cal.id || '',
      name: cal.summary || '',
      description: cal.description,
      primary: cal.primary || false,
      accessRole: cal.accessRole,
      backgroundColor: cal.backgroundColor,
      foregroundColor: cal.foregroundColor
    })) || []

} catch (error) {
// Error fetching calendars
throw new Error('ìº˜ë¦°ë” ëª©ë¡ì„ ê°€ì ¸ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.')
}
}

/\*\*
ì—¬í–‰ ì •ë³´ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ìº˜ë¦°ë” ì´ë²¤íŠ¸ ìƒì„±
/
export function createTravelEvents(travelInfo: TravelInfo): TravelCalendarEvent[] {
const events: TravelCalendarEvent[] = []
const airportCodes = {
'ICN': 'ì¸ì²œêµ­ì œê³µí•­', 'GMP': 'ê¹€í¬êµ­ì œê³µí•­', 'CJU': 'ì œì£¼êµ­ì œê³µí•­',
'NRT': 'ë‚˜ë¦¬íƒ€êµ­ì œê³µí•­', 'HND': 'í•˜ë„¤ë‹¤ê³µí•­', 'LAX': 'ë¡œìŠ¤ì•¤ì ¤ë ˆìŠ¤êµ­ì œê³µí•­'
// ë” ë§ì€ ê³µí•­ ì½”ë“œ ë§¤í•‘ì€ travel-patterns.tsì—ì„œ ê°€ì ¸ì˜¬ ìˆ˜ ìˆìŒ
}

// ì¶œë°œ ì´ë²¤íŠ¸
if (travelInfo.departureDate) {
const departureDate = normalizeDateString(travelInfo.departureDate)

    if (departureDate) {
      const departureLocation = travelInfo.departure ?
        (airportCodes[travelInfo.departure as keyof typeof airportCodes] || travelInfo.departure) :
        'ì¶œë°œì§€'

      const destinationLocation = travelInfo.destination ?
        (airportCodes[travelInfo.destination as keyof typeof airportCodes] || travelInfo.destination) :
        'ëª©ì ì§€'

      events.push({
        summary: `âœˆï¸ ${destinationLocation} ì¶œë°œ`,
        description: [
          `í•­ê³µí¸: ${travelInfo.flightNumber || 'ë¯¸ìƒ'}`,
          `ì˜ˆì•½ë²ˆí˜¸: ${travelInfo.bookingReference || 'ë¯¸ìƒ'}`,
          `ì¶œë°œì§€: ${departureLocation}`,
          `ëª©ì ì§€: ${destinationLocation}`,
          ``,
          `ğŸ“§ Gmailì—ì„œ ìë™ ì¶”ì¶œë¨`,
          `ì‹ ë¢°ë„: ${Math.round(travelInfo.confidence * 100)}%`
        ].join('\\n'),
        start: {
          date: departureDate,
          timeZone: 'Asia/Seoul'
        },
        end: {
          date: departureDate,
          timeZone: 'Asia/Seoul'
        },
        location: departureLocation,
        colorId: '11', // ë¹¨ê°„ìƒ‰ (ì¶œë°œ)
        reminders: {
          useDefault: false,
          overrides: [
            { method: 'popup', minutes: 24 * 60 }, // 1ì¼ ì „
            { method: 'popup', minutes: 2 * 60 },  // 2ì‹œê°„ ì „
            { method: 'email', minutes: 24 * 60 }  // 1ì¼ ì „ ì´ë©”ì¼
          ]
        },
        travelType: 'departure',
        flightNumber: travelInfo.flightNumber,
        bookingReference: travelInfo.bookingReference,
        confidence: travelInfo.confidence,
        originalEmailId: travelInfo.emailId
      })
    }

}

// ê·€êµ­ ì´ë²¤íŠ¸
if (travelInfo.returnDate) {
const returnDate = normalizeDateString(travelInfo.returnDate)

    if (returnDate) {
      const departureLocation = travelInfo.departure ?
        (airportCodes[travelInfo.departure as keyof typeof airportCodes] || travelInfo.departure) :
        'ì¶œë°œì§€'

      const destinationLocation = travelInfo.destination ?
        (airportCodes[travelInfo.destination as keyof typeof airportCodes] || travelInfo.destination) :
        'ëª©ì ì§€'

      events.push({
        summary: `ğŸ  ${departureLocation} ê·€êµ­`,
        description: [
          `í•­ê³µí¸: ${travelInfo.flightNumber || 'ë¯¸ìƒ'}`,
          `ì˜ˆì•½ë²ˆí˜¸: ${travelInfo.bookingReference || 'ë¯¸ìƒ'}`,
          `ì¶œë°œì§€: ${destinationLocation}`,
          `ë„ì°©ì§€: ${departureLocation}`,
          ``,
          `ğŸ“§ Gmailì—ì„œ ìë™ ì¶”ì¶œë¨`,
          `ì‹ ë¢°ë„: ${Math.round(travelInfo.confidence * 100)}%`
        ].join('\\n'),
        start: {
          date: returnDate,
          timeZone: 'Asia/Seoul'
        },
        end: {
          date: returnDate,
          timeZone: 'Asia/Seoul'
        },
        location: destinationLocation,
        colorId: '10', // ì´ˆë¡ìƒ‰ (ê·€êµ­)
        reminders: {
          useDefault: false,
          overrides: [
            { method: 'popup', minutes: 24 * 60 }, // 1ì¼ ì „
            { method: 'popup', minutes: 2 * 60 },  // 2ì‹œê°„ ì „
          ]
        },
        travelType: 'return',
        flightNumber: travelInfo.flightNumber,
        bookingReference: travelInfo.bookingReference,
        confidence: travelInfo.confidence,
        originalEmailId: travelInfo.emailId
      })
    }

}

// ìˆ™ë°• ê¸°ê°„ ì´ë²¤íŠ¸ (í˜¸í…”ì´ ìˆê³  ì¶œë°œì¼ê³¼ ê·€êµ­ì¼ì´ ëª¨ë‘ ìˆëŠ” ê²½ìš°)
if (travelInfo.hotelName && travelInfo.departureDate && travelInfo.returnDate) {
const depDate = normalizeDateString(travelInfo.departureDate)
const retDate = normalizeDateString(travelInfo.returnDate)

    if (depDate && retDate) {
      const destinationLocation = travelInfo.destination ?
        (airportCodes[travelInfo.destination as keyof typeof airportCodes] || travelInfo.destination) :
        'ëª©ì ì§€'

      events.push({
        summary: `ğŸ¨ ${travelInfo.hotelName}`,
        description: [
          `í˜¸í…”: ${travelInfo.hotelName}`,
          `ìœ„ì¹˜: ${destinationLocation}`,
          `ì˜ˆì•½ë²ˆí˜¸: ${travelInfo.bookingReference || 'ë¯¸ìƒ'}`,
          ``,
          `ğŸ“§ Gmailì—ì„œ ìë™ ì¶”ì¶œë¨`,
          `ì‹ ë¢°ë„: ${Math.round(travelInfo.confidence * 100)}%`
        ].join('\\n'),
        start: {
          date: depDate,
          timeZone: 'Asia/Seoul'
        },
        end: {
          date: retDate,
          timeZone: 'Asia/Seoul'
        },
        location: `${travelInfo.hotelName}, ${destinationLocation}`,
        colorId: '9', // íŒŒë€ìƒ‰ (ìˆ™ë°•)
        travelType: 'stay',
        bookingReference: travelInfo.bookingReference,
        confidence: travelInfo.confidence,
        originalEmailId: travelInfo.emailId
      })
    }

}

return events
}

/\*\*
ìº˜ë¦°ë”ì— ì´ë²¤íŠ¸ ìƒì„±

**íŠ¹ì„±:** `exported`, `async`

#### `syncTravelToCalendar`

Google Calendar API í†µí•© ë¼ì´ë¸ŒëŸ¬ë¦¬
Gmailì—ì„œ ì¶”ì¶œí•œ ì—¬í–‰ ì •ë³´ë¥¼ Google Calendarì— ë™ê¸°í™”
/

import { google } from 'googleapis'
import { TravelInfo } from './gmail'
import { normalizeDateString } from './email-intelligence'

export interface CalendarEvent {
id?: string
summary: string
description?: string
start: {
dateTime?: string
date?: string
timeZone?: string
}
end: {
dateTime?: string
date?: string
timeZone?: string
}
location?: string
attendees?: { email: string }[]
reminders?: {
useDefault?: boolean
overrides?: Array<{
method: 'email' | 'popup'
minutes: number
}>
}
colorId?: string
source?: {
title: string
url: string
}
}

export interface TravelCalendarEvent extends CalendarEvent {
travelType: 'departure' | 'return' | 'stay'
flightNumber?: string
bookingReference?: string
confidence: number
originalEmailId: string
}

/\*\*
Google Calendar API í´ë¼ì´ì–¸íŠ¸ ìƒì„±
/
export function createCalendarClient(accessToken: string) {
const oauth2Client = new google.auth.OAuth2(
process.env.GOOGLE_CLIENT_ID,
process.env.GOOGLE_CLIENT_SECRET
)

oauth2Client.setCredentials({
access_token: accessToken
})

return google.calendar({ version: 'v3', auth: oauth2Client })
}

/\*\*
Calendar API ì—°ê²° ìƒíƒœ í™•ì¸
/
export async function checkCalendarConnection(accessToken: string): Promise<boolean> {
try {
const calendar = createCalendarClient(accessToken)

    // ìº˜ë¦°ë” ëª©ë¡ ìš”ì²­ìœ¼ë¡œ ì—°ê²° í…ŒìŠ¤íŠ¸
    await calendar.calendarList.list({
      maxResults: 1
    })

    return true

} catch (error) {
// Calendar connection failed
return false
}
}

/\*\*
ì‚¬ìš©ìì˜ ìº˜ë¦°ë” ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
/
export async function getUserCalendars(accessToken: string) {
try {
const calendar = createCalendarClient(accessToken)

    const response = await calendar.calendarList.list({
      maxResults: 50
    })

    return response.data.items?.map(cal => ({
      id: cal.id || '',
      name: cal.summary || '',
      description: cal.description,
      primary: cal.primary || false,
      accessRole: cal.accessRole,
      backgroundColor: cal.backgroundColor,
      foregroundColor: cal.foregroundColor
    })) || []

} catch (error) {
// Error fetching calendars
throw new Error('ìº˜ë¦°ë” ëª©ë¡ì„ ê°€ì ¸ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.')
}
}

/\*\*
ì—¬í–‰ ì •ë³´ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ìº˜ë¦°ë” ì´ë²¤íŠ¸ ìƒì„±
/
export function createTravelEvents(travelInfo: TravelInfo): TravelCalendarEvent[] {
const events: TravelCalendarEvent[] = []
const airportCodes = {
'ICN': 'ì¸ì²œêµ­ì œê³µí•­', 'GMP': 'ê¹€í¬êµ­ì œê³µí•­', 'CJU': 'ì œì£¼êµ­ì œê³µí•­',
'NRT': 'ë‚˜ë¦¬íƒ€êµ­ì œê³µí•­', 'HND': 'í•˜ë„¤ë‹¤ê³µí•­', 'LAX': 'ë¡œìŠ¤ì•¤ì ¤ë ˆìŠ¤êµ­ì œê³µí•­'
// ë” ë§ì€ ê³µí•­ ì½”ë“œ ë§¤í•‘ì€ travel-patterns.tsì—ì„œ ê°€ì ¸ì˜¬ ìˆ˜ ìˆìŒ
}

// ì¶œë°œ ì´ë²¤íŠ¸
if (travelInfo.departureDate) {
const departureDate = normalizeDateString(travelInfo.departureDate)

    if (departureDate) {
      const departureLocation = travelInfo.departure ?
        (airportCodes[travelInfo.departure as keyof typeof airportCodes] || travelInfo.departure) :
        'ì¶œë°œì§€'

      const destinationLocation = travelInfo.destination ?
        (airportCodes[travelInfo.destination as keyof typeof airportCodes] || travelInfo.destination) :
        'ëª©ì ì§€'

      events.push({
        summary: `âœˆï¸ ${destinationLocation} ì¶œë°œ`,
        description: [
          `í•­ê³µí¸: ${travelInfo.flightNumber || 'ë¯¸ìƒ'}`,
          `ì˜ˆì•½ë²ˆí˜¸: ${travelInfo.bookingReference || 'ë¯¸ìƒ'}`,
          `ì¶œë°œì§€: ${departureLocation}`,
          `ëª©ì ì§€: ${destinationLocation}`,
          ``,
          `ğŸ“§ Gmailì—ì„œ ìë™ ì¶”ì¶œë¨`,
          `ì‹ ë¢°ë„: ${Math.round(travelInfo.confidence * 100)}%`
        ].join('\\n'),
        start: {
          date: departureDate,
          timeZone: 'Asia/Seoul'
        },
        end: {
          date: departureDate,
          timeZone: 'Asia/Seoul'
        },
        location: departureLocation,
        colorId: '11', // ë¹¨ê°„ìƒ‰ (ì¶œë°œ)
        reminders: {
          useDefault: false,
          overrides: [
            { method: 'popup', minutes: 24 * 60 }, // 1ì¼ ì „
            { method: 'popup', minutes: 2 * 60 },  // 2ì‹œê°„ ì „
            { method: 'email', minutes: 24 * 60 }  // 1ì¼ ì „ ì´ë©”ì¼
          ]
        },
        travelType: 'departure',
        flightNumber: travelInfo.flightNumber,
        bookingReference: travelInfo.bookingReference,
        confidence: travelInfo.confidence,
        originalEmailId: travelInfo.emailId
      })
    }

}

// ê·€êµ­ ì´ë²¤íŠ¸
if (travelInfo.returnDate) {
const returnDate = normalizeDateString(travelInfo.returnDate)

    if (returnDate) {
      const departureLocation = travelInfo.departure ?
        (airportCodes[travelInfo.departure as keyof typeof airportCodes] || travelInfo.departure) :
        'ì¶œë°œì§€'

      const destinationLocation = travelInfo.destination ?
        (airportCodes[travelInfo.destination as keyof typeof airportCodes] || travelInfo.destination) :
        'ëª©ì ì§€'

      events.push({
        summary: `ğŸ  ${departureLocation} ê·€êµ­`,
        description: [
          `í•­ê³µí¸: ${travelInfo.flightNumber || 'ë¯¸ìƒ'}`,
          `ì˜ˆì•½ë²ˆí˜¸: ${travelInfo.bookingReference || 'ë¯¸ìƒ'}`,
          `ì¶œë°œì§€: ${destinationLocation}`,
          `ë„ì°©ì§€: ${departureLocation}`,
          ``,
          `ğŸ“§ Gmailì—ì„œ ìë™ ì¶”ì¶œë¨`,
          `ì‹ ë¢°ë„: ${Math.round(travelInfo.confidence * 100)}%`
        ].join('\\n'),
        start: {
          date: returnDate,
          timeZone: 'Asia/Seoul'
        },
        end: {
          date: returnDate,
          timeZone: 'Asia/Seoul'
        },
        location: destinationLocation,
        colorId: '10', // ì´ˆë¡ìƒ‰ (ê·€êµ­)
        reminders: {
          useDefault: false,
          overrides: [
            { method: 'popup', minutes: 24 * 60 }, // 1ì¼ ì „
            { method: 'popup', minutes: 2 * 60 },  // 2ì‹œê°„ ì „
          ]
        },
        travelType: 'return',
        flightNumber: travelInfo.flightNumber,
        bookingReference: travelInfo.bookingReference,
        confidence: travelInfo.confidence,
        originalEmailId: travelInfo.emailId
      })
    }

}

// ìˆ™ë°• ê¸°ê°„ ì´ë²¤íŠ¸ (í˜¸í…”ì´ ìˆê³  ì¶œë°œì¼ê³¼ ê·€êµ­ì¼ì´ ëª¨ë‘ ìˆëŠ” ê²½ìš°)
if (travelInfo.hotelName && travelInfo.departureDate && travelInfo.returnDate) {
const depDate = normalizeDateString(travelInfo.departureDate)
const retDate = normalizeDateString(travelInfo.returnDate)

    if (depDate && retDate) {
      const destinationLocation = travelInfo.destination ?
        (airportCodes[travelInfo.destination as keyof typeof airportCodes] || travelInfo.destination) :
        'ëª©ì ì§€'

      events.push({
        summary: `ğŸ¨ ${travelInfo.hotelName}`,
        description: [
          `í˜¸í…”: ${travelInfo.hotelName}`,
          `ìœ„ì¹˜: ${destinationLocation}`,
          `ì˜ˆì•½ë²ˆí˜¸: ${travelInfo.bookingReference || 'ë¯¸ìƒ'}`,
          ``,
          `ğŸ“§ Gmailì—ì„œ ìë™ ì¶”ì¶œë¨`,
          `ì‹ ë¢°ë„: ${Math.round(travelInfo.confidence * 100)}%`
        ].join('\\n'),
        start: {
          date: depDate,
          timeZone: 'Asia/Seoul'
        },
        end: {
          date: retDate,
          timeZone: 'Asia/Seoul'
        },
        location: `${travelInfo.hotelName}, ${destinationLocation}`,
        colorId: '9', // íŒŒë€ìƒ‰ (ìˆ™ë°•)
        travelType: 'stay',
        bookingReference: travelInfo.bookingReference,
        confidence: travelInfo.confidence,
        originalEmailId: travelInfo.emailId
      })
    }

}

return events
}

/\*\*
ìº˜ë¦°ë”ì— ì´ë²¤íŠ¸ ìƒì„±
/
export async function createCalendarEvent(
accessToken: string,
calendarId: string,
event: TravelCalendarEvent
): Promise<string | null> {
try {
const calendar = createCalendarClient(accessToken)

    const response = await calendar.events.insert({
      calendarId,
      requestBody: {
        summary: event.summary,
        description: event.description,
        start: event.start,
        end: event.end,
        location: event.location,
        reminders: event.reminders,
        colorId: event.colorId,
        source: event.source
      }
    })

    return response.data.id || null

} catch (error) {
// Error creating calendar event
throw new Error('ìº˜ë¦°ë” ì´ë²¤íŠ¸ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.')
}
}

/\*\*
ì—¬í–‰ ì •ë³´ë¥¼ ìº˜ë¦°ë”ì— ë™ê¸°í™”

**íŠ¹ì„±:** `exported`, `async`

#### `findExistingTravelEvents`

Google Calendar API í†µí•© ë¼ì´ë¸ŒëŸ¬ë¦¬
Gmailì—ì„œ ì¶”ì¶œí•œ ì—¬í–‰ ì •ë³´ë¥¼ Google Calendarì— ë™ê¸°í™”
/

import { google } from 'googleapis'
import { TravelInfo } from './gmail'
import { normalizeDateString } from './email-intelligence'

export interface CalendarEvent {
id?: string
summary: string
description?: string
start: {
dateTime?: string
date?: string
timeZone?: string
}
end: {
dateTime?: string
date?: string
timeZone?: string
}
location?: string
attendees?: { email: string }[]
reminders?: {
useDefault?: boolean
overrides?: Array<{
method: 'email' | 'popup'
minutes: number
}>
}
colorId?: string
source?: {
title: string
url: string
}
}

export interface TravelCalendarEvent extends CalendarEvent {
travelType: 'departure' | 'return' | 'stay'
flightNumber?: string
bookingReference?: string
confidence: number
originalEmailId: string
}

/\*\*
Google Calendar API í´ë¼ì´ì–¸íŠ¸ ìƒì„±
/
export function createCalendarClient(accessToken: string) {
const oauth2Client = new google.auth.OAuth2(
process.env.GOOGLE_CLIENT_ID,
process.env.GOOGLE_CLIENT_SECRET
)

oauth2Client.setCredentials({
access_token: accessToken
})

return google.calendar({ version: 'v3', auth: oauth2Client })
}

/\*\*
Calendar API ì—°ê²° ìƒíƒœ í™•ì¸
/
export async function checkCalendarConnection(accessToken: string): Promise<boolean> {
try {
const calendar = createCalendarClient(accessToken)

    // ìº˜ë¦°ë” ëª©ë¡ ìš”ì²­ìœ¼ë¡œ ì—°ê²° í…ŒìŠ¤íŠ¸
    await calendar.calendarList.list({
      maxResults: 1
    })

    return true

} catch (error) {
// Calendar connection failed
return false
}
}

/\*\*
ì‚¬ìš©ìì˜ ìº˜ë¦°ë” ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
/
export async function getUserCalendars(accessToken: string) {
try {
const calendar = createCalendarClient(accessToken)

    const response = await calendar.calendarList.list({
      maxResults: 50
    })

    return response.data.items?.map(cal => ({
      id: cal.id || '',
      name: cal.summary || '',
      description: cal.description,
      primary: cal.primary || false,
      accessRole: cal.accessRole,
      backgroundColor: cal.backgroundColor,
      foregroundColor: cal.foregroundColor
    })) || []

} catch (error) {
// Error fetching calendars
throw new Error('ìº˜ë¦°ë” ëª©ë¡ì„ ê°€ì ¸ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.')
}
}

/\*\*
ì—¬í–‰ ì •ë³´ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ìº˜ë¦°ë” ì´ë²¤íŠ¸ ìƒì„±
/
export function createTravelEvents(travelInfo: TravelInfo): TravelCalendarEvent[] {
const events: TravelCalendarEvent[] = []
const airportCodes = {
'ICN': 'ì¸ì²œêµ­ì œê³µí•­', 'GMP': 'ê¹€í¬êµ­ì œê³µí•­', 'CJU': 'ì œì£¼êµ­ì œê³µí•­',
'NRT': 'ë‚˜ë¦¬íƒ€êµ­ì œê³µí•­', 'HND': 'í•˜ë„¤ë‹¤ê³µí•­', 'LAX': 'ë¡œìŠ¤ì•¤ì ¤ë ˆìŠ¤êµ­ì œê³µí•­'
// ë” ë§ì€ ê³µí•­ ì½”ë“œ ë§¤í•‘ì€ travel-patterns.tsì—ì„œ ê°€ì ¸ì˜¬ ìˆ˜ ìˆìŒ
}

// ì¶œë°œ ì´ë²¤íŠ¸
if (travelInfo.departureDate) {
const departureDate = normalizeDateString(travelInfo.departureDate)

    if (departureDate) {
      const departureLocation = travelInfo.departure ?
        (airportCodes[travelInfo.departure as keyof typeof airportCodes] || travelInfo.departure) :
        'ì¶œë°œì§€'

      const destinationLocation = travelInfo.destination ?
        (airportCodes[travelInfo.destination as keyof typeof airportCodes] || travelInfo.destination) :
        'ëª©ì ì§€'

      events.push({
        summary: `âœˆï¸ ${destinationLocation} ì¶œë°œ`,
        description: [
          `í•­ê³µí¸: ${travelInfo.flightNumber || 'ë¯¸ìƒ'}`,
          `ì˜ˆì•½ë²ˆí˜¸: ${travelInfo.bookingReference || 'ë¯¸ìƒ'}`,
          `ì¶œë°œì§€: ${departureLocation}`,
          `ëª©ì ì§€: ${destinationLocation}`,
          ``,
          `ğŸ“§ Gmailì—ì„œ ìë™ ì¶”ì¶œë¨`,
          `ì‹ ë¢°ë„: ${Math.round(travelInfo.confidence * 100)}%`
        ].join('\\n'),
        start: {
          date: departureDate,
          timeZone: 'Asia/Seoul'
        },
        end: {
          date: departureDate,
          timeZone: 'Asia/Seoul'
        },
        location: departureLocation,
        colorId: '11', // ë¹¨ê°„ìƒ‰ (ì¶œë°œ)
        reminders: {
          useDefault: false,
          overrides: [
            { method: 'popup', minutes: 24 * 60 }, // 1ì¼ ì „
            { method: 'popup', minutes: 2 * 60 },  // 2ì‹œê°„ ì „
            { method: 'email', minutes: 24 * 60 }  // 1ì¼ ì „ ì´ë©”ì¼
          ]
        },
        travelType: 'departure',
        flightNumber: travelInfo.flightNumber,
        bookingReference: travelInfo.bookingReference,
        confidence: travelInfo.confidence,
        originalEmailId: travelInfo.emailId
      })
    }

}

// ê·€êµ­ ì´ë²¤íŠ¸
if (travelInfo.returnDate) {
const returnDate = normalizeDateString(travelInfo.returnDate)

    if (returnDate) {
      const departureLocation = travelInfo.departure ?
        (airportCodes[travelInfo.departure as keyof typeof airportCodes] || travelInfo.departure) :
        'ì¶œë°œì§€'

      const destinationLocation = travelInfo.destination ?
        (airportCodes[travelInfo.destination as keyof typeof airportCodes] || travelInfo.destination) :
        'ëª©ì ì§€'

      events.push({
        summary: `ğŸ  ${departureLocation} ê·€êµ­`,
        description: [
          `í•­ê³µí¸: ${travelInfo.flightNumber || 'ë¯¸ìƒ'}`,
          `ì˜ˆì•½ë²ˆí˜¸: ${travelInfo.bookingReference || 'ë¯¸ìƒ'}`,
          `ì¶œë°œì§€: ${destinationLocation}`,
          `ë„ì°©ì§€: ${departureLocation}`,
          ``,
          `ğŸ“§ Gmailì—ì„œ ìë™ ì¶”ì¶œë¨`,
          `ì‹ ë¢°ë„: ${Math.round(travelInfo.confidence * 100)}%`
        ].join('\\n'),
        start: {
          date: returnDate,
          timeZone: 'Asia/Seoul'
        },
        end: {
          date: returnDate,
          timeZone: 'Asia/Seoul'
        },
        location: destinationLocation,
        colorId: '10', // ì´ˆë¡ìƒ‰ (ê·€êµ­)
        reminders: {
          useDefault: false,
          overrides: [
            { method: 'popup', minutes: 24 * 60 }, // 1ì¼ ì „
            { method: 'popup', minutes: 2 * 60 },  // 2ì‹œê°„ ì „
          ]
        },
        travelType: 'return',
        flightNumber: travelInfo.flightNumber,
        bookingReference: travelInfo.bookingReference,
        confidence: travelInfo.confidence,
        originalEmailId: travelInfo.emailId
      })
    }

}

// ìˆ™ë°• ê¸°ê°„ ì´ë²¤íŠ¸ (í˜¸í…”ì´ ìˆê³  ì¶œë°œì¼ê³¼ ê·€êµ­ì¼ì´ ëª¨ë‘ ìˆëŠ” ê²½ìš°)
if (travelInfo.hotelName && travelInfo.departureDate && travelInfo.returnDate) {
const depDate = normalizeDateString(travelInfo.departureDate)
const retDate = normalizeDateString(travelInfo.returnDate)

    if (depDate && retDate) {
      const destinationLocation = travelInfo.destination ?
        (airportCodes[travelInfo.destination as keyof typeof airportCodes] || travelInfo.destination) :
        'ëª©ì ì§€'

      events.push({
        summary: `ğŸ¨ ${travelInfo.hotelName}`,
        description: [
          `í˜¸í…”: ${travelInfo.hotelName}`,
          `ìœ„ì¹˜: ${destinationLocation}`,
          `ì˜ˆì•½ë²ˆí˜¸: ${travelInfo.bookingReference || 'ë¯¸ìƒ'}`,
          ``,
          `ğŸ“§ Gmailì—ì„œ ìë™ ì¶”ì¶œë¨`,
          `ì‹ ë¢°ë„: ${Math.round(travelInfo.confidence * 100)}%`
        ].join('\\n'),
        start: {
          date: depDate,
          timeZone: 'Asia/Seoul'
        },
        end: {
          date: retDate,
          timeZone: 'Asia/Seoul'
        },
        location: `${travelInfo.hotelName}, ${destinationLocation}`,
        colorId: '9', // íŒŒë€ìƒ‰ (ìˆ™ë°•)
        travelType: 'stay',
        bookingReference: travelInfo.bookingReference,
        confidence: travelInfo.confidence,
        originalEmailId: travelInfo.emailId
      })
    }

}

return events
}

/\*\*
ìº˜ë¦°ë”ì— ì´ë²¤íŠ¸ ìƒì„±
/
export async function createCalendarEvent(
accessToken: string,
calendarId: string,
event: TravelCalendarEvent
): Promise<string | null> {
try {
const calendar = createCalendarClient(accessToken)

    const response = await calendar.events.insert({
      calendarId,
      requestBody: {
        summary: event.summary,
        description: event.description,
        start: event.start,
        end: event.end,
        location: event.location,
        reminders: event.reminders,
        colorId: event.colorId,
        source: event.source
      }
    })

    return response.data.id || null

} catch (error) {
// Error creating calendar event
throw new Error('ìº˜ë¦°ë” ì´ë²¤íŠ¸ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.')
}
}

/\*\*
ì—¬í–‰ ì •ë³´ë¥¼ ìº˜ë¦°ë”ì— ë™ê¸°í™”
/
export async function syncTravelToCalendar(
accessToken: string,
calendarId: string,
travelInfos: TravelInfo[]
): Promise<{
success: boolean
created: number
errors: string[]
eventIds: string[]
}> {
const result = {
success: true,
created: 0,
errors: [] as string[],
eventIds: [] as string[]
}

try {
for (const travelInfo of travelInfos) {
// ì‹ ë¢°ë„ê°€ ë‚®ì€ ì—¬í–‰ ì •ë³´ëŠ” ê±´ë„ˆë›°ê¸°
if (travelInfo.confidence < 0.4) {
result.errors.push(`ë‚®ì€ ì‹ ë¢°ë„ë¡œ ì¸í•´ ê±´ë„ˆëœ€: ${travelInfo.subject} (${Math.round(travelInfo.confidence * 100)}%)`)
continue
}

      const events = createTravelEvents(travelInfo)

      for (const event of events) {
        try {
          const eventId = await createCalendarEvent(accessToken, calendarId, event)
          if (eventId) {
            result.eventIds.push(eventId)
            result.created++
          }
        } catch (error) {
          result.success = false
          result.errors.push(`ì´ë²¤íŠ¸ ìƒì„± ì‹¤íŒ¨: ${event.summary} - ${error instanceof Error ? error.message : 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜'}`)
        }
      }
    }

} catch (error) {
result.success = false
result.errors.push(`ë™ê¸°í™” ì¤‘ ì˜¤ë¥˜: ${error instanceof Error ? error.message : 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜'}`)
}

return result
}

/\*\*
ê¸°ì¡´ ì—¬í–‰ ì´ë²¤íŠ¸ ê²€ìƒ‰ (ì¤‘ë³µ ë°©ì§€)

**íŠ¹ì„±:** `exported`, `async`

#### `deleteCalendarEvent`

Google Calendar API í†µí•© ë¼ì´ë¸ŒëŸ¬ë¦¬
Gmailì—ì„œ ì¶”ì¶œí•œ ì—¬í–‰ ì •ë³´ë¥¼ Google Calendarì— ë™ê¸°í™”
/

import { google } from 'googleapis'
import { TravelInfo } from './gmail'
import { normalizeDateString } from './email-intelligence'

export interface CalendarEvent {
id?: string
summary: string
description?: string
start: {
dateTime?: string
date?: string
timeZone?: string
}
end: {
dateTime?: string
date?: string
timeZone?: string
}
location?: string
attendees?: { email: string }[]
reminders?: {
useDefault?: boolean
overrides?: Array<{
method: 'email' | 'popup'
minutes: number
}>
}
colorId?: string
source?: {
title: string
url: string
}
}

export interface TravelCalendarEvent extends CalendarEvent {
travelType: 'departure' | 'return' | 'stay'
flightNumber?: string
bookingReference?: string
confidence: number
originalEmailId: string
}

/\*\*
Google Calendar API í´ë¼ì´ì–¸íŠ¸ ìƒì„±
/
export function createCalendarClient(accessToken: string) {
const oauth2Client = new google.auth.OAuth2(
process.env.GOOGLE_CLIENT_ID,
process.env.GOOGLE_CLIENT_SECRET
)

oauth2Client.setCredentials({
access_token: accessToken
})

return google.calendar({ version: 'v3', auth: oauth2Client })
}

/\*\*
Calendar API ì—°ê²° ìƒíƒœ í™•ì¸
/
export async function checkCalendarConnection(accessToken: string): Promise<boolean> {
try {
const calendar = createCalendarClient(accessToken)

    // ìº˜ë¦°ë” ëª©ë¡ ìš”ì²­ìœ¼ë¡œ ì—°ê²° í…ŒìŠ¤íŠ¸
    await calendar.calendarList.list({
      maxResults: 1
    })

    return true

} catch (error) {
// Calendar connection failed
return false
}
}

/\*\*
ì‚¬ìš©ìì˜ ìº˜ë¦°ë” ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
/
export async function getUserCalendars(accessToken: string) {
try {
const calendar = createCalendarClient(accessToken)

    const response = await calendar.calendarList.list({
      maxResults: 50
    })

    return response.data.items?.map(cal => ({
      id: cal.id || '',
      name: cal.summary || '',
      description: cal.description,
      primary: cal.primary || false,
      accessRole: cal.accessRole,
      backgroundColor: cal.backgroundColor,
      foregroundColor: cal.foregroundColor
    })) || []

} catch (error) {
// Error fetching calendars
throw new Error('ìº˜ë¦°ë” ëª©ë¡ì„ ê°€ì ¸ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.')
}
}

/\*\*
ì—¬í–‰ ì •ë³´ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ìº˜ë¦°ë” ì´ë²¤íŠ¸ ìƒì„±
/
export function createTravelEvents(travelInfo: TravelInfo): TravelCalendarEvent[] {
const events: TravelCalendarEvent[] = []
const airportCodes = {
'ICN': 'ì¸ì²œêµ­ì œê³µí•­', 'GMP': 'ê¹€í¬êµ­ì œê³µí•­', 'CJU': 'ì œì£¼êµ­ì œê³µí•­',
'NRT': 'ë‚˜ë¦¬íƒ€êµ­ì œê³µí•­', 'HND': 'í•˜ë„¤ë‹¤ê³µí•­', 'LAX': 'ë¡œìŠ¤ì•¤ì ¤ë ˆìŠ¤êµ­ì œê³µí•­'
// ë” ë§ì€ ê³µí•­ ì½”ë“œ ë§¤í•‘ì€ travel-patterns.tsì—ì„œ ê°€ì ¸ì˜¬ ìˆ˜ ìˆìŒ
}

// ì¶œë°œ ì´ë²¤íŠ¸
if (travelInfo.departureDate) {
const departureDate = normalizeDateString(travelInfo.departureDate)

    if (departureDate) {
      const departureLocation = travelInfo.departure ?
        (airportCodes[travelInfo.departure as keyof typeof airportCodes] || travelInfo.departure) :
        'ì¶œë°œì§€'

      const destinationLocation = travelInfo.destination ?
        (airportCodes[travelInfo.destination as keyof typeof airportCodes] || travelInfo.destination) :
        'ëª©ì ì§€'

      events.push({
        summary: `âœˆï¸ ${destinationLocation} ì¶œë°œ`,
        description: [
          `í•­ê³µí¸: ${travelInfo.flightNumber || 'ë¯¸ìƒ'}`,
          `ì˜ˆì•½ë²ˆí˜¸: ${travelInfo.bookingReference || 'ë¯¸ìƒ'}`,
          `ì¶œë°œì§€: ${departureLocation}`,
          `ëª©ì ì§€: ${destinationLocation}`,
          ``,
          `ğŸ“§ Gmailì—ì„œ ìë™ ì¶”ì¶œë¨`,
          `ì‹ ë¢°ë„: ${Math.round(travelInfo.confidence * 100)}%`
        ].join('\\n'),
        start: {
          date: departureDate,
          timeZone: 'Asia/Seoul'
        },
        end: {
          date: departureDate,
          timeZone: 'Asia/Seoul'
        },
        location: departureLocation,
        colorId: '11', // ë¹¨ê°„ìƒ‰ (ì¶œë°œ)
        reminders: {
          useDefault: false,
          overrides: [
            { method: 'popup', minutes: 24 * 60 }, // 1ì¼ ì „
            { method: 'popup', minutes: 2 * 60 },  // 2ì‹œê°„ ì „
            { method: 'email', minutes: 24 * 60 }  // 1ì¼ ì „ ì´ë©”ì¼
          ]
        },
        travelType: 'departure',
        flightNumber: travelInfo.flightNumber,
        bookingReference: travelInfo.bookingReference,
        confidence: travelInfo.confidence,
        originalEmailId: travelInfo.emailId
      })
    }

}

// ê·€êµ­ ì´ë²¤íŠ¸
if (travelInfo.returnDate) {
const returnDate = normalizeDateString(travelInfo.returnDate)

    if (returnDate) {
      const departureLocation = travelInfo.departure ?
        (airportCodes[travelInfo.departure as keyof typeof airportCodes] || travelInfo.departure) :
        'ì¶œë°œì§€'

      const destinationLocation = travelInfo.destination ?
        (airportCodes[travelInfo.destination as keyof typeof airportCodes] || travelInfo.destination) :
        'ëª©ì ì§€'

      events.push({
        summary: `ğŸ  ${departureLocation} ê·€êµ­`,
        description: [
          `í•­ê³µí¸: ${travelInfo.flightNumber || 'ë¯¸ìƒ'}`,
          `ì˜ˆì•½ë²ˆí˜¸: ${travelInfo.bookingReference || 'ë¯¸ìƒ'}`,
          `ì¶œë°œì§€: ${destinationLocation}`,
          `ë„ì°©ì§€: ${departureLocation}`,
          ``,
          `ğŸ“§ Gmailì—ì„œ ìë™ ì¶”ì¶œë¨`,
          `ì‹ ë¢°ë„: ${Math.round(travelInfo.confidence * 100)}%`
        ].join('\\n'),
        start: {
          date: returnDate,
          timeZone: 'Asia/Seoul'
        },
        end: {
          date: returnDate,
          timeZone: 'Asia/Seoul'
        },
        location: destinationLocation,
        colorId: '10', // ì´ˆë¡ìƒ‰ (ê·€êµ­)
        reminders: {
          useDefault: false,
          overrides: [
            { method: 'popup', minutes: 24 * 60 }, // 1ì¼ ì „
            { method: 'popup', minutes: 2 * 60 },  // 2ì‹œê°„ ì „
          ]
        },
        travelType: 'return',
        flightNumber: travelInfo.flightNumber,
        bookingReference: travelInfo.bookingReference,
        confidence: travelInfo.confidence,
        originalEmailId: travelInfo.emailId
      })
    }

}

// ìˆ™ë°• ê¸°ê°„ ì´ë²¤íŠ¸ (í˜¸í…”ì´ ìˆê³  ì¶œë°œì¼ê³¼ ê·€êµ­ì¼ì´ ëª¨ë‘ ìˆëŠ” ê²½ìš°)
if (travelInfo.hotelName && travelInfo.departureDate && travelInfo.returnDate) {
const depDate = normalizeDateString(travelInfo.departureDate)
const retDate = normalizeDateString(travelInfo.returnDate)

    if (depDate && retDate) {
      const destinationLocation = travelInfo.destination ?
        (airportCodes[travelInfo.destination as keyof typeof airportCodes] || travelInfo.destination) :
        'ëª©ì ì§€'

      events.push({
        summary: `ğŸ¨ ${travelInfo.hotelName}`,
        description: [
          `í˜¸í…”: ${travelInfo.hotelName}`,
          `ìœ„ì¹˜: ${destinationLocation}`,
          `ì˜ˆì•½ë²ˆí˜¸: ${travelInfo.bookingReference || 'ë¯¸ìƒ'}`,
          ``,
          `ğŸ“§ Gmailì—ì„œ ìë™ ì¶”ì¶œë¨`,
          `ì‹ ë¢°ë„: ${Math.round(travelInfo.confidence * 100)}%`
        ].join('\\n'),
        start: {
          date: depDate,
          timeZone: 'Asia/Seoul'
        },
        end: {
          date: retDate,
          timeZone: 'Asia/Seoul'
        },
        location: `${travelInfo.hotelName}, ${destinationLocation}`,
        colorId: '9', // íŒŒë€ìƒ‰ (ìˆ™ë°•)
        travelType: 'stay',
        bookingReference: travelInfo.bookingReference,
        confidence: travelInfo.confidence,
        originalEmailId: travelInfo.emailId
      })
    }

}

return events
}

/\*\*
ìº˜ë¦°ë”ì— ì´ë²¤íŠ¸ ìƒì„±
/
export async function createCalendarEvent(
accessToken: string,
calendarId: string,
event: TravelCalendarEvent
): Promise<string | null> {
try {
const calendar = createCalendarClient(accessToken)

    const response = await calendar.events.insert({
      calendarId,
      requestBody: {
        summary: event.summary,
        description: event.description,
        start: event.start,
        end: event.end,
        location: event.location,
        reminders: event.reminders,
        colorId: event.colorId,
        source: event.source
      }
    })

    return response.data.id || null

} catch (error) {
// Error creating calendar event
throw new Error('ìº˜ë¦°ë” ì´ë²¤íŠ¸ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.')
}
}

/\*\*
ì—¬í–‰ ì •ë³´ë¥¼ ìº˜ë¦°ë”ì— ë™ê¸°í™”
/
export async function syncTravelToCalendar(
accessToken: string,
calendarId: string,
travelInfos: TravelInfo[]
): Promise<{
success: boolean
created: number
errors: string[]
eventIds: string[]
}> {
const result = {
success: true,
created: 0,
errors: [] as string[],
eventIds: [] as string[]
}

try {
for (const travelInfo of travelInfos) {
// ì‹ ë¢°ë„ê°€ ë‚®ì€ ì—¬í–‰ ì •ë³´ëŠ” ê±´ë„ˆë›°ê¸°
if (travelInfo.confidence < 0.4) {
result.errors.push(`ë‚®ì€ ì‹ ë¢°ë„ë¡œ ì¸í•´ ê±´ë„ˆëœ€: ${travelInfo.subject} (${Math.round(travelInfo.confidence * 100)}%)`)
continue
}

      const events = createTravelEvents(travelInfo)

      for (const event of events) {
        try {
          const eventId = await createCalendarEvent(accessToken, calendarId, event)
          if (eventId) {
            result.eventIds.push(eventId)
            result.created++
          }
        } catch (error) {
          result.success = false
          result.errors.push(`ì´ë²¤íŠ¸ ìƒì„± ì‹¤íŒ¨: ${event.summary} - ${error instanceof Error ? error.message : 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜'}`)
        }
      }
    }

} catch (error) {
result.success = false
result.errors.push(`ë™ê¸°í™” ì¤‘ ì˜¤ë¥˜: ${error instanceof Error ? error.message : 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜'}`)
}

return result
}

/\*\*
ê¸°ì¡´ ì—¬í–‰ ì´ë²¤íŠ¸ ê²€ìƒ‰ (ì¤‘ë³µ ë°©ì§€)
/
export async function findExistingTravelEvents(
accessToken: string,
calendarId: string,
emailId: string
): Promise<CalendarEvent[]> {
try {
const calendar = createCalendarClient(accessToken)

    // ìµœê·¼ 6ê°œì›” ë²”ìœ„ì—ì„œ ê²€ìƒ‰
    const timeMin = new Date()
    timeMin.setMonth(timeMin.getMonth() - 6)

    const timeMax = new Date()
    timeMax.setMonth(timeMax.getMonth() + 6)

    const response = await calendar.events.list({
      calendarId,
      timeMin: timeMin.toISOString(),
      timeMax: timeMax.toISOString(),
      q: emailId, // ì´ë²¤íŠ¸ ì„¤ëª…ì—ì„œ emailId ê²€ìƒ‰
      maxResults: 100
    })

    return response.data.items?.filter(event =>
      event.description?.includes(emailId)
    ).map(event => ({
      id: event.id || undefined,
      summary: event.summary || '',
      description: event.description || undefined,
      start: {
        dateTime: event.start?.dateTime || undefined,
        date: event.start?.date || undefined,
        timeZone: event.start?.timeZone || undefined
      },
      end: {
        dateTime: event.end?.dateTime || undefined,
        date: event.end?.date || undefined,
        timeZone: event.end?.timeZone || undefined
      },
      location: event.location || undefined
    })) || []

} catch (error) {
// Error finding existing events
return []
}
}

/\*\*
ìº˜ë¦°ë” ì´ë²¤íŠ¸ ì‚­ì œ

**íŠ¹ì„±:** `exported`, `async`

### ğŸ”— Interfaces

#### `CalendarEvent`

**íŠ¹ì„±:** `exported`

#### `TravelCalendarEvent`

**íŠ¹ì„±:** `exported`

## environment.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/config/environment.ts`

**ì„¤ëª…:** Environment configuration for DiNoCal
Handles development, staging, and production environments

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 5324 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 195
- ğŸ”§ í•¨ìˆ˜: 5ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 0ê°œ

**Exports:**

- `env`
- `validateEnvironment`
- `getDatabaseConfig`
- `getCacheConfig`
- `getRateLimitConfig`
- `getSecurityConfig`
- `config`

### ğŸ”§ Functions

#### `validateEnvironment`

Environment configuration for DiNoCal
Handles development, staging, and production environments
/

export const env = {
// Environment detection
NODE_ENV: process.env.NODE_ENV || 'development',
isDevelopment: process.env.NODE_ENV === 'development',
isProduction: process.env.NODE_ENV === 'production',
isTest: process.env.NODE_ENV === 'test',

// Database
DATABASE_URL: process.env.DATABASE_URL || 'file:./dev.db',

// NextAuth
NEXTAUTH_URL: process.env.NEXTAUTH_URL || 'http://localhost:3000',
NEXTAUTH_SECRET: process.env.NEXTAUTH_SECRET || '',

// Google OAuth
GOOGLE_CLIENT_ID: process.env.GOOGLE_CLIENT_ID || '',
GOOGLE_CLIENT_SECRET: process.env.GOOGLE_CLIENT_SECRET || '',

// Gmail API
GMAIL_CREDENTIALS_PATH: process.env.GMAIL_CREDENTIALS_PATH || '',
GMAIL_TOKEN_PATH: process.env.GMAIL_TOKEN_PATH || '',

// Public features
ENABLE_GMAIL_INTEGRATION: process.env.NEXT_PUBLIC_ENABLE_GMAIL_INTEGRATION === 'true',
ENABLE_NOTIFICATIONS: process.env.NEXT_PUBLIC_ENABLE_NOTIFICATIONS === 'true',
ENABLE_ANALYTICS: process.env.NEXT_PUBLIC_ENABLE_ANALYTICS === 'true',

// API Configuration
API_RATE_LIMIT_REQUESTS: parseInt(process.env.API_RATE_LIMIT_REQUESTS || '100'),
API_RATE_LIMIT_WINDOW: parseInt(process.env.API_RATE_LIMIT_WINDOW || '60000'),

// Cache Configuration
CACHE_TTL_SECONDS: parseInt(process.env.CACHE_TTL_SECONDS || '300'),
ENABLE_REDIS_CACHE: process.env.ENABLE_REDIS_CACHE === 'true',
REDIS_URL: process.env.REDIS_URL || '',

// Security
ENCRYPTION_KEY: process.env.ENCRYPTION_KEY || '',
SESSION_MAX_AGE: parseInt(process.env.SESSION_MAX_AGE || '2592000'), // 30 days

// Monitoring
ANALYTICS_ID: process.env.NEXT_PUBLIC_ANALYTICS_ID || '',
SENTRY_DSN: process.env.SENTRY_DSN || '',

// Logging
LOG_LEVEL: process.env.LOG_LEVEL || 'info'
} as const

/\*\*
Validate required environment variables

**íŠ¹ì„±:** `exported`

#### `getDatabaseConfig`

Environment configuration for DiNoCal
Handles development, staging, and production environments
/

export const env = {
// Environment detection
NODE_ENV: process.env.NODE_ENV || 'development',
isDevelopment: process.env.NODE_ENV === 'development',
isProduction: process.env.NODE_ENV === 'production',
isTest: process.env.NODE_ENV === 'test',

// Database
DATABASE_URL: process.env.DATABASE_URL || 'file:./dev.db',

// NextAuth
NEXTAUTH_URL: process.env.NEXTAUTH_URL || 'http://localhost:3000',
NEXTAUTH_SECRET: process.env.NEXTAUTH_SECRET || '',

// Google OAuth
GOOGLE_CLIENT_ID: process.env.GOOGLE_CLIENT_ID || '',
GOOGLE_CLIENT_SECRET: process.env.GOOGLE_CLIENT_SECRET || '',

// Gmail API
GMAIL_CREDENTIALS_PATH: process.env.GMAIL_CREDENTIALS_PATH || '',
GMAIL_TOKEN_PATH: process.env.GMAIL_TOKEN_PATH || '',

// Public features
ENABLE_GMAIL_INTEGRATION: process.env.NEXT_PUBLIC_ENABLE_GMAIL_INTEGRATION === 'true',
ENABLE_NOTIFICATIONS: process.env.NEXT_PUBLIC_ENABLE_NOTIFICATIONS === 'true',
ENABLE_ANALYTICS: process.env.NEXT_PUBLIC_ENABLE_ANALYTICS === 'true',

// API Configuration
API_RATE_LIMIT_REQUESTS: parseInt(process.env.API_RATE_LIMIT_REQUESTS || '100'),
API_RATE_LIMIT_WINDOW: parseInt(process.env.API_RATE_LIMIT_WINDOW || '60000'),

// Cache Configuration
CACHE_TTL_SECONDS: parseInt(process.env.CACHE_TTL_SECONDS || '300'),
ENABLE_REDIS_CACHE: process.env.ENABLE_REDIS_CACHE === 'true',
REDIS_URL: process.env.REDIS_URL || '',

// Security
ENCRYPTION_KEY: process.env.ENCRYPTION_KEY || '',
SESSION_MAX_AGE: parseInt(process.env.SESSION_MAX_AGE || '2592000'), // 30 days

// Monitoring
ANALYTICS_ID: process.env.NEXT_PUBLIC_ANALYTICS_ID || '',
SENTRY_DSN: process.env.SENTRY_DSN || '',

// Logging
LOG_LEVEL: process.env.LOG_LEVEL || 'info'
} as const

/\*\*
Validate required environment variables
/
export function validateEnvironment(): { isValid: boolean; errors: string[] } {
const errors: string[] = []

// Required in production
if (env.isProduction) {
if (!env.NEXTAUTH_SECRET) {
errors.push('NEXTAUTH_SECRET is required in production')
}

    if (!env.GOOGLE_CLIENT_ID) {
      errors.push('GOOGLE_CLIENT_ID is required')
    }

    if (!env.GOOGLE_CLIENT_SECRET) {
      errors.push('GOOGLE_CLIENT_SECRET is required')
    }

    if (!env.DATABASE_URL) {
      errors.push('DATABASE_URL is required')
    }

    if (env.ENABLE_GMAIL_INTEGRATION && !env.GMAIL_CREDENTIALS_PATH) {
      errors.push('GMAIL_CREDENTIALS_PATH is required when Gmail integration is enabled')
    }

}

// Always required
if (!env.NEXTAUTH_URL) {
errors.push('NEXTAUTH_URL is required')
}

return {
isValid: errors.length === 0,
errors
}
}

/\*\*
Get database configuration based on environment

**íŠ¹ì„±:** `exported`

#### `getCacheConfig`

Environment configuration for DiNoCal
Handles development, staging, and production environments
/

export const env = {
// Environment detection
NODE_ENV: process.env.NODE_ENV || 'development',
isDevelopment: process.env.NODE_ENV === 'development',
isProduction: process.env.NODE_ENV === 'production',
isTest: process.env.NODE_ENV === 'test',

// Database
DATABASE_URL: process.env.DATABASE_URL || 'file:./dev.db',

// NextAuth
NEXTAUTH_URL: process.env.NEXTAUTH_URL || 'http://localhost:3000',
NEXTAUTH_SECRET: process.env.NEXTAUTH_SECRET || '',

// Google OAuth
GOOGLE_CLIENT_ID: process.env.GOOGLE_CLIENT_ID || '',
GOOGLE_CLIENT_SECRET: process.env.GOOGLE_CLIENT_SECRET || '',

// Gmail API
GMAIL_CREDENTIALS_PATH: process.env.GMAIL_CREDENTIALS_PATH || '',
GMAIL_TOKEN_PATH: process.env.GMAIL_TOKEN_PATH || '',

// Public features
ENABLE_GMAIL_INTEGRATION: process.env.NEXT_PUBLIC_ENABLE_GMAIL_INTEGRATION === 'true',
ENABLE_NOTIFICATIONS: process.env.NEXT_PUBLIC_ENABLE_NOTIFICATIONS === 'true',
ENABLE_ANALYTICS: process.env.NEXT_PUBLIC_ENABLE_ANALYTICS === 'true',

// API Configuration
API_RATE_LIMIT_REQUESTS: parseInt(process.env.API_RATE_LIMIT_REQUESTS || '100'),
API_RATE_LIMIT_WINDOW: parseInt(process.env.API_RATE_LIMIT_WINDOW || '60000'),

// Cache Configuration
CACHE_TTL_SECONDS: parseInt(process.env.CACHE_TTL_SECONDS || '300'),
ENABLE_REDIS_CACHE: process.env.ENABLE_REDIS_CACHE === 'true',
REDIS_URL: process.env.REDIS_URL || '',

// Security
ENCRYPTION_KEY: process.env.ENCRYPTION_KEY || '',
SESSION_MAX_AGE: parseInt(process.env.SESSION_MAX_AGE || '2592000'), // 30 days

// Monitoring
ANALYTICS_ID: process.env.NEXT_PUBLIC_ANALYTICS_ID || '',
SENTRY_DSN: process.env.SENTRY_DSN || '',

// Logging
LOG_LEVEL: process.env.LOG_LEVEL || 'info'
} as const

/\*\*
Validate required environment variables
/
export function validateEnvironment(): { isValid: boolean; errors: string[] } {
const errors: string[] = []

// Required in production
if (env.isProduction) {
if (!env.NEXTAUTH_SECRET) {
errors.push('NEXTAUTH_SECRET is required in production')
}

    if (!env.GOOGLE_CLIENT_ID) {
      errors.push('GOOGLE_CLIENT_ID is required')
    }

    if (!env.GOOGLE_CLIENT_SECRET) {
      errors.push('GOOGLE_CLIENT_SECRET is required')
    }

    if (!env.DATABASE_URL) {
      errors.push('DATABASE_URL is required')
    }

    if (env.ENABLE_GMAIL_INTEGRATION && !env.GMAIL_CREDENTIALS_PATH) {
      errors.push('GMAIL_CREDENTIALS_PATH is required when Gmail integration is enabled')
    }

}

// Always required
if (!env.NEXTAUTH_URL) {
errors.push('NEXTAUTH_URL is required')
}

return {
isValid: errors.length === 0,
errors
}
}

/\*\*
Get database configuration based on environment
/
export function getDatabaseConfig() {
if (env.isProduction) {
return {
url: env.DATABASE_URL,
// Production optimizations
connectionLimit: 20,
idleTimeout: 30000,
acquireTimeout: 60000,
ssl: env.DATABASE_URL.includes('postgresql') ? { rejectUnauthorized: false } : false
}
}

return {
url: env.DATABASE_URL,
connectionLimit: 5,
idleTimeout: 10000
}
}

/\*\*
Get cache configuration

**íŠ¹ì„±:** `exported`

#### `getRateLimitConfig`

Environment configuration for DiNoCal
Handles development, staging, and production environments
/

export const env = {
// Environment detection
NODE_ENV: process.env.NODE_ENV || 'development',
isDevelopment: process.env.NODE_ENV === 'development',
isProduction: process.env.NODE_ENV === 'production',
isTest: process.env.NODE_ENV === 'test',

// Database
DATABASE_URL: process.env.DATABASE_URL || 'file:./dev.db',

// NextAuth
NEXTAUTH_URL: process.env.NEXTAUTH_URL || 'http://localhost:3000',
NEXTAUTH_SECRET: process.env.NEXTAUTH_SECRET || '',

// Google OAuth
GOOGLE_CLIENT_ID: process.env.GOOGLE_CLIENT_ID || '',
GOOGLE_CLIENT_SECRET: process.env.GOOGLE_CLIENT_SECRET || '',

// Gmail API
GMAIL_CREDENTIALS_PATH: process.env.GMAIL_CREDENTIALS_PATH || '',
GMAIL_TOKEN_PATH: process.env.GMAIL_TOKEN_PATH || '',

// Public features
ENABLE_GMAIL_INTEGRATION: process.env.NEXT_PUBLIC_ENABLE_GMAIL_INTEGRATION === 'true',
ENABLE_NOTIFICATIONS: process.env.NEXT_PUBLIC_ENABLE_NOTIFICATIONS === 'true',
ENABLE_ANALYTICS: process.env.NEXT_PUBLIC_ENABLE_ANALYTICS === 'true',

// API Configuration
API_RATE_LIMIT_REQUESTS: parseInt(process.env.API_RATE_LIMIT_REQUESTS || '100'),
API_RATE_LIMIT_WINDOW: parseInt(process.env.API_RATE_LIMIT_WINDOW || '60000'),

// Cache Configuration
CACHE_TTL_SECONDS: parseInt(process.env.CACHE_TTL_SECONDS || '300'),
ENABLE_REDIS_CACHE: process.env.ENABLE_REDIS_CACHE === 'true',
REDIS_URL: process.env.REDIS_URL || '',

// Security
ENCRYPTION_KEY: process.env.ENCRYPTION_KEY || '',
SESSION_MAX_AGE: parseInt(process.env.SESSION_MAX_AGE || '2592000'), // 30 days

// Monitoring
ANALYTICS_ID: process.env.NEXT_PUBLIC_ANALYTICS_ID || '',
SENTRY_DSN: process.env.SENTRY_DSN || '',

// Logging
LOG_LEVEL: process.env.LOG_LEVEL || 'info'
} as const

/\*\*
Validate required environment variables
/
export function validateEnvironment(): { isValid: boolean; errors: string[] } {
const errors: string[] = []

// Required in production
if (env.isProduction) {
if (!env.NEXTAUTH_SECRET) {
errors.push('NEXTAUTH_SECRET is required in production')
}

    if (!env.GOOGLE_CLIENT_ID) {
      errors.push('GOOGLE_CLIENT_ID is required')
    }

    if (!env.GOOGLE_CLIENT_SECRET) {
      errors.push('GOOGLE_CLIENT_SECRET is required')
    }

    if (!env.DATABASE_URL) {
      errors.push('DATABASE_URL is required')
    }

    if (env.ENABLE_GMAIL_INTEGRATION && !env.GMAIL_CREDENTIALS_PATH) {
      errors.push('GMAIL_CREDENTIALS_PATH is required when Gmail integration is enabled')
    }

}

// Always required
if (!env.NEXTAUTH_URL) {
errors.push('NEXTAUTH_URL is required')
}

return {
isValid: errors.length === 0,
errors
}
}

/\*\*
Get database configuration based on environment
/
export function getDatabaseConfig() {
if (env.isProduction) {
return {
url: env.DATABASE_URL,
// Production optimizations
connectionLimit: 20,
idleTimeout: 30000,
acquireTimeout: 60000,
ssl: env.DATABASE_URL.includes('postgresql') ? { rejectUnauthorized: false } : false
}
}

return {
url: env.DATABASE_URL,
connectionLimit: 5,
idleTimeout: 10000
}
}

/\*_
Get cache configuration
/
export function getCacheConfig() {
return {
ttl: env.CACHE_TTL_SECONDS _ 1000, // Convert to milliseconds
useRedis: env.ENABLE_REDIS_CACHE && env.isProduction,
redisUrl: env.REDIS_URL,
memoryLimit: env.isProduction ? 100 : 50, // MB
cleanupInterval: 60000 // 1 minute
}
}

/\*\*
Get API rate limiting configuration

**íŠ¹ì„±:** `exported`

#### `getSecurityConfig`

Environment configuration for DiNoCal
Handles development, staging, and production environments
/

export const env = {
// Environment detection
NODE_ENV: process.env.NODE_ENV || 'development',
isDevelopment: process.env.NODE_ENV === 'development',
isProduction: process.env.NODE_ENV === 'production',
isTest: process.env.NODE_ENV === 'test',

// Database
DATABASE_URL: process.env.DATABASE_URL || 'file:./dev.db',

// NextAuth
NEXTAUTH_URL: process.env.NEXTAUTH_URL || 'http://localhost:3000',
NEXTAUTH_SECRET: process.env.NEXTAUTH_SECRET || '',

// Google OAuth
GOOGLE_CLIENT_ID: process.env.GOOGLE_CLIENT_ID || '',
GOOGLE_CLIENT_SECRET: process.env.GOOGLE_CLIENT_SECRET || '',

// Gmail API
GMAIL_CREDENTIALS_PATH: process.env.GMAIL_CREDENTIALS_PATH || '',
GMAIL_TOKEN_PATH: process.env.GMAIL_TOKEN_PATH || '',

// Public features
ENABLE_GMAIL_INTEGRATION: process.env.NEXT_PUBLIC_ENABLE_GMAIL_INTEGRATION === 'true',
ENABLE_NOTIFICATIONS: process.env.NEXT_PUBLIC_ENABLE_NOTIFICATIONS === 'true',
ENABLE_ANALYTICS: process.env.NEXT_PUBLIC_ENABLE_ANALYTICS === 'true',

// API Configuration
API_RATE_LIMIT_REQUESTS: parseInt(process.env.API_RATE_LIMIT_REQUESTS || '100'),
API_RATE_LIMIT_WINDOW: parseInt(process.env.API_RATE_LIMIT_WINDOW || '60000'),

// Cache Configuration
CACHE_TTL_SECONDS: parseInt(process.env.CACHE_TTL_SECONDS || '300'),
ENABLE_REDIS_CACHE: process.env.ENABLE_REDIS_CACHE === 'true',
REDIS_URL: process.env.REDIS_URL || '',

// Security
ENCRYPTION_KEY: process.env.ENCRYPTION_KEY || '',
SESSION_MAX_AGE: parseInt(process.env.SESSION_MAX_AGE || '2592000'), // 30 days

// Monitoring
ANALYTICS_ID: process.env.NEXT_PUBLIC_ANALYTICS_ID || '',
SENTRY_DSN: process.env.SENTRY_DSN || '',

// Logging
LOG_LEVEL: process.env.LOG_LEVEL || 'info'
} as const

/\*\*
Validate required environment variables
/
export function validateEnvironment(): { isValid: boolean; errors: string[] } {
const errors: string[] = []

// Required in production
if (env.isProduction) {
if (!env.NEXTAUTH_SECRET) {
errors.push('NEXTAUTH_SECRET is required in production')
}

    if (!env.GOOGLE_CLIENT_ID) {
      errors.push('GOOGLE_CLIENT_ID is required')
    }

    if (!env.GOOGLE_CLIENT_SECRET) {
      errors.push('GOOGLE_CLIENT_SECRET is required')
    }

    if (!env.DATABASE_URL) {
      errors.push('DATABASE_URL is required')
    }

    if (env.ENABLE_GMAIL_INTEGRATION && !env.GMAIL_CREDENTIALS_PATH) {
      errors.push('GMAIL_CREDENTIALS_PATH is required when Gmail integration is enabled')
    }

}

// Always required
if (!env.NEXTAUTH_URL) {
errors.push('NEXTAUTH_URL is required')
}

return {
isValid: errors.length === 0,
errors
}
}

/\*\*
Get database configuration based on environment
/
export function getDatabaseConfig() {
if (env.isProduction) {
return {
url: env.DATABASE_URL,
// Production optimizations
connectionLimit: 20,
idleTimeout: 30000,
acquireTimeout: 60000,
ssl: env.DATABASE_URL.includes('postgresql') ? { rejectUnauthorized: false } : false
}
}

return {
url: env.DATABASE_URL,
connectionLimit: 5,
idleTimeout: 10000
}
}

/\*_
Get cache configuration
/
export function getCacheConfig() {
return {
ttl: env.CACHE_TTL_SECONDS _ 1000, // Convert to milliseconds
useRedis: env.ENABLE_REDIS_CACHE && env.isProduction,
redisUrl: env.REDIS_URL,
memoryLimit: env.isProduction ? 100 : 50, // MB
cleanupInterval: 60000 // 1 minute
}
}

/\*\*
Get API rate limiting configuration
/
export function getRateLimitConfig() {
return {
requests: env.API_RATE_LIMIT_REQUESTS,
window: env.API_RATE_LIMIT_WINDOW,
skipSuccessfulRequests: false,
skipFailedRequests: false,
keyPrefix: 'dinocal:ratelimit:',
// More lenient in development
multiplier: env.isDevelopment ? 10 : 1
}
}

/\*\*
Get security headers configuration

**íŠ¹ì„±:** `exported`

## connection-manager.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/database/connection-manager.ts`

**ì„¤ëª…:** Database Connection Manager
Handles connection pooling, retry logic, and health monitoring

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 9853 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 382
- ğŸ”§ í•¨ìˆ˜: 3ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 1ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 2ê°œ

**Exports:**

- `ConnectionOptions`
- `ConnectionHealth`
- `DatabaseConnectionManager`
- `dbManager`
- `async`
- `getDbHealth`
- `isDbHealthy`

### ğŸ”§ Functions

#### `getPrismaClient`

**íŠ¹ì„±:** `exported`, `async`

#### `getDbHealth`

**íŠ¹ì„±:** `exported`

#### `isDbHealthy`

**íŠ¹ì„±:** `exported`

### ğŸ“¦ Classes

#### `DatabaseConnectionManager`

**íŠ¹ì„±:** `exported`

### ğŸ”— Interfaces

#### `ConnectionOptions`

**íŠ¹ì„±:** `exported`

#### `ConnectionHealth`

**íŠ¹ì„±:** `exported`

## connection-pool-v2.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/database/connection-pool-v2.ts`

**ì„¤ëª…:** Simplified connection pool for testing

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 6212 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 238
- ğŸ”§ í•¨ìˆ˜: 0ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 1ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 2ê°œ

**Exports:**

- `PoolConfig`
- `PoolStats`
- `enum`
- `ConnectionPool`

### ğŸ“¦ Classes

#### `ConnectionPool`

**íŠ¹ì„±:** `exported`

### ğŸ”— Interfaces

#### `PoolConfig`

**íŠ¹ì„±:** `exported`

#### `PoolStats`

**íŠ¹ì„±:** `exported`

## connection-pool.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/database/connection-pool.ts`

**ì„¤ëª…:** Database Connection Pool Management for Production
í”„ë¡œë•ì…˜ í™˜ê²½ì„ ìœ„í•œ ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° í’€ ê´€ë¦¬

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 4991 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 199
- ğŸ”§ í•¨ìˆ˜: 0ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 1ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 1ê°œ

**Exports:**

- `dbPool`
- `prisma`

### ğŸ“¦ Classes

#### `DatabaseConnectionPool`

### ğŸ”— Interfaces

#### `ConnectionPoolConfig`

## dev-prisma.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/database/dev-prisma.ts`

**ì„¤ëª…:** Development Prisma Client for SQLite
This file provides a simple Prisma client for local development with SQLite
Enhanced with connection recovery and error handling

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 1252 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 35
- ğŸ”§ í•¨ìˆ˜: 1ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 0ê°œ

**Exports:**

- `devPrisma`
- `isDevelopment`
- `getPrismaClient`

### ğŸ”§ Functions

#### `getPrismaClient`

**íŠ¹ì„±:** `exported`, `async`

## optimized-queries.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/database/optimized-queries.ts`

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 8585 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 397
- ğŸ”§ í•¨ìˆ˜: 8ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 2ê°œ

**Exports:**

- `TripQueryOptions`
- `SchengenQueryOptions`
- `async`
- `prisma`

### ğŸ”§ Functions

#### `getUserTrips`

Optimized database queries for DiNoCal
Uses proper indexes and query optimization techniques
/

export interface TripQueryOptions {
userId: string
limit?: number
offset?: number
country?: string
visaType?: string
dateFrom?: Date
dateTo?: Date
orderBy?: 'entryDate' | 'createdAt'
orderDirection?: 'asc' | 'desc'
}

export interface SchengenQueryOptions {
userId: string
fromDate?: Date
toDate?: Date
passportCountry?: string
}

/\*\*
Get user trips with optimized filtering and pagination

**íŠ¹ì„±:** `exported`, `async`

#### `getSchengenTrips`

Optimized database queries for DiNoCal
Uses proper indexes and query optimization techniques
/

export interface TripQueryOptions {
userId: string
limit?: number
offset?: number
country?: string
visaType?: string
dateFrom?: Date
dateTo?: Date
orderBy?: 'entryDate' | 'createdAt'
orderDirection?: 'asc' | 'desc'
}

export interface SchengenQueryOptions {
userId: string
fromDate?: Date
toDate?: Date
passportCountry?: string
}

/\*\*
Get user trips with optimized filtering and pagination
/
export async function getUserTrips(options: TripQueryOptions): Promise<CountryVisit[]> {
const {
userId,
limit = 50,
offset = 0,
country,
visaType,
dateFrom,
dateTo,
orderBy = 'entryDate',
orderDirection = 'desc'
} = options

const where: any = { userId }

// Add filters
if (country) {
where.country = country
}

if (visaType) {
where.visaType = visaType
}

if (dateFrom || dateTo) {
where.entryDate = {}
if (dateFrom) {
where.entryDate.gte = dateFrom
}
if (dateTo) {
where.entryDate.lte = dateTo
}
}

// Use optimized query with proper indexes
const trips = await prisma.countryVisit.findMany({
where,
orderBy: {
[orderBy]: orderDirection
},
take: limit,
skip: offset,
select: {
id: true,
userId: true,
country: true,
entryDate: true,
exitDate: true,
visaType: true,
maxDays: true,
passportCountry: true,
notes: true,
createdAt: true,
updatedAt: true
}
})

return trips.map(trip => ({
...trip,
entryDate: trip.entryDate.toISOString(),
exitDate: trip.exitDate?.toISOString() || null,
visaType: trip.visaType as any,
passportCountry: trip.passportCountry as any
})) as CountryVisit[]
}

/\*\*
Get trips for Schengen calculation (optimized for date ranges)

**íŠ¹ì„±:** `exported`, `async`

#### `getUserStats`

Optimized database queries for DiNoCal
Uses proper indexes and query optimization techniques
/

export interface TripQueryOptions {
userId: string
limit?: number
offset?: number
country?: string
visaType?: string
dateFrom?: Date
dateTo?: Date
orderBy?: 'entryDate' | 'createdAt'
orderDirection?: 'asc' | 'desc'
}

export interface SchengenQueryOptions {
userId: string
fromDate?: Date
toDate?: Date
passportCountry?: string
}

/\*\*
Get user trips with optimized filtering and pagination
/
export async function getUserTrips(options: TripQueryOptions): Promise<CountryVisit[]> {
const {
userId,
limit = 50,
offset = 0,
country,
visaType,
dateFrom,
dateTo,
orderBy = 'entryDate',
orderDirection = 'desc'
} = options

const where: any = { userId }

// Add filters
if (country) {
where.country = country
}

if (visaType) {
where.visaType = visaType
}

if (dateFrom || dateTo) {
where.entryDate = {}
if (dateFrom) {
where.entryDate.gte = dateFrom
}
if (dateTo) {
where.entryDate.lte = dateTo
}
}

// Use optimized query with proper indexes
const trips = await prisma.countryVisit.findMany({
where,
orderBy: {
[orderBy]: orderDirection
},
take: limit,
skip: offset,
select: {
id: true,
userId: true,
country: true,
entryDate: true,
exitDate: true,
visaType: true,
maxDays: true,
passportCountry: true,
notes: true,
createdAt: true,
updatedAt: true
}
})

return trips.map(trip => ({
...trip,
entryDate: trip.entryDate.toISOString(),
exitDate: trip.exitDate?.toISOString() || null,
visaType: trip.visaType as any,
passportCountry: trip.passportCountry as any
})) as CountryVisit[]
}

/\*\*
Get trips for Schengen calculation (optimized for date ranges)
/
export async function getSchengenTrips(options: SchengenQueryOptions): Promise<CountryVisit[]> {
const { userId, fromDate, toDate, passportCountry } = options

const where: any = {
userId,
country: {
in: getSchengenCountries() // List of Schengen countries
}
}

if (passportCountry) {
where.passportCountry = passportCountry
}

if (fromDate || toDate) {
where.OR = [
// Entry date in range
{
entryDate: {
gte: fromDate,
lte: toDate
}
},
// Exit date in range
{
exitDate: {
gte: fromDate,
lte: toDate
}
},
// Trip spans the entire range
{
AND: [
{ entryDate: { lte: fromDate } },
{
OR: [
{ exitDate: { gte: toDate } },
{ exitDate: null } // Still in country
]
}
]
}
]
}

// Use compound index [userId, entryDate, exitDate]
const trips = await prisma.countryVisit.findMany({
where,
orderBy: {
entryDate: 'asc'
},
select: {
id: true,
country: true,
entryDate: true,
exitDate: true,
visaType: true,
maxDays: true,
passportCountry: true
}
})

return trips.map(trip => ({
...trip,
entryDate: trip.entryDate.toISOString(),
exitDate: trip.exitDate?.toISOString() || null,
visaType: trip.visaType as any,
passportCountry: trip.passportCountry as any
})) as CountryVisit[]
}

/\*\*
Get user statistics (optimized aggregation)

**íŠ¹ì„±:** `exported`, `async`

#### `createMultipleTrips`

Optimized database queries for DiNoCal
Uses proper indexes and query optimization techniques
/

export interface TripQueryOptions {
userId: string
limit?: number
offset?: number
country?: string
visaType?: string
dateFrom?: Date
dateTo?: Date
orderBy?: 'entryDate' | 'createdAt'
orderDirection?: 'asc' | 'desc'
}

export interface SchengenQueryOptions {
userId: string
fromDate?: Date
toDate?: Date
passportCountry?: string
}

/\*\*
Get user trips with optimized filtering and pagination
/
export async function getUserTrips(options: TripQueryOptions): Promise<CountryVisit[]> {
const {
userId,
limit = 50,
offset = 0,
country,
visaType,
dateFrom,
dateTo,
orderBy = 'entryDate',
orderDirection = 'desc'
} = options

const where: any = { userId }

// Add filters
if (country) {
where.country = country
}

if (visaType) {
where.visaType = visaType
}

if (dateFrom || dateTo) {
where.entryDate = {}
if (dateFrom) {
where.entryDate.gte = dateFrom
}
if (dateTo) {
where.entryDate.lte = dateTo
}
}

// Use optimized query with proper indexes
const trips = await prisma.countryVisit.findMany({
where,
orderBy: {
[orderBy]: orderDirection
},
take: limit,
skip: offset,
select: {
id: true,
userId: true,
country: true,
entryDate: true,
exitDate: true,
visaType: true,
maxDays: true,
passportCountry: true,
notes: true,
createdAt: true,
updatedAt: true
}
})

return trips.map(trip => ({
...trip,
entryDate: trip.entryDate.toISOString(),
exitDate: trip.exitDate?.toISOString() || null,
visaType: trip.visaType as any,
passportCountry: trip.passportCountry as any
})) as CountryVisit[]
}

/\*\*
Get trips for Schengen calculation (optimized for date ranges)
/
export async function getSchengenTrips(options: SchengenQueryOptions): Promise<CountryVisit[]> {
const { userId, fromDate, toDate, passportCountry } = options

const where: any = {
userId,
country: {
in: getSchengenCountries() // List of Schengen countries
}
}

if (passportCountry) {
where.passportCountry = passportCountry
}

if (fromDate || toDate) {
where.OR = [
// Entry date in range
{
entryDate: {
gte: fromDate,
lte: toDate
}
},
// Exit date in range
{
exitDate: {
gte: fromDate,
lte: toDate
}
},
// Trip spans the entire range
{
AND: [
{ entryDate: { lte: fromDate } },
{
OR: [
{ exitDate: { gte: toDate } },
{ exitDate: null } // Still in country
]
}
]
}
]
}

// Use compound index [userId, entryDate, exitDate]
const trips = await prisma.countryVisit.findMany({
where,
orderBy: {
entryDate: 'asc'
},
select: {
id: true,
country: true,
entryDate: true,
exitDate: true,
visaType: true,
maxDays: true,
passportCountry: true
}
})

return trips.map(trip => ({
...trip,
entryDate: trip.entryDate.toISOString(),
exitDate: trip.exitDate?.toISOString() || null,
visaType: trip.visaType as any,
passportCountry: trip.passportCountry as any
})) as CountryVisit[]
}

/\*\*
Get user statistics (optimized aggregation)
/
export async function getUserStats(userId: string) {
// Use Promise.all for parallel execution
const [
totalTrips,
countriesVisited,
currentTrips,
schengenTrips,
recentTrips
] = await Promise.all([
// Total trips count
prisma.countryVisit.count({
where: { userId }
}),

    // Unique countries count
    prisma.countryVisit.groupBy({
      by: ['country'],
      where: { userId },
      _count: { country: true }
    }),

    // Current ongoing trips
    prisma.countryVisit.count({
      where: {
        userId,
        exitDate: null
      }
    }),

    // Schengen trips in last 180 days
    prisma.countryVisit.count({
      where: {
        userId,
        country: {
          in: getSchengenCountries()
        },
        entryDate: {
          gte: new Date(Date.now() - 180 * 24 * 60 * 60 * 1000)
        }
      }
    }),

    // Recent trips (last 30 days)
    prisma.countryVisit.findMany({
      where: {
        userId,
        createdAt: {
          gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000)
        }
      },
      take: 5,
      orderBy: {
        createdAt: 'desc'
      },
      select: {
        id: true,
        country: true,
        entryDate: true,
        visaType: true
      }
    })

])

return {
totalTrips,
countriesVisited: countriesVisited.length,
currentTrips,
schengenTrips,
recentTrips
}
}

/\*\*
Bulk operations for better performance

**íŠ¹ì„±:** `exported`, `async`

#### `searchTrips`

Optimized database queries for DiNoCal
Uses proper indexes and query optimization techniques
/

export interface TripQueryOptions {
userId: string
limit?: number
offset?: number
country?: string
visaType?: string
dateFrom?: Date
dateTo?: Date
orderBy?: 'entryDate' | 'createdAt'
orderDirection?: 'asc' | 'desc'
}

export interface SchengenQueryOptions {
userId: string
fromDate?: Date
toDate?: Date
passportCountry?: string
}

/\*\*
Get user trips with optimized filtering and pagination
/
export async function getUserTrips(options: TripQueryOptions): Promise<CountryVisit[]> {
const {
userId,
limit = 50,
offset = 0,
country,
visaType,
dateFrom,
dateTo,
orderBy = 'entryDate',
orderDirection = 'desc'
} = options

const where: any = { userId }

// Add filters
if (country) {
where.country = country
}

if (visaType) {
where.visaType = visaType
}

if (dateFrom || dateTo) {
where.entryDate = {}
if (dateFrom) {
where.entryDate.gte = dateFrom
}
if (dateTo) {
where.entryDate.lte = dateTo
}
}

// Use optimized query with proper indexes
const trips = await prisma.countryVisit.findMany({
where,
orderBy: {
[orderBy]: orderDirection
},
take: limit,
skip: offset,
select: {
id: true,
userId: true,
country: true,
entryDate: true,
exitDate: true,
visaType: true,
maxDays: true,
passportCountry: true,
notes: true,
createdAt: true,
updatedAt: true
}
})

return trips.map(trip => ({
...trip,
entryDate: trip.entryDate.toISOString(),
exitDate: trip.exitDate?.toISOString() || null,
visaType: trip.visaType as any,
passportCountry: trip.passportCountry as any
})) as CountryVisit[]
}

/\*\*
Get trips for Schengen calculation (optimized for date ranges)
/
export async function getSchengenTrips(options: SchengenQueryOptions): Promise<CountryVisit[]> {
const { userId, fromDate, toDate, passportCountry } = options

const where: any = {
userId,
country: {
in: getSchengenCountries() // List of Schengen countries
}
}

if (passportCountry) {
where.passportCountry = passportCountry
}

if (fromDate || toDate) {
where.OR = [
// Entry date in range
{
entryDate: {
gte: fromDate,
lte: toDate
}
},
// Exit date in range
{
exitDate: {
gte: fromDate,
lte: toDate
}
},
// Trip spans the entire range
{
AND: [
{ entryDate: { lte: fromDate } },
{
OR: [
{ exitDate: { gte: toDate } },
{ exitDate: null } // Still in country
]
}
]
}
]
}

// Use compound index [userId, entryDate, exitDate]
const trips = await prisma.countryVisit.findMany({
where,
orderBy: {
entryDate: 'asc'
},
select: {
id: true,
country: true,
entryDate: true,
exitDate: true,
visaType: true,
maxDays: true,
passportCountry: true
}
})

return trips.map(trip => ({
...trip,
entryDate: trip.entryDate.toISOString(),
exitDate: trip.exitDate?.toISOString() || null,
visaType: trip.visaType as any,
passportCountry: trip.passportCountry as any
})) as CountryVisit[]
}

/\*\*
Get user statistics (optimized aggregation)
/
export async function getUserStats(userId: string) {
// Use Promise.all for parallel execution
const [
totalTrips,
countriesVisited,
currentTrips,
schengenTrips,
recentTrips
] = await Promise.all([
// Total trips count
prisma.countryVisit.count({
where: { userId }
}),

    // Unique countries count
    prisma.countryVisit.groupBy({
      by: ['country'],
      where: { userId },
      _count: { country: true }
    }),

    // Current ongoing trips
    prisma.countryVisit.count({
      where: {
        userId,
        exitDate: null
      }
    }),

    // Schengen trips in last 180 days
    prisma.countryVisit.count({
      where: {
        userId,
        country: {
          in: getSchengenCountries()
        },
        entryDate: {
          gte: new Date(Date.now() - 180 * 24 * 60 * 60 * 1000)
        }
      }
    }),

    // Recent trips (last 30 days)
    prisma.countryVisit.findMany({
      where: {
        userId,
        createdAt: {
          gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000)
        }
      },
      take: 5,
      orderBy: {
        createdAt: 'desc'
      },
      select: {
        id: true,
        country: true,
        entryDate: true,
        visaType: true
      }
    })

])

return {
totalTrips,
countriesVisited: countriesVisited.length,
currentTrips,
schengenTrips,
recentTrips
}
}

/\*\*
Bulk operations for better performance
/
export async function createMultipleTrips(userId: string, trips: Omit<CountryVisit, 'id' | 'userId' | 'createdAt' | 'updatedAt'>[]) {
const data = trips.map(trip => ({
...trip,
userId,
passportCountry: trip.passportCountry || 'Unknown',
entryDate: new Date(trip.entryDate),
exitDate: trip.exitDate ? new Date(trip.exitDate) : null
}))

return await prisma.countryVisit.createMany({
data
})
}

/\*\*
Search trips with full-text search on notes

**íŠ¹ì„±:** `exported`, `async`

#### `getSchengenCountries`

Optimized database queries for DiNoCal
Uses proper indexes and query optimization techniques
/

export interface TripQueryOptions {
userId: string
limit?: number
offset?: number
country?: string
visaType?: string
dateFrom?: Date
dateTo?: Date
orderBy?: 'entryDate' | 'createdAt'
orderDirection?: 'asc' | 'desc'
}

export interface SchengenQueryOptions {
userId: string
fromDate?: Date
toDate?: Date
passportCountry?: string
}

/\*\*
Get user trips with optimized filtering and pagination
/
export async function getUserTrips(options: TripQueryOptions): Promise<CountryVisit[]> {
const {
userId,
limit = 50,
offset = 0,
country,
visaType,
dateFrom,
dateTo,
orderBy = 'entryDate',
orderDirection = 'desc'
} = options

const where: any = { userId }

// Add filters
if (country) {
where.country = country
}

if (visaType) {
where.visaType = visaType
}

if (dateFrom || dateTo) {
where.entryDate = {}
if (dateFrom) {
where.entryDate.gte = dateFrom
}
if (dateTo) {
where.entryDate.lte = dateTo
}
}

// Use optimized query with proper indexes
const trips = await prisma.countryVisit.findMany({
where,
orderBy: {
[orderBy]: orderDirection
},
take: limit,
skip: offset,
select: {
id: true,
userId: true,
country: true,
entryDate: true,
exitDate: true,
visaType: true,
maxDays: true,
passportCountry: true,
notes: true,
createdAt: true,
updatedAt: true
}
})

return trips.map(trip => ({
...trip,
entryDate: trip.entryDate.toISOString(),
exitDate: trip.exitDate?.toISOString() || null,
visaType: trip.visaType as any,
passportCountry: trip.passportCountry as any
})) as CountryVisit[]
}

/\*\*
Get trips for Schengen calculation (optimized for date ranges)
/
export async function getSchengenTrips(options: SchengenQueryOptions): Promise<CountryVisit[]> {
const { userId, fromDate, toDate, passportCountry } = options

const where: any = {
userId,
country: {
in: getSchengenCountries() // List of Schengen countries
}
}

if (passportCountry) {
where.passportCountry = passportCountry
}

if (fromDate || toDate) {
where.OR = [
// Entry date in range
{
entryDate: {
gte: fromDate,
lte: toDate
}
},
// Exit date in range
{
exitDate: {
gte: fromDate,
lte: toDate
}
},
// Trip spans the entire range
{
AND: [
{ entryDate: { lte: fromDate } },
{
OR: [
{ exitDate: { gte: toDate } },
{ exitDate: null } // Still in country
]
}
]
}
]
}

// Use compound index [userId, entryDate, exitDate]
const trips = await prisma.countryVisit.findMany({
where,
orderBy: {
entryDate: 'asc'
},
select: {
id: true,
country: true,
entryDate: true,
exitDate: true,
visaType: true,
maxDays: true,
passportCountry: true
}
})

return trips.map(trip => ({
...trip,
entryDate: trip.entryDate.toISOString(),
exitDate: trip.exitDate?.toISOString() || null,
visaType: trip.visaType as any,
passportCountry: trip.passportCountry as any
})) as CountryVisit[]
}

/\*\*
Get user statistics (optimized aggregation)
/
export async function getUserStats(userId: string) {
// Use Promise.all for parallel execution
const [
totalTrips,
countriesVisited,
currentTrips,
schengenTrips,
recentTrips
] = await Promise.all([
// Total trips count
prisma.countryVisit.count({
where: { userId }
}),

    // Unique countries count
    prisma.countryVisit.groupBy({
      by: ['country'],
      where: { userId },
      _count: { country: true }
    }),

    // Current ongoing trips
    prisma.countryVisit.count({
      where: {
        userId,
        exitDate: null
      }
    }),

    // Schengen trips in last 180 days
    prisma.countryVisit.count({
      where: {
        userId,
        country: {
          in: getSchengenCountries()
        },
        entryDate: {
          gte: new Date(Date.now() - 180 * 24 * 60 * 60 * 1000)
        }
      }
    }),

    // Recent trips (last 30 days)
    prisma.countryVisit.findMany({
      where: {
        userId,
        createdAt: {
          gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000)
        }
      },
      take: 5,
      orderBy: {
        createdAt: 'desc'
      },
      select: {
        id: true,
        country: true,
        entryDate: true,
        visaType: true
      }
    })

])

return {
totalTrips,
countriesVisited: countriesVisited.length,
currentTrips,
schengenTrips,
recentTrips
}
}

/\*\*
Bulk operations for better performance
/
export async function createMultipleTrips(userId: string, trips: Omit<CountryVisit, 'id' | 'userId' | 'createdAt' | 'updatedAt'>[]) {
const data = trips.map(trip => ({
...trip,
userId,
passportCountry: trip.passportCountry || 'Unknown',
entryDate: new Date(trip.entryDate),
exitDate: trip.exitDate ? new Date(trip.exitDate) : null
}))

return await prisma.countryVisit.createMany({
data
})
}

/\*\*
Search trips with full-text search on notes
/
export async function searchTrips(userId: string, query: string, limit = 20): Promise<CountryVisit[]> {
// Use LIKE for SQLite compatibility
const trips = await prisma.countryVisit.findMany({
where: {
userId,
OR: [
{
country: {
contains: query
}
},
{
notes: {
contains: query
}
},
{
visaType: {
contains: query
}
}
]
},
orderBy: {
entryDate: 'desc'
},
take: limit,
select: {
id: true,
userId: true,
country: true,
entryDate: true,
exitDate: true,
visaType: true,
maxDays: true,
passportCountry: true,
notes: true,
createdAt: true,
updatedAt: true
}
})

return trips.map(trip => ({
...trip,
entryDate: trip.entryDate.toISOString(),
exitDate: trip.exitDate?.toISOString() || null,
visaType: trip.visaType as any,
passportCountry: trip.passportCountry as any
})) as CountryVisit[]
}

/\*\*
Get Schengen countries list (cached)

#### `getDatabaseHealth`

Optimized database queries for DiNoCal
Uses proper indexes and query optimization techniques
/

export interface TripQueryOptions {
userId: string
limit?: number
offset?: number
country?: string
visaType?: string
dateFrom?: Date
dateTo?: Date
orderBy?: 'entryDate' | 'createdAt'
orderDirection?: 'asc' | 'desc'
}

export interface SchengenQueryOptions {
userId: string
fromDate?: Date
toDate?: Date
passportCountry?: string
}

/\*\*
Get user trips with optimized filtering and pagination
/
export async function getUserTrips(options: TripQueryOptions): Promise<CountryVisit[]> {
const {
userId,
limit = 50,
offset = 0,
country,
visaType,
dateFrom,
dateTo,
orderBy = 'entryDate',
orderDirection = 'desc'
} = options

const where: any = { userId }

// Add filters
if (country) {
where.country = country
}

if (visaType) {
where.visaType = visaType
}

if (dateFrom || dateTo) {
where.entryDate = {}
if (dateFrom) {
where.entryDate.gte = dateFrom
}
if (dateTo) {
where.entryDate.lte = dateTo
}
}

// Use optimized query with proper indexes
const trips = await prisma.countryVisit.findMany({
where,
orderBy: {
[orderBy]: orderDirection
},
take: limit,
skip: offset,
select: {
id: true,
userId: true,
country: true,
entryDate: true,
exitDate: true,
visaType: true,
maxDays: true,
passportCountry: true,
notes: true,
createdAt: true,
updatedAt: true
}
})

return trips.map(trip => ({
...trip,
entryDate: trip.entryDate.toISOString(),
exitDate: trip.exitDate?.toISOString() || null,
visaType: trip.visaType as any,
passportCountry: trip.passportCountry as any
})) as CountryVisit[]
}

/\*\*
Get trips for Schengen calculation (optimized for date ranges)
/
export async function getSchengenTrips(options: SchengenQueryOptions): Promise<CountryVisit[]> {
const { userId, fromDate, toDate, passportCountry } = options

const where: any = {
userId,
country: {
in: getSchengenCountries() // List of Schengen countries
}
}

if (passportCountry) {
where.passportCountry = passportCountry
}

if (fromDate || toDate) {
where.OR = [
// Entry date in range
{
entryDate: {
gte: fromDate,
lte: toDate
}
},
// Exit date in range
{
exitDate: {
gte: fromDate,
lte: toDate
}
},
// Trip spans the entire range
{
AND: [
{ entryDate: { lte: fromDate } },
{
OR: [
{ exitDate: { gte: toDate } },
{ exitDate: null } // Still in country
]
}
]
}
]
}

// Use compound index [userId, entryDate, exitDate]
const trips = await prisma.countryVisit.findMany({
where,
orderBy: {
entryDate: 'asc'
},
select: {
id: true,
country: true,
entryDate: true,
exitDate: true,
visaType: true,
maxDays: true,
passportCountry: true
}
})

return trips.map(trip => ({
...trip,
entryDate: trip.entryDate.toISOString(),
exitDate: trip.exitDate?.toISOString() || null,
visaType: trip.visaType as any,
passportCountry: trip.passportCountry as any
})) as CountryVisit[]
}

/\*\*
Get user statistics (optimized aggregation)
/
export async function getUserStats(userId: string) {
// Use Promise.all for parallel execution
const [
totalTrips,
countriesVisited,
currentTrips,
schengenTrips,
recentTrips
] = await Promise.all([
// Total trips count
prisma.countryVisit.count({
where: { userId }
}),

    // Unique countries count
    prisma.countryVisit.groupBy({
      by: ['country'],
      where: { userId },
      _count: { country: true }
    }),

    // Current ongoing trips
    prisma.countryVisit.count({
      where: {
        userId,
        exitDate: null
      }
    }),

    // Schengen trips in last 180 days
    prisma.countryVisit.count({
      where: {
        userId,
        country: {
          in: getSchengenCountries()
        },
        entryDate: {
          gte: new Date(Date.now() - 180 * 24 * 60 * 60 * 1000)
        }
      }
    }),

    // Recent trips (last 30 days)
    prisma.countryVisit.findMany({
      where: {
        userId,
        createdAt: {
          gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000)
        }
      },
      take: 5,
      orderBy: {
        createdAt: 'desc'
      },
      select: {
        id: true,
        country: true,
        entryDate: true,
        visaType: true
      }
    })

])

return {
totalTrips,
countriesVisited: countriesVisited.length,
currentTrips,
schengenTrips,
recentTrips
}
}

/\*\*
Bulk operations for better performance
/
export async function createMultipleTrips(userId: string, trips: Omit<CountryVisit, 'id' | 'userId' | 'createdAt' | 'updatedAt'>[]) {
const data = trips.map(trip => ({
...trip,
userId,
passportCountry: trip.passportCountry || 'Unknown',
entryDate: new Date(trip.entryDate),
exitDate: trip.exitDate ? new Date(trip.exitDate) : null
}))

return await prisma.countryVisit.createMany({
data
})
}

/\*\*
Search trips with full-text search on notes
/
export async function searchTrips(userId: string, query: string, limit = 20): Promise<CountryVisit[]> {
// Use LIKE for SQLite compatibility
const trips = await prisma.countryVisit.findMany({
where: {
userId,
OR: [
{
country: {
contains: query
}
},
{
notes: {
contains: query
}
},
{
visaType: {
contains: query
}
}
]
},
orderBy: {
entryDate: 'desc'
},
take: limit,
select: {
id: true,
userId: true,
country: true,
entryDate: true,
exitDate: true,
visaType: true,
maxDays: true,
passportCountry: true,
notes: true,
createdAt: true,
updatedAt: true
}
})

return trips.map(trip => ({
...trip,
entryDate: trip.entryDate.toISOString(),
exitDate: trip.exitDate?.toISOString() || null,
visaType: trip.visaType as any,
passportCountry: trip.passportCountry as any
})) as CountryVisit[]
}

/\*\*
Get Schengen countries list (cached)
/
function getSchengenCountries(): string[] {
return [
'Austria', 'Belgium', 'Czech Republic', 'Denmark', 'Estonia', 'Finland',
'France', 'Germany', 'Greece', 'Hungary', 'Iceland', 'Italy', 'Latvia',
'Lithuania', 'Luxembourg', 'Malta', 'Netherlands', 'Norway', 'Poland',
'Portugal', 'Slovakia', 'Slovenia', 'Spain', 'Sweden', 'Switzerland',
'Liechtenstein'
]
}

/\*\*
Database health check and optimization suggestions

**íŠ¹ì„±:** `exported`, `async`

#### `cleanupOldData`

Optimized database queries for DiNoCal
Uses proper indexes and query optimization techniques
/

export interface TripQueryOptions {
userId: string
limit?: number
offset?: number
country?: string
visaType?: string
dateFrom?: Date
dateTo?: Date
orderBy?: 'entryDate' | 'createdAt'
orderDirection?: 'asc' | 'desc'
}

export interface SchengenQueryOptions {
userId: string
fromDate?: Date
toDate?: Date
passportCountry?: string
}

/\*\*
Get user trips with optimized filtering and pagination
/
export async function getUserTrips(options: TripQueryOptions): Promise<CountryVisit[]> {
const {
userId,
limit = 50,
offset = 0,
country,
visaType,
dateFrom,
dateTo,
orderBy = 'entryDate',
orderDirection = 'desc'
} = options

const where: any = { userId }

// Add filters
if (country) {
where.country = country
}

if (visaType) {
where.visaType = visaType
}

if (dateFrom || dateTo) {
where.entryDate = {}
if (dateFrom) {
where.entryDate.gte = dateFrom
}
if (dateTo) {
where.entryDate.lte = dateTo
}
}

// Use optimized query with proper indexes
const trips = await prisma.countryVisit.findMany({
where,
orderBy: {
[orderBy]: orderDirection
},
take: limit,
skip: offset,
select: {
id: true,
userId: true,
country: true,
entryDate: true,
exitDate: true,
visaType: true,
maxDays: true,
passportCountry: true,
notes: true,
createdAt: true,
updatedAt: true
}
})

return trips.map(trip => ({
...trip,
entryDate: trip.entryDate.toISOString(),
exitDate: trip.exitDate?.toISOString() || null,
visaType: trip.visaType as any,
passportCountry: trip.passportCountry as any
})) as CountryVisit[]
}

/\*\*
Get trips for Schengen calculation (optimized for date ranges)
/
export async function getSchengenTrips(options: SchengenQueryOptions): Promise<CountryVisit[]> {
const { userId, fromDate, toDate, passportCountry } = options

const where: any = {
userId,
country: {
in: getSchengenCountries() // List of Schengen countries
}
}

if (passportCountry) {
where.passportCountry = passportCountry
}

if (fromDate || toDate) {
where.OR = [
// Entry date in range
{
entryDate: {
gte: fromDate,
lte: toDate
}
},
// Exit date in range
{
exitDate: {
gte: fromDate,
lte: toDate
}
},
// Trip spans the entire range
{
AND: [
{ entryDate: { lte: fromDate } },
{
OR: [
{ exitDate: { gte: toDate } },
{ exitDate: null } // Still in country
]
}
]
}
]
}

// Use compound index [userId, entryDate, exitDate]
const trips = await prisma.countryVisit.findMany({
where,
orderBy: {
entryDate: 'asc'
},
select: {
id: true,
country: true,
entryDate: true,
exitDate: true,
visaType: true,
maxDays: true,
passportCountry: true
}
})

return trips.map(trip => ({
...trip,
entryDate: trip.entryDate.toISOString(),
exitDate: trip.exitDate?.toISOString() || null,
visaType: trip.visaType as any,
passportCountry: trip.passportCountry as any
})) as CountryVisit[]
}

/\*\*
Get user statistics (optimized aggregation)
/
export async function getUserStats(userId: string) {
// Use Promise.all for parallel execution
const [
totalTrips,
countriesVisited,
currentTrips,
schengenTrips,
recentTrips
] = await Promise.all([
// Total trips count
prisma.countryVisit.count({
where: { userId }
}),

    // Unique countries count
    prisma.countryVisit.groupBy({
      by: ['country'],
      where: { userId },
      _count: { country: true }
    }),

    // Current ongoing trips
    prisma.countryVisit.count({
      where: {
        userId,
        exitDate: null
      }
    }),

    // Schengen trips in last 180 days
    prisma.countryVisit.count({
      where: {
        userId,
        country: {
          in: getSchengenCountries()
        },
        entryDate: {
          gte: new Date(Date.now() - 180 * 24 * 60 * 60 * 1000)
        }
      }
    }),

    // Recent trips (last 30 days)
    prisma.countryVisit.findMany({
      where: {
        userId,
        createdAt: {
          gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000)
        }
      },
      take: 5,
      orderBy: {
        createdAt: 'desc'
      },
      select: {
        id: true,
        country: true,
        entryDate: true,
        visaType: true
      }
    })

])

return {
totalTrips,
countriesVisited: countriesVisited.length,
currentTrips,
schengenTrips,
recentTrips
}
}

/\*\*
Bulk operations for better performance
/
export async function createMultipleTrips(userId: string, trips: Omit<CountryVisit, 'id' | 'userId' | 'createdAt' | 'updatedAt'>[]) {
const data = trips.map(trip => ({
...trip,
userId,
passportCountry: trip.passportCountry || 'Unknown',
entryDate: new Date(trip.entryDate),
exitDate: trip.exitDate ? new Date(trip.exitDate) : null
}))

return await prisma.countryVisit.createMany({
data
})
}

/\*\*
Search trips with full-text search on notes
/
export async function searchTrips(userId: string, query: string, limit = 20): Promise<CountryVisit[]> {
// Use LIKE for SQLite compatibility
const trips = await prisma.countryVisit.findMany({
where: {
userId,
OR: [
{
country: {
contains: query
}
},
{
notes: {
contains: query
}
},
{
visaType: {
contains: query
}
}
]
},
orderBy: {
entryDate: 'desc'
},
take: limit,
select: {
id: true,
userId: true,
country: true,
entryDate: true,
exitDate: true,
visaType: true,
maxDays: true,
passportCountry: true,
notes: true,
createdAt: true,
updatedAt: true
}
})

return trips.map(trip => ({
...trip,
entryDate: trip.entryDate.toISOString(),
exitDate: trip.exitDate?.toISOString() || null,
visaType: trip.visaType as any,
passportCountry: trip.passportCountry as any
})) as CountryVisit[]
}

/\*\*
Get Schengen countries list (cached)
/
function getSchengenCountries(): string[] {
return [
'Austria', 'Belgium', 'Czech Republic', 'Denmark', 'Estonia', 'Finland',
'France', 'Germany', 'Greece', 'Hungary', 'Iceland', 'Italy', 'Latvia',
'Lithuania', 'Luxembourg', 'Malta', 'Netherlands', 'Norway', 'Poland',
'Portugal', 'Slovakia', 'Slovenia', 'Spain', 'Sweden', 'Switzerland',
'Liechtenstein'
]
}

/\*_
Database health check and optimization suggestions
/
export async function getDatabaseHealth() {
const [
totalUsers,
totalTrips,
recentActivity,
oldestTrip,
newestTrip
] = await Promise.all([
prisma.user.count(),
prisma.countryVisit.count(),
prisma.countryVisit.count({
where: {
createdAt: {
gte: new Date(Date.now() - 24 _ 60 _ 60 _ 1000) // Last 24 hours
}
}
}),
prisma.countryVisit.findFirst({
orderBy: { entryDate: 'asc' },
select: { entryDate: true }
}),
prisma.countryVisit.findFirst({
orderBy: { entryDate: 'desc' },
select: { entryDate: true }
})
])

return {
totalUsers,
totalTrips,
recentActivity,
dataRange: {
oldest: oldestTrip?.entryDate,
newest: newestTrip?.entryDate
},
avgTripsPerUser: totalUsers > 0 ? Math.round(totalTrips / totalUsers) : 0
}
}

/\*\*
Clean up old data (for maintenance)

**íŠ¹ì„±:** `exported`, `async`

### ğŸ”— Interfaces

#### `TripQueryOptions`

Optimized database queries for DiNoCal
Uses proper indexes and query optimization techniques

**íŠ¹ì„±:** `exported`

#### `SchengenQueryOptions`

**íŠ¹ì„±:** `exported`

## prisma-client.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/database/prisma-client.ts`

**ì„¤ëª…:** Enhanced Prisma Client with Connection Recovery
Provides resilient database access with automatic recovery

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 5678 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 223
- ğŸ”§ í•¨ìˆ˜: 2ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 0ê°œ

**Exports:**

- `async`
- `db`

### ğŸ”§ Functions

#### `getPrismaClient`

**íŠ¹ì„±:** `exported`, `async`

#### `checkDatabaseHealth`

**íŠ¹ì„±:** `exported`, `async`

## query-optimizer.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/database/query-optimizer.ts`

**ì„¤ëª…:** Database Query Optimizer for Production Performance
í”„ë¡œë•ì…˜ ì„±ëŠ¥ì„ ìœ„í•œ ë°ì´í„°ë² ì´ìŠ¤ ì¿¼ë¦¬ ìµœì í™”

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 9013 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 362
- ğŸ”§ í•¨ìˆ˜: 3ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 1ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 2ê°œ

**Exports:**

- `queryOptimizer`
- `async`

### ğŸ”§ Functions

#### `getUserTripsOptimized`

Database Query Optimizer for Production Performance
í”„ë¡œë•ì…˜ ì„±ëŠ¥ì„ ìœ„í•œ ë°ì´í„°ë² ì´ìŠ¤ ì¿¼ë¦¬ ìµœì í™”
/

import { PrismaClient, Prisma } from '@prisma/client'
import { getPrismaClient } from './dev-prisma'
const prisma = getPrismaClient()

interface QueryMetrics {
query: string
duration: number
timestamp: Date
recordCount?: number
error?: string
}

interface CacheOptions {
ttl: number // Time to live in seconds
key: string
}

class QueryOptimizer {
private static instance: QueryOptimizer
private queryMetrics: QueryMetrics[] = []
private cache = new Map<string, { data: any; expires: number }>()
private readonly MAX_METRICS = 1000 // ìµœëŒ€ ë©”íŠ¸ë¦­ ë³´ê´€ ìˆ˜
private readonly DEFAULT_CACHE_TTL = 300 // 5ë¶„

private constructor() {}

public static getInstance(): QueryOptimizer {
if (!QueryOptimizer.instance) {
QueryOptimizer.instance = new QueryOptimizer()
}
return QueryOptimizer.instance
}

/\*\*
ìºì‹œëœ ì¿¼ë¦¬ ì‹¤í–‰
/
public async executeWithCache<T>(
queryFn: () => Promise<T>,
cacheOptions: CacheOptions
): Promise<T> {
const now = Date.now()
const cached = this.cache.get(cacheOptions.key)

    // ìºì‹œ íˆíŠ¸
    if (cached && cached.expires > now) {
      return cached.data as T
    }

    // ìºì‹œ ë¯¸ìŠ¤ - ì¿¼ë¦¬ ì‹¤í–‰
    const result = await queryFn()

    // ìºì‹œ ì €ì¥
    this.cache.set(cacheOptions.key, {
      data: result,
      expires: now + (cacheOptions.ttl * 1000)
    })

    return result

}

/\*\*
ë©”íŠ¸ë¦­ê³¼ í•¨ê»˜ ì¿¼ë¦¬ ì‹¤í–‰
/
public async executeWithMetrics<T>(
queryFn: () => Promise<T>,
queryName: string
): Promise<T> {
const startTime = Date.now()

    try {
      const result = await queryFn()
      const duration = Date.now() - startTime

      // ë©”íŠ¸ë¦­ ê¸°ë¡
      this.recordMetrics({
        query: queryName,
        duration,
        timestamp: new Date(),
        recordCount: Array.isArray(result) ? result.length : 1
      })

      return result
    } catch (error) {
      const duration = Date.now() - startTime

      // ì—ëŸ¬ ë©”íŠ¸ë¦­ ê¸°ë¡
      this.recordMetrics({
        query: queryName,
        duration,
        timestamp: new Date(),
        error: error instanceof Error ? error.message : 'Unknown error'
      })

      throw error
    }

}

private recordMetrics(metrics: QueryMetrics): void {
this.queryMetrics.push(metrics)

    // ë©”íŠ¸ë¦­ ìˆ˜ ì œí•œ
    if (this.queryMetrics.length > this.MAX_METRICS) {
      this.queryMetrics = this.queryMetrics.slice(-this.MAX_METRICS)
    }

}

/\*\*
ì¿¼ë¦¬ ì„±ëŠ¥ í†µê³„
/
public getQueryStats(): {
totalQueries: number
averageDuration: number
slowQueries: QueryMetrics[]
errorQueries: QueryMetrics[]
cacheHitRate: number
} {
const total = this.queryMetrics.length
const totalDuration = this.queryMetrics.reduce((sum, m) => sum + m.duration, 0)
const slowQueries = this.queryMetrics.filter(m => m.duration > 1000) // 1ì´ˆ ì´ìƒ
const errorQueries = this.queryMetrics.filter(m => m.error)

    return {
      totalQueries: total,
      averageDuration: total > 0 ? totalDuration / total : 0,
      slowQueries,
      errorQueries,
      cacheHitRate: this.calculateCacheHitRate()
    }

}

private calculateCacheHitRate(): number {
// ê°„ë‹¨í•œ ìºì‹œ íˆíŠ¸ìœ¨ ê³„ì‚° (ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ë” ì •êµí•œ ì¶”ì  í•„ìš”)
return this.cache.size > 0 ? 0.8 : 0 // ì„ì‹œê°’
}

/\*\*
ìºì‹œ ì •ë¦¬
/
public clearExpiredCache(): void {
const now = Date.now()
for (const [key, value] of this.cache.entries()) {
if (value.expires <= now) {
this.cache.delete(key)
}
}
}

/\*\*
ìºì‹œ í†µê³„
/
public getCacheStats() {
return {
size: this.cache.size,
keys: Array.from(this.cache.keys())
}
}
}

// Optimized query helpers
export const queryOptimizer = QueryOptimizer.getInstance()

/\*\*
ì‚¬ìš©ìì˜ ì—¬í–‰ ê¸°ë¡ ì¡°íšŒ (ìµœì í™”ëœ ë²„ì „)

**íŠ¹ì„±:** `exported`, `async`

#### `getSchengenTripsOptimized`

Database Query Optimizer for Production Performance
í”„ë¡œë•ì…˜ ì„±ëŠ¥ì„ ìœ„í•œ ë°ì´í„°ë² ì´ìŠ¤ ì¿¼ë¦¬ ìµœì í™”
/

import { PrismaClient, Prisma } from '@prisma/client'
import { getPrismaClient } from './dev-prisma'
const prisma = getPrismaClient()

interface QueryMetrics {
query: string
duration: number
timestamp: Date
recordCount?: number
error?: string
}

interface CacheOptions {
ttl: number // Time to live in seconds
key: string
}

class QueryOptimizer {
private static instance: QueryOptimizer
private queryMetrics: QueryMetrics[] = []
private cache = new Map<string, { data: any; expires: number }>()
private readonly MAX_METRICS = 1000 // ìµœëŒ€ ë©”íŠ¸ë¦­ ë³´ê´€ ìˆ˜
private readonly DEFAULT_CACHE_TTL = 300 // 5ë¶„

private constructor() {}

public static getInstance(): QueryOptimizer {
if (!QueryOptimizer.instance) {
QueryOptimizer.instance = new QueryOptimizer()
}
return QueryOptimizer.instance
}

/\*\*
ìºì‹œëœ ì¿¼ë¦¬ ì‹¤í–‰
/
public async executeWithCache<T>(
queryFn: () => Promise<T>,
cacheOptions: CacheOptions
): Promise<T> {
const now = Date.now()
const cached = this.cache.get(cacheOptions.key)

    // ìºì‹œ íˆíŠ¸
    if (cached && cached.expires > now) {
      return cached.data as T
    }

    // ìºì‹œ ë¯¸ìŠ¤ - ì¿¼ë¦¬ ì‹¤í–‰
    const result = await queryFn()

    // ìºì‹œ ì €ì¥
    this.cache.set(cacheOptions.key, {
      data: result,
      expires: now + (cacheOptions.ttl * 1000)
    })

    return result

}

/\*\*
ë©”íŠ¸ë¦­ê³¼ í•¨ê»˜ ì¿¼ë¦¬ ì‹¤í–‰
/
public async executeWithMetrics<T>(
queryFn: () => Promise<T>,
queryName: string
): Promise<T> {
const startTime = Date.now()

    try {
      const result = await queryFn()
      const duration = Date.now() - startTime

      // ë©”íŠ¸ë¦­ ê¸°ë¡
      this.recordMetrics({
        query: queryName,
        duration,
        timestamp: new Date(),
        recordCount: Array.isArray(result) ? result.length : 1
      })

      return result
    } catch (error) {
      const duration = Date.now() - startTime

      // ì—ëŸ¬ ë©”íŠ¸ë¦­ ê¸°ë¡
      this.recordMetrics({
        query: queryName,
        duration,
        timestamp: new Date(),
        error: error instanceof Error ? error.message : 'Unknown error'
      })

      throw error
    }

}

private recordMetrics(metrics: QueryMetrics): void {
this.queryMetrics.push(metrics)

    // ë©”íŠ¸ë¦­ ìˆ˜ ì œí•œ
    if (this.queryMetrics.length > this.MAX_METRICS) {
      this.queryMetrics = this.queryMetrics.slice(-this.MAX_METRICS)
    }

}

/\*\*
ì¿¼ë¦¬ ì„±ëŠ¥ í†µê³„
/
public getQueryStats(): {
totalQueries: number
averageDuration: number
slowQueries: QueryMetrics[]
errorQueries: QueryMetrics[]
cacheHitRate: number
} {
const total = this.queryMetrics.length
const totalDuration = this.queryMetrics.reduce((sum, m) => sum + m.duration, 0)
const slowQueries = this.queryMetrics.filter(m => m.duration > 1000) // 1ì´ˆ ì´ìƒ
const errorQueries = this.queryMetrics.filter(m => m.error)

    return {
      totalQueries: total,
      averageDuration: total > 0 ? totalDuration / total : 0,
      slowQueries,
      errorQueries,
      cacheHitRate: this.calculateCacheHitRate()
    }

}

private calculateCacheHitRate(): number {
// ê°„ë‹¨í•œ ìºì‹œ íˆíŠ¸ìœ¨ ê³„ì‚° (ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ë” ì •êµí•œ ì¶”ì  í•„ìš”)
return this.cache.size > 0 ? 0.8 : 0 // ì„ì‹œê°’
}

/\*\*
ìºì‹œ ì •ë¦¬
/
public clearExpiredCache(): void {
const now = Date.now()
for (const [key, value] of this.cache.entries()) {
if (value.expires <= now) {
this.cache.delete(key)
}
}
}

/\*\*
ìºì‹œ í†µê³„
/
public getCacheStats() {
return {
size: this.cache.size,
keys: Array.from(this.cache.keys())
}
}
}

// Optimized query helpers
export const queryOptimizer = QueryOptimizer.getInstance()

/\*\*
ì‚¬ìš©ìì˜ ì—¬í–‰ ê¸°ë¡ ì¡°íšŒ (ìµœì í™”ëœ ë²„ì „)
/
export async function getUserTripsOptimized(
userId: string,
options: {
limit?: number
offset?: number
country?: string
fromDate?: Date
toDate?: Date
includeActive?: boolean
} = {}
) {
const cacheKey = `user_trips_${userId}_${JSON.stringify(options)}`

return queryOptimizer.executeWithCache(
async () => {
return queryOptimizer.executeWithMetrics(
async () => {
const where: Prisma.CountryVisitWhereInput = {
userId,
...(options.country && { country: options.country }),
...(options.fromDate && { entryDate: { gte: options.fromDate } }),
...(options.toDate && { entryDate: { lte: options.toDate } }),
...(options.includeActive !== undefined && {
exitDate: options.includeActive ? null : { not: null }
})
}

          return prisma.countryVisit.findMany({
            where,
            orderBy: { entryDate: 'desc' },
            take: options.limit,
            skip: options.offset,
            select: {
              id: true,
              country: true,
              entryDate: true,
              exitDate: true,
              visaType: true,
              maxDays: true,
              passportCountry: true,
              notes: true,
              createdAt: true
            }
          })
        },
        `getUserTrips_${userId}`
      )
    },
    { key: cacheKey, ttl: 300 } // 5ë¶„ ìºì‹œ

)
}

/\*\*
ì…°ê² ê³„ì‚°ì„ ìœ„í•œ ìµœì í™”ëœ ì¿¼ë¦¬

**íŠ¹ì„±:** `exported`, `async`

#### `getDashboardStatsOptimized`

Database Query Optimizer for Production Performance
í”„ë¡œë•ì…˜ ì„±ëŠ¥ì„ ìœ„í•œ ë°ì´í„°ë² ì´ìŠ¤ ì¿¼ë¦¬ ìµœì í™”
/

import { PrismaClient, Prisma } from '@prisma/client'
import { getPrismaClient } from './dev-prisma'
const prisma = getPrismaClient()

interface QueryMetrics {
query: string
duration: number
timestamp: Date
recordCount?: number
error?: string
}

interface CacheOptions {
ttl: number // Time to live in seconds
key: string
}

class QueryOptimizer {
private static instance: QueryOptimizer
private queryMetrics: QueryMetrics[] = []
private cache = new Map<string, { data: any; expires: number }>()
private readonly MAX_METRICS = 1000 // ìµœëŒ€ ë©”íŠ¸ë¦­ ë³´ê´€ ìˆ˜
private readonly DEFAULT_CACHE_TTL = 300 // 5ë¶„

private constructor() {}

public static getInstance(): QueryOptimizer {
if (!QueryOptimizer.instance) {
QueryOptimizer.instance = new QueryOptimizer()
}
return QueryOptimizer.instance
}

/\*\*
ìºì‹œëœ ì¿¼ë¦¬ ì‹¤í–‰
/
public async executeWithCache<T>(
queryFn: () => Promise<T>,
cacheOptions: CacheOptions
): Promise<T> {
const now = Date.now()
const cached = this.cache.get(cacheOptions.key)

    // ìºì‹œ íˆíŠ¸
    if (cached && cached.expires > now) {
      return cached.data as T
    }

    // ìºì‹œ ë¯¸ìŠ¤ - ì¿¼ë¦¬ ì‹¤í–‰
    const result = await queryFn()

    // ìºì‹œ ì €ì¥
    this.cache.set(cacheOptions.key, {
      data: result,
      expires: now + (cacheOptions.ttl * 1000)
    })

    return result

}

/\*\*
ë©”íŠ¸ë¦­ê³¼ í•¨ê»˜ ì¿¼ë¦¬ ì‹¤í–‰
/
public async executeWithMetrics<T>(
queryFn: () => Promise<T>,
queryName: string
): Promise<T> {
const startTime = Date.now()

    try {
      const result = await queryFn()
      const duration = Date.now() - startTime

      // ë©”íŠ¸ë¦­ ê¸°ë¡
      this.recordMetrics({
        query: queryName,
        duration,
        timestamp: new Date(),
        recordCount: Array.isArray(result) ? result.length : 1
      })

      return result
    } catch (error) {
      const duration = Date.now() - startTime

      // ì—ëŸ¬ ë©”íŠ¸ë¦­ ê¸°ë¡
      this.recordMetrics({
        query: queryName,
        duration,
        timestamp: new Date(),
        error: error instanceof Error ? error.message : 'Unknown error'
      })

      throw error
    }

}

private recordMetrics(metrics: QueryMetrics): void {
this.queryMetrics.push(metrics)

    // ë©”íŠ¸ë¦­ ìˆ˜ ì œí•œ
    if (this.queryMetrics.length > this.MAX_METRICS) {
      this.queryMetrics = this.queryMetrics.slice(-this.MAX_METRICS)
    }

}

/\*\*
ì¿¼ë¦¬ ì„±ëŠ¥ í†µê³„
/
public getQueryStats(): {
totalQueries: number
averageDuration: number
slowQueries: QueryMetrics[]
errorQueries: QueryMetrics[]
cacheHitRate: number
} {
const total = this.queryMetrics.length
const totalDuration = this.queryMetrics.reduce((sum, m) => sum + m.duration, 0)
const slowQueries = this.queryMetrics.filter(m => m.duration > 1000) // 1ì´ˆ ì´ìƒ
const errorQueries = this.queryMetrics.filter(m => m.error)

    return {
      totalQueries: total,
      averageDuration: total > 0 ? totalDuration / total : 0,
      slowQueries,
      errorQueries,
      cacheHitRate: this.calculateCacheHitRate()
    }

}

private calculateCacheHitRate(): number {
// ê°„ë‹¨í•œ ìºì‹œ íˆíŠ¸ìœ¨ ê³„ì‚° (ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ë” ì •êµí•œ ì¶”ì  í•„ìš”)
return this.cache.size > 0 ? 0.8 : 0 // ì„ì‹œê°’
}

/\*\*
ìºì‹œ ì •ë¦¬
/
public clearExpiredCache(): void {
const now = Date.now()
for (const [key, value] of this.cache.entries()) {
if (value.expires <= now) {
this.cache.delete(key)
}
}
}

/\*\*
ìºì‹œ í†µê³„
/
public getCacheStats() {
return {
size: this.cache.size,
keys: Array.from(this.cache.keys())
}
}
}

// Optimized query helpers
export const queryOptimizer = QueryOptimizer.getInstance()

/\*\*
ì‚¬ìš©ìì˜ ì—¬í–‰ ê¸°ë¡ ì¡°íšŒ (ìµœì í™”ëœ ë²„ì „)
/
export async function getUserTripsOptimized(
userId: string,
options: {
limit?: number
offset?: number
country?: string
fromDate?: Date
toDate?: Date
includeActive?: boolean
} = {}
) {
const cacheKey = `user_trips_${userId}_${JSON.stringify(options)}`

return queryOptimizer.executeWithCache(
async () => {
return queryOptimizer.executeWithMetrics(
async () => {
const where: Prisma.CountryVisitWhereInput = {
userId,
...(options.country && { country: options.country }),
...(options.fromDate && { entryDate: { gte: options.fromDate } }),
...(options.toDate && { entryDate: { lte: options.toDate } }),
...(options.includeActive !== undefined && {
exitDate: options.includeActive ? null : { not: null }
})
}

          return prisma.countryVisit.findMany({
            where,
            orderBy: { entryDate: 'desc' },
            take: options.limit,
            skip: options.offset,
            select: {
              id: true,
              country: true,
              entryDate: true,
              exitDate: true,
              visaType: true,
              maxDays: true,
              passportCountry: true,
              notes: true,
              createdAt: true
            }
          })
        },
        `getUserTrips_${userId}`
      )
    },
    { key: cacheKey, ttl: 300 } // 5ë¶„ ìºì‹œ

)
}

/\*\*
ì…°ê² ê³„ì‚°ì„ ìœ„í•œ ìµœì í™”ëœ ì¿¼ë¦¬
/
export async function getSchengenTripsOptimized(
userId: string,
fromDate: Date,
toDate: Date
) {
const cacheKey = `schengen_${userId}_${fromDate.getTime()}_${toDate.getTime()}`

return queryOptimizer.executeWithCache(
async () => {
return queryOptimizer.executeWithMetrics(
async () => {
// ì…°ê² êµ­ê°€ ëª©ë¡
const schengenCountries = [
'Austria', 'Belgium', 'Czech Republic', 'Denmark', 'Estonia', 'Finland',
'France', 'Germany', 'Greece', 'Hungary', 'Iceland', 'Italy', 'Latvia',
'Lithuania', 'Luxembourg', 'Malta', 'Netherlands', 'Norway', 'Poland',
'Portugal', 'Slovakia', 'Slovenia', 'Spain', 'Sweden', 'Switzerland'
]

          return prisma.countryVisit.findMany({
            where: {
              userId,
              country: { in: schengenCountries },
              OR: [
                {
                  // ê¸°ê°„ ë‚´ ì…êµ­
                  entryDate: {
                    gte: fromDate,
                    lte: toDate
                  }
                },
                {
                  // ê¸°ê°„ ë‚´ ì¶œêµ­
                  exitDate: {
                    gte: fromDate,
                    lte: toDate
                  }
                },
                {
                  // ê¸°ê°„ì„ ê°€ë¡œì§€ë¥´ëŠ” ì²´ë¥˜
                  AND: [
                    { entryDate: { lte: fromDate } },
                    {
                      OR: [
                        { exitDate: { gte: toDate } },
                        { exitDate: null }
                      ]
                    }
                  ]
                }
              ]
            },
            orderBy: { entryDate: 'asc' },
            select: {
              id: true,
              country: true,
              entryDate: true,
              exitDate: true,
              visaType: true
            }
          })
        },
        `getSchengenTrips_${userId}`
      )
    },
    { key: cacheKey, ttl: 600 } // 10ë¶„ ìºì‹œ (ê³„ì‚°ì´ ë³µì¡í•˜ë¯€ë¡œ ë” ê¸¸ê²Œ)

)
}

/\*\*
ëŒ€ì‹œë³´ë“œ í†µê³„ë¥¼ ìœ„í•œ ìµœì í™”ëœ ì¿¼ë¦¬

**íŠ¹ì„±:** `exported`, `async`

### ğŸ“¦ Classes

#### `QueryOptimizer`

### ğŸ”— Interfaces

#### `QueryMetrics`

#### `CacheOptions`

## db-performance.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/db-performance.ts`

**ì„¤ëª…:** Database Performance Optimization and Monitoring
Advanced query optimization, connection pooling, and performance analysis

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 13745 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 488
- ğŸ”§ í•¨ìˆ˜: 2ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 4ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 1ê°œ

**Exports:**

- `createOptimizedPrismaClient`
- `DatabaseConnectionPool`
- `OptimizedQueries`
- `DatabaseMaintenance`
- `dbPerformanceMonitor`
- `dbConnectionPool`
- `createDatabasePerformanceMiddleware`
- `type`

### ğŸ”§ Functions

#### `createOptimizedPrismaClient`

**íŠ¹ì„±:** `exported`

#### `createDatabasePerformanceMiddleware`

**íŠ¹ì„±:** `exported`

### ğŸ“¦ Classes

#### `DatabasePerformanceMonitor`

#### `DatabaseConnectionPool`

**íŠ¹ì„±:** `exported`

#### `OptimizedQueries`

**íŠ¹ì„±:** `exported`

#### `DatabaseMaintenance`

**íŠ¹ì„±:** `exported`

### ğŸ”— Interfaces

#### `QueryMetric`

## db-utils.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/db-utils.ts`

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 4555 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 150
- ğŸ”§ í•¨ìˆ˜: 10ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 0ê°œ

**Exports:**

- `async`
- `invalidateUserCache`

### ğŸ”§ Functions

#### `getUserByEmail`

**íŠ¹ì„±:** `exported`, `async`

#### `getUserById`

**íŠ¹ì„±:** `exported`, `async`

#### `createCountryVisit`

**íŠ¹ì„±:** `exported`, `async`

#### `updateCountryVisit`

**íŠ¹ì„±:** `exported`, `async`

#### `deleteCountryVisit`

**íŠ¹ì„±:** `exported`, `async`

#### `getUserCountryVisits`

**íŠ¹ì„±:** `exported`, `async`

#### `getSchengenCountryVisits`

**íŠ¹ì„±:** `exported`, `async`

#### `updateNotificationSettings`

**íŠ¹ì„±:** `exported`, `async`

#### `getUserTravelStats`

**íŠ¹ì„±:** `exported`, `async`

#### `invalidateUserCache`

**íŠ¹ì„±:** `exported`

## parser.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/email/parser.ts`

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 10901 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 415
- ğŸ”§ í•¨ìˆ˜: 2ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 1ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 0ê°œ

**Exports:**

- `EmailParser`
- `defaultEmailParser`
- `async`

### ğŸ”§ Functions

#### `parseEmail`

**íŠ¹ì„±:** `exported`, `async`

#### `parseEmails`

**íŠ¹ì„±:** `exported`, `async`

### ğŸ“¦ Classes

#### `EmailParser`

**íŠ¹ì„±:** `exported`

## patterns.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/email/patterns.ts`

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 6510 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 264
- ğŸ”§ í•¨ìˆ˜: 0ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 0ê°œ

**Exports:**

- `EMAIL_PROVIDERS`
- `COMMON_DATE_PATTERNS`
- `TIME_PATTERNS`
- `AIRPORT_CODE_PATTERN`
- `FLIGHT_NUMBER_PATTERNS`
- `CONFIRMATION_PATTERNS`

## service.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/email/service.ts`

**ì„¤ëª…:** Email service stub for testing

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 1046 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 46
- ğŸ”§ í•¨ìˆ˜: 3ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 1ê°œ

**Exports:**

- `EmailOptions`
- `async`
- `emailTemplates`

### ğŸ”§ Functions

#### `sendEmail`

**íŠ¹ì„±:** `exported`, `async`

#### `sendBulkEmails`

**íŠ¹ì„±:** `exported`, `async`

#### `sendTemplateEmail`

**íŠ¹ì„±:** `exported`, `async`

### ğŸ”— Interfaces

#### `EmailOptions`

**íŠ¹ì„±:** `exported`

## email-intelligence.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/email-intelligence.ts`

**ì„¤ëª…:** ì´ë©”ì¼ ì§€ëŠ¥í˜• ë¶„ì„ ë¼ì´ë¸ŒëŸ¬ë¦¬
ê³ ê¸‰ íŒ¨í„´ ë§¤ì¹­, ìì—°ì–´ ì²˜ë¦¬, ì»¨í…ìŠ¤íŠ¸ ë¶„ì„ì„ í†µí•œ ì—¬í–‰ ì •ë³´ ì¶”ì¶œ

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 9907 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 332
- ğŸ”§ í•¨ìˆ˜: 10ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 0ê°œ

**Exports:**

- `normalizeDateString`
- `validateFlightNumber`
- `validateAirportCode`
- `validateBookingReference`
- `adjustConfidenceByContext`
- `validateDataConsistency`
- `prioritizeTravelInfo`
- `deduplicateAndMergeTravelInfo`

### ğŸ”§ Functions

#### `normalizeDateString`

ì´ë©”ì¼ ì§€ëŠ¥í˜• ë¶„ì„ ë¼ì´ë¸ŒëŸ¬ë¦¬
ê³ ê¸‰ íŒ¨í„´ ë§¤ì¹­, ìì—°ì–´ ì²˜ë¦¬, ì»¨í…ìŠ¤íŠ¸ ë¶„ì„ì„ í†µí•œ ì—¬í–‰ ì •ë³´ ì¶”ì¶œ
/

import { ExtractedTravelInfo } from '@/types/gmail'
import { airportCodes, airlineCodes } from '@/data/travel-patterns'

/\*\*
ë‚ ì§œ ë¬¸ìì—´ì„ í‘œì¤€ í˜•ì‹ìœ¼ë¡œ ì •ê·œí™”

**íŠ¹ì„±:** `exported`

#### `validateFlightNumber`

ì´ë©”ì¼ ì§€ëŠ¥í˜• ë¶„ì„ ë¼ì´ë¸ŒëŸ¬ë¦¬
ê³ ê¸‰ íŒ¨í„´ ë§¤ì¹­, ìì—°ì–´ ì²˜ë¦¬, ì»¨í…ìŠ¤íŠ¸ ë¶„ì„ì„ í†µí•œ ì—¬í–‰ ì •ë³´ ì¶”ì¶œ
/

import { ExtractedTravelInfo } from '@/types/gmail'
import { airportCodes, airlineCodes } from '@/data/travel-patterns'

/\*\*
ë‚ ì§œ ë¬¸ìì—´ì„ í‘œì¤€ í˜•ì‹ìœ¼ë¡œ ì •ê·œí™”
/
export function normalizeDateString(dateStr: string): string | null {
if (!dateStr) return null

// ë‹¤ì–‘í•œ ë‚ ì§œ í˜•ì‹ì„ ISO í˜•ì‹ìœ¼ë¡œ ë³€í™˜
const dateFormats = [
// YYYY-MM-DD
/(\d{4})-(\d{1,2})-(\d{1,2})/,
// MM/DD/YYYY
/(\d{1,2})\/(\d{1,2})\/(\d{4})/,
// DD/MM/YYYY
/(\d{1,2})\/(\d{1,2})\/(\d{4})/,
// YYYYë…„ MMì›” DDì¼
/(\d{4})ë…„\s*(\d{1,2})ì›”\s*(\d{1,2})ì¼/,
// MMM DD, YYYY
/(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\w*\s+(\d{1,2}),?\s+(\d{4})/i,
// DD MMM YYYY
/(\d{1,2})\s+(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\w*\s+(\d{4})/i
]

const monthMap: { [key: string]: string } = {
'jan': '01', 'feb': '02', 'mar': '03', 'apr': '04',
'may': '05', 'jun': '06', 'jul': '07', 'aug': '08',
'sep': '09', 'oct': '10', 'nov': '11', 'dec': '12'
}

for (const format of dateFormats) {
const match = dateStr.match(format)
if (match) {
if (format === dateFormats[0]) { // YYYY-MM-DD
return `${match[1]}-${match[2].padStart(2, '0')}-${match[3].padStart(2, '0')}`
} else if (format === dateFormats[1] || format === dateFormats[2]) { // MM/DD/YYYY
return `${match[3]}-${match[1].padStart(2, '0')}-${match[2].padStart(2, '0')}`
} else if (format === dateFormats[3]) { // í•œêµ­ì–´ í˜•ì‹
return `${match[1]}-${match[2].padStart(2, '0')}-${match[3].padStart(2, '0')}`
} else if (format === dateFormats[4]) { // MMM DD, YYYY
const month = monthMap[match[1].toLowerCase().substring(0, 3)]
return `${match[3]}-${month}-${match[2].padStart(2, '0')}`
} else if (format === dateFormats[5]) { // DD MMM YYYY
const month = monthMap[match[2].toLowerCase().substring(0, 3)]
return `${match[3]}-${month}-${match[1].padStart(2, '0')}`
}
}
}

return null
}

/\*\*
í•­ê³µí¸ ë²ˆí˜¸ì˜ ìœ íš¨ì„± ê²€ì¦

**íŠ¹ì„±:** `exported`

#### `validateAirportCode`

ì´ë©”ì¼ ì§€ëŠ¥í˜• ë¶„ì„ ë¼ì´ë¸ŒëŸ¬ë¦¬
ê³ ê¸‰ íŒ¨í„´ ë§¤ì¹­, ìì—°ì–´ ì²˜ë¦¬, ì»¨í…ìŠ¤íŠ¸ ë¶„ì„ì„ í†µí•œ ì—¬í–‰ ì •ë³´ ì¶”ì¶œ
/

import { ExtractedTravelInfo } from '@/types/gmail'
import { airportCodes, airlineCodes } from '@/data/travel-patterns'

/\*\*
ë‚ ì§œ ë¬¸ìì—´ì„ í‘œì¤€ í˜•ì‹ìœ¼ë¡œ ì •ê·œí™”
/
export function normalizeDateString(dateStr: string): string | null {
if (!dateStr) return null

// ë‹¤ì–‘í•œ ë‚ ì§œ í˜•ì‹ì„ ISO í˜•ì‹ìœ¼ë¡œ ë³€í™˜
const dateFormats = [
// YYYY-MM-DD
/(\d{4})-(\d{1,2})-(\d{1,2})/,
// MM/DD/YYYY
/(\d{1,2})\/(\d{1,2})\/(\d{4})/,
// DD/MM/YYYY
/(\d{1,2})\/(\d{1,2})\/(\d{4})/,
// YYYYë…„ MMì›” DDì¼
/(\d{4})ë…„\s*(\d{1,2})ì›”\s*(\d{1,2})ì¼/,
// MMM DD, YYYY
/(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\w*\s+(\d{1,2}),?\s+(\d{4})/i,
// DD MMM YYYY
/(\d{1,2})\s+(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\w*\s+(\d{4})/i
]

const monthMap: { [key: string]: string } = {
'jan': '01', 'feb': '02', 'mar': '03', 'apr': '04',
'may': '05', 'jun': '06', 'jul': '07', 'aug': '08',
'sep': '09', 'oct': '10', 'nov': '11', 'dec': '12'
}

for (const format of dateFormats) {
const match = dateStr.match(format)
if (match) {
if (format === dateFormats[0]) { // YYYY-MM-DD
return `${match[1]}-${match[2].padStart(2, '0')}-${match[3].padStart(2, '0')}`
} else if (format === dateFormats[1] || format === dateFormats[2]) { // MM/DD/YYYY
return `${match[3]}-${match[1].padStart(2, '0')}-${match[2].padStart(2, '0')}`
} else if (format === dateFormats[3]) { // í•œêµ­ì–´ í˜•ì‹
return `${match[1]}-${match[2].padStart(2, '0')}-${match[3].padStart(2, '0')}`
} else if (format === dateFormats[4]) { // MMM DD, YYYY
const month = monthMap[match[1].toLowerCase().substring(0, 3)]
return `${match[3]}-${month}-${match[2].padStart(2, '0')}`
} else if (format === dateFormats[5]) { // DD MMM YYYY
const month = monthMap[match[2].toLowerCase().substring(0, 3)]
return `${match[3]}-${month}-${match[1].padStart(2, '0')}`
}
}
}

return null
}

/\*\*
í•­ê³µí¸ ë²ˆí˜¸ì˜ ìœ íš¨ì„± ê²€ì¦
/
export function validateFlightNumber(flightNumber: string): boolean {
if (!flightNumber) return false

const normalizedFlight = flightNumber.toUpperCase().replace(/\s+/g, '')
const match = normalizedFlight.match(/^([A-Z]{2,3})(\d{1,4})$/)

if (!match) return false

const [, airlineCode, flightNum] = match

// í•­ê³µì‚¬ ì½”ë“œ ê²€ì¦
if (!(airlineCode in airlineCodes)) return false

// í•­ê³µí¸ ë²ˆí˜¸ ë²”ìœ„ ê²€ì¦ (ì¼ë°˜ì ìœ¼ë¡œ 1-9999)
const num = parseInt(flightNum)
return num >= 1 && num <= 9999
}

/\*\*
ê³µí•­ ì½”ë“œì˜ ìœ íš¨ì„± ê²€ì¦

**íŠ¹ì„±:** `exported`

#### `validateBookingReference`

ì´ë©”ì¼ ì§€ëŠ¥í˜• ë¶„ì„ ë¼ì´ë¸ŒëŸ¬ë¦¬
ê³ ê¸‰ íŒ¨í„´ ë§¤ì¹­, ìì—°ì–´ ì²˜ë¦¬, ì»¨í…ìŠ¤íŠ¸ ë¶„ì„ì„ í†µí•œ ì—¬í–‰ ì •ë³´ ì¶”ì¶œ
/

import { ExtractedTravelInfo } from '@/types/gmail'
import { airportCodes, airlineCodes } from '@/data/travel-patterns'

/\*\*
ë‚ ì§œ ë¬¸ìì—´ì„ í‘œì¤€ í˜•ì‹ìœ¼ë¡œ ì •ê·œí™”
/
export function normalizeDateString(dateStr: string): string | null {
if (!dateStr) return null

// ë‹¤ì–‘í•œ ë‚ ì§œ í˜•ì‹ì„ ISO í˜•ì‹ìœ¼ë¡œ ë³€í™˜
const dateFormats = [
// YYYY-MM-DD
/(\d{4})-(\d{1,2})-(\d{1,2})/,
// MM/DD/YYYY
/(\d{1,2})\/(\d{1,2})\/(\d{4})/,
// DD/MM/YYYY
/(\d{1,2})\/(\d{1,2})\/(\d{4})/,
// YYYYë…„ MMì›” DDì¼
/(\d{4})ë…„\s*(\d{1,2})ì›”\s*(\d{1,2})ì¼/,
// MMM DD, YYYY
/(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\w*\s+(\d{1,2}),?\s+(\d{4})/i,
// DD MMM YYYY
/(\d{1,2})\s+(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\w*\s+(\d{4})/i
]

const monthMap: { [key: string]: string } = {
'jan': '01', 'feb': '02', 'mar': '03', 'apr': '04',
'may': '05', 'jun': '06', 'jul': '07', 'aug': '08',
'sep': '09', 'oct': '10', 'nov': '11', 'dec': '12'
}

for (const format of dateFormats) {
const match = dateStr.match(format)
if (match) {
if (format === dateFormats[0]) { // YYYY-MM-DD
return `${match[1]}-${match[2].padStart(2, '0')}-${match[3].padStart(2, '0')}`
} else if (format === dateFormats[1] || format === dateFormats[2]) { // MM/DD/YYYY
return `${match[3]}-${match[1].padStart(2, '0')}-${match[2].padStart(2, '0')}`
} else if (format === dateFormats[3]) { // í•œêµ­ì–´ í˜•ì‹
return `${match[1]}-${match[2].padStart(2, '0')}-${match[3].padStart(2, '0')}`
} else if (format === dateFormats[4]) { // MMM DD, YYYY
const month = monthMap[match[1].toLowerCase().substring(0, 3)]
return `${match[3]}-${month}-${match[2].padStart(2, '0')}`
} else if (format === dateFormats[5]) { // DD MMM YYYY
const month = monthMap[match[2].toLowerCase().substring(0, 3)]
return `${match[3]}-${month}-${match[1].padStart(2, '0')}`
}
}
}

return null
}

/\*\*
í•­ê³µí¸ ë²ˆí˜¸ì˜ ìœ íš¨ì„± ê²€ì¦
/
export function validateFlightNumber(flightNumber: string): boolean {
if (!flightNumber) return false

const normalizedFlight = flightNumber.toUpperCase().replace(/\s+/g, '')
const match = normalizedFlight.match(/^([A-Z]{2,3})(\d{1,4})$/)

if (!match) return false

const [, airlineCode, flightNum] = match

// í•­ê³µì‚¬ ì½”ë“œ ê²€ì¦
if (!(airlineCode in airlineCodes)) return false

// í•­ê³µí¸ ë²ˆí˜¸ ë²”ìœ„ ê²€ì¦ (ì¼ë°˜ì ìœ¼ë¡œ 1-9999)
const num = parseInt(flightNum)
return num >= 1 && num <= 9999
}

/\*\*
ê³µí•­ ì½”ë“œì˜ ìœ íš¨ì„± ê²€ì¦
/
export function validateAirportCode(airportCode: string): boolean {
if (!airportCode) return false

const normalizedCode = airportCode.toUpperCase()
return normalizedCode.length === 3 && /^[A-Z]{3}$/.test(normalizedCode) && normalizedCode in airportCodes
}

/\*\*
ì˜ˆì•½ ë²ˆí˜¸ì˜ ìœ íš¨ì„± ê²€ì¦

**íŠ¹ì„±:** `exported`

#### `adjustConfidenceByContext`

ì´ë©”ì¼ ì§€ëŠ¥í˜• ë¶„ì„ ë¼ì´ë¸ŒëŸ¬ë¦¬
ê³ ê¸‰ íŒ¨í„´ ë§¤ì¹­, ìì—°ì–´ ì²˜ë¦¬, ì»¨í…ìŠ¤íŠ¸ ë¶„ì„ì„ í†µí•œ ì—¬í–‰ ì •ë³´ ì¶”ì¶œ
/

import { ExtractedTravelInfo } from '@/types/gmail'
import { airportCodes, airlineCodes } from '@/data/travel-patterns'

/\*\*
ë‚ ì§œ ë¬¸ìì—´ì„ í‘œì¤€ í˜•ì‹ìœ¼ë¡œ ì •ê·œí™”
/
export function normalizeDateString(dateStr: string): string | null {
if (!dateStr) return null

// ë‹¤ì–‘í•œ ë‚ ì§œ í˜•ì‹ì„ ISO í˜•ì‹ìœ¼ë¡œ ë³€í™˜
const dateFormats = [
// YYYY-MM-DD
/(\d{4})-(\d{1,2})-(\d{1,2})/,
// MM/DD/YYYY
/(\d{1,2})\/(\d{1,2})\/(\d{4})/,
// DD/MM/YYYY
/(\d{1,2})\/(\d{1,2})\/(\d{4})/,
// YYYYë…„ MMì›” DDì¼
/(\d{4})ë…„\s*(\d{1,2})ì›”\s*(\d{1,2})ì¼/,
// MMM DD, YYYY
/(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\w*\s+(\d{1,2}),?\s+(\d{4})/i,
// DD MMM YYYY
/(\d{1,2})\s+(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\w*\s+(\d{4})/i
]

const monthMap: { [key: string]: string } = {
'jan': '01', 'feb': '02', 'mar': '03', 'apr': '04',
'may': '05', 'jun': '06', 'jul': '07', 'aug': '08',
'sep': '09', 'oct': '10', 'nov': '11', 'dec': '12'
}

for (const format of dateFormats) {
const match = dateStr.match(format)
if (match) {
if (format === dateFormats[0]) { // YYYY-MM-DD
return `${match[1]}-${match[2].padStart(2, '0')}-${match[3].padStart(2, '0')}`
} else if (format === dateFormats[1] || format === dateFormats[2]) { // MM/DD/YYYY
return `${match[3]}-${match[1].padStart(2, '0')}-${match[2].padStart(2, '0')}`
} else if (format === dateFormats[3]) { // í•œêµ­ì–´ í˜•ì‹
return `${match[1]}-${match[2].padStart(2, '0')}-${match[3].padStart(2, '0')}`
} else if (format === dateFormats[4]) { // MMM DD, YYYY
const month = monthMap[match[1].toLowerCase().substring(0, 3)]
return `${match[3]}-${month}-${match[2].padStart(2, '0')}`
} else if (format === dateFormats[5]) { // DD MMM YYYY
const month = monthMap[match[2].toLowerCase().substring(0, 3)]
return `${match[3]}-${month}-${match[1].padStart(2, '0')}`
}
}
}

return null
}

/\*\*
í•­ê³µí¸ ë²ˆí˜¸ì˜ ìœ íš¨ì„± ê²€ì¦
/
export function validateFlightNumber(flightNumber: string): boolean {
if (!flightNumber) return false

const normalizedFlight = flightNumber.toUpperCase().replace(/\s+/g, '')
const match = normalizedFlight.match(/^([A-Z]{2,3})(\d{1,4})$/)

if (!match) return false

const [, airlineCode, flightNum] = match

// í•­ê³µì‚¬ ì½”ë“œ ê²€ì¦
if (!(airlineCode in airlineCodes)) return false

// í•­ê³µí¸ ë²ˆí˜¸ ë²”ìœ„ ê²€ì¦ (ì¼ë°˜ì ìœ¼ë¡œ 1-9999)
const num = parseInt(flightNum)
return num >= 1 && num <= 9999
}

/\*\*
ê³µí•­ ì½”ë“œì˜ ìœ íš¨ì„± ê²€ì¦
/
export function validateAirportCode(airportCode: string): boolean {
if (!airportCode) return false

const normalizedCode = airportCode.toUpperCase()
return normalizedCode.length === 3 && /^[A-Z]{3}$/.test(normalizedCode) && normalizedCode in airportCodes
}

/\*\*
ì˜ˆì•½ ë²ˆí˜¸ì˜ ìœ íš¨ì„± ê²€ì¦
/
export function validateBookingReference(bookingRef: string): boolean {
if (!bookingRef) return false

// ì¼ë°˜ì ì¸ ì˜ˆì•½ ë²ˆí˜¸ íŒ¨í„´ (6-8ìë¦¬ ì˜ìˆ«ì)
return /^[A-Z0-9]{6,8}$/.test(bookingRef.toUpperCase())
}

/\*\*
ì»¨í…ìŠ¤íŠ¸ ê¸°ë°˜ ì‹ ë¢°ë„ ì¡°ì •

**íŠ¹ì„±:** `exported`

#### `validateDataConsistency`

ì´ë©”ì¼ ì§€ëŠ¥í˜• ë¶„ì„ ë¼ì´ë¸ŒëŸ¬ë¦¬
ê³ ê¸‰ íŒ¨í„´ ë§¤ì¹­, ìì—°ì–´ ì²˜ë¦¬, ì»¨í…ìŠ¤íŠ¸ ë¶„ì„ì„ í†µí•œ ì—¬í–‰ ì •ë³´ ì¶”ì¶œ
/

import { ExtractedTravelInfo } from '@/types/gmail'
import { airportCodes, airlineCodes } from '@/data/travel-patterns'

/\*\*
ë‚ ì§œ ë¬¸ìì—´ì„ í‘œì¤€ í˜•ì‹ìœ¼ë¡œ ì •ê·œí™”
/
export function normalizeDateString(dateStr: string): string | null {
if (!dateStr) return null

// ë‹¤ì–‘í•œ ë‚ ì§œ í˜•ì‹ì„ ISO í˜•ì‹ìœ¼ë¡œ ë³€í™˜
const dateFormats = [
// YYYY-MM-DD
/(\d{4})-(\d{1,2})-(\d{1,2})/,
// MM/DD/YYYY
/(\d{1,2})\/(\d{1,2})\/(\d{4})/,
// DD/MM/YYYY
/(\d{1,2})\/(\d{1,2})\/(\d{4})/,
// YYYYë…„ MMì›” DDì¼
/(\d{4})ë…„\s*(\d{1,2})ì›”\s*(\d{1,2})ì¼/,
// MMM DD, YYYY
/(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\w*\s+(\d{1,2}),?\s+(\d{4})/i,
// DD MMM YYYY
/(\d{1,2})\s+(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\w*\s+(\d{4})/i
]

const monthMap: { [key: string]: string } = {
'jan': '01', 'feb': '02', 'mar': '03', 'apr': '04',
'may': '05', 'jun': '06', 'jul': '07', 'aug': '08',
'sep': '09', 'oct': '10', 'nov': '11', 'dec': '12'
}

for (const format of dateFormats) {
const match = dateStr.match(format)
if (match) {
if (format === dateFormats[0]) { // YYYY-MM-DD
return `${match[1]}-${match[2].padStart(2, '0')}-${match[3].padStart(2, '0')}`
} else if (format === dateFormats[1] || format === dateFormats[2]) { // MM/DD/YYYY
return `${match[3]}-${match[1].padStart(2, '0')}-${match[2].padStart(2, '0')}`
} else if (format === dateFormats[3]) { // í•œêµ­ì–´ í˜•ì‹
return `${match[1]}-${match[2].padStart(2, '0')}-${match[3].padStart(2, '0')}`
} else if (format === dateFormats[4]) { // MMM DD, YYYY
const month = monthMap[match[1].toLowerCase().substring(0, 3)]
return `${match[3]}-${month}-${match[2].padStart(2, '0')}`
} else if (format === dateFormats[5]) { // DD MMM YYYY
const month = monthMap[match[2].toLowerCase().substring(0, 3)]
return `${match[3]}-${month}-${match[1].padStart(2, '0')}`
}
}
}

return null
}

/\*\*
í•­ê³µí¸ ë²ˆí˜¸ì˜ ìœ íš¨ì„± ê²€ì¦
/
export function validateFlightNumber(flightNumber: string): boolean {
if (!flightNumber) return false

const normalizedFlight = flightNumber.toUpperCase().replace(/\s+/g, '')
const match = normalizedFlight.match(/^([A-Z]{2,3})(\d{1,4})$/)

if (!match) return false

const [, airlineCode, flightNum] = match

// í•­ê³µì‚¬ ì½”ë“œ ê²€ì¦
if (!(airlineCode in airlineCodes)) return false

// í•­ê³µí¸ ë²ˆí˜¸ ë²”ìœ„ ê²€ì¦ (ì¼ë°˜ì ìœ¼ë¡œ 1-9999)
const num = parseInt(flightNum)
return num >= 1 && num <= 9999
}

/\*\*
ê³µí•­ ì½”ë“œì˜ ìœ íš¨ì„± ê²€ì¦
/
export function validateAirportCode(airportCode: string): boolean {
if (!airportCode) return false

const normalizedCode = airportCode.toUpperCase()
return normalizedCode.length === 3 && /^[A-Z]{3}$/.test(normalizedCode) && normalizedCode in airportCodes
}

/\*\*
ì˜ˆì•½ ë²ˆí˜¸ì˜ ìœ íš¨ì„± ê²€ì¦
/
export function validateBookingReference(bookingRef: string): boolean {
if (!bookingRef) return false

// ì¼ë°˜ì ì¸ ì˜ˆì•½ ë²ˆí˜¸ íŒ¨í„´ (6-8ìë¦¬ ì˜ìˆ«ì)
return /^[A-Z0-9]{6,8}$/.test(bookingRef.toUpperCase())
}

/\*\*
ì»¨í…ìŠ¤íŠ¸ ê¸°ë°˜ ì‹ ë¢°ë„ ì¡°ì •
/
export function adjustConfidenceByContext(
travelInfo: ExtractedTravelInfo,
emailContext: {
senderDomain: string
hasMultipleBookings: boolean
isForwardedEmail: boolean
hasAttachments: boolean
}
): number {
let adjustedConfidence = travelInfo.confidence

// ì‹ ë¢°í•  ìˆ˜ ìˆëŠ” ë°œì‹ ì ë„ë©”ì¸ ë³´ë„ˆìŠ¤
const trustedDomains = [
'koreanair.com', 'flyasiana.com', 'jejuair.net',
'united.com', 'delta.com', 'jal.com',
'booking.com', 'expedia.com', 'agoda.com',
'hotels.com', 'airbnb.com'
]

if (trustedDomains.some(domain => emailContext.senderDomain.includes(domain))) {
adjustedConfidence += 0.15
}

// ì²¨ë¶€íŒŒì¼ì´ ìˆëŠ” ê²½ìš° (e-ticket ë“±)
if (emailContext.hasAttachments) {
adjustedConfidence += 0.1
}

// ì „ë‹¬ëœ ì´ë©”ì¼ì˜ ê²½ìš° ì‹ ë¢°ë„ ê°ì†Œ
if (emailContext.isForwardedEmail) {
adjustedConfidence -= 0.1
}

// ì—¬ëŸ¬ ì˜ˆì•½ì´ í¬í•¨ëœ ê²½ìš° í˜¼ë€ ê°€ëŠ¥ì„±ìœ¼ë¡œ ì‹ ë¢°ë„ ê°ì†Œ
if (emailContext.hasMultipleBookings) {
adjustedConfidence -= 0.05
}

return Math.max(0, Math.min(1, adjustedConfidence))
}

/\*\*
ì¶”ì¶œëœ ë°ì´í„°ì˜ ì¼ê´€ì„± ê²€ì¦

**íŠ¹ì„±:** `exported`

#### `prioritizeTravelInfo`

ì´ë©”ì¼ ì§€ëŠ¥í˜• ë¶„ì„ ë¼ì´ë¸ŒëŸ¬ë¦¬
ê³ ê¸‰ íŒ¨í„´ ë§¤ì¹­, ìì—°ì–´ ì²˜ë¦¬, ì»¨í…ìŠ¤íŠ¸ ë¶„ì„ì„ í†µí•œ ì—¬í–‰ ì •ë³´ ì¶”ì¶œ
/

import { ExtractedTravelInfo } from '@/types/gmail'
import { airportCodes, airlineCodes } from '@/data/travel-patterns'

/\*\*
ë‚ ì§œ ë¬¸ìì—´ì„ í‘œì¤€ í˜•ì‹ìœ¼ë¡œ ì •ê·œí™”
/
export function normalizeDateString(dateStr: string): string | null {
if (!dateStr) return null

// ë‹¤ì–‘í•œ ë‚ ì§œ í˜•ì‹ì„ ISO í˜•ì‹ìœ¼ë¡œ ë³€í™˜
const dateFormats = [
// YYYY-MM-DD
/(\d{4})-(\d{1,2})-(\d{1,2})/,
// MM/DD/YYYY
/(\d{1,2})\/(\d{1,2})\/(\d{4})/,
// DD/MM/YYYY
/(\d{1,2})\/(\d{1,2})\/(\d{4})/,
// YYYYë…„ MMì›” DDì¼
/(\d{4})ë…„\s*(\d{1,2})ì›”\s*(\d{1,2})ì¼/,
// MMM DD, YYYY
/(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\w*\s+(\d{1,2}),?\s+(\d{4})/i,
// DD MMM YYYY
/(\d{1,2})\s+(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\w*\s+(\d{4})/i
]

const monthMap: { [key: string]: string } = {
'jan': '01', 'feb': '02', 'mar': '03', 'apr': '04',
'may': '05', 'jun': '06', 'jul': '07', 'aug': '08',
'sep': '09', 'oct': '10', 'nov': '11', 'dec': '12'
}

for (const format of dateFormats) {
const match = dateStr.match(format)
if (match) {
if (format === dateFormats[0]) { // YYYY-MM-DD
return `${match[1]}-${match[2].padStart(2, '0')}-${match[3].padStart(2, '0')}`
} else if (format === dateFormats[1] || format === dateFormats[2]) { // MM/DD/YYYY
return `${match[3]}-${match[1].padStart(2, '0')}-${match[2].padStart(2, '0')}`
} else if (format === dateFormats[3]) { // í•œêµ­ì–´ í˜•ì‹
return `${match[1]}-${match[2].padStart(2, '0')}-${match[3].padStart(2, '0')}`
} else if (format === dateFormats[4]) { // MMM DD, YYYY
const month = monthMap[match[1].toLowerCase().substring(0, 3)]
return `${match[3]}-${month}-${match[2].padStart(2, '0')}`
} else if (format === dateFormats[5]) { // DD MMM YYYY
const month = monthMap[match[2].toLowerCase().substring(0, 3)]
return `${match[3]}-${month}-${match[1].padStart(2, '0')}`
}
}
}

return null
}

/\*\*
í•­ê³µí¸ ë²ˆí˜¸ì˜ ìœ íš¨ì„± ê²€ì¦
/
export function validateFlightNumber(flightNumber: string): boolean {
if (!flightNumber) return false

const normalizedFlight = flightNumber.toUpperCase().replace(/\s+/g, '')
const match = normalizedFlight.match(/^([A-Z]{2,3})(\d{1,4})$/)

if (!match) return false

const [, airlineCode, flightNum] = match

// í•­ê³µì‚¬ ì½”ë“œ ê²€ì¦
if (!(airlineCode in airlineCodes)) return false

// í•­ê³µí¸ ë²ˆí˜¸ ë²”ìœ„ ê²€ì¦ (ì¼ë°˜ì ìœ¼ë¡œ 1-9999)
const num = parseInt(flightNum)
return num >= 1 && num <= 9999
}

/\*\*
ê³µí•­ ì½”ë“œì˜ ìœ íš¨ì„± ê²€ì¦
/
export function validateAirportCode(airportCode: string): boolean {
if (!airportCode) return false

const normalizedCode = airportCode.toUpperCase()
return normalizedCode.length === 3 && /^[A-Z]{3}$/.test(normalizedCode) && normalizedCode in airportCodes
}

/\*\*
ì˜ˆì•½ ë²ˆí˜¸ì˜ ìœ íš¨ì„± ê²€ì¦
/
export function validateBookingReference(bookingRef: string): boolean {
if (!bookingRef) return false

// ì¼ë°˜ì ì¸ ì˜ˆì•½ ë²ˆí˜¸ íŒ¨í„´ (6-8ìë¦¬ ì˜ìˆ«ì)
return /^[A-Z0-9]{6,8}$/.test(bookingRef.toUpperCase())
}

/\*\*
ì»¨í…ìŠ¤íŠ¸ ê¸°ë°˜ ì‹ ë¢°ë„ ì¡°ì •
/
export function adjustConfidenceByContext(
travelInfo: ExtractedTravelInfo,
emailContext: {
senderDomain: string
hasMultipleBookings: boolean
isForwardedEmail: boolean
hasAttachments: boolean
}
): number {
let adjustedConfidence = travelInfo.confidence

// ì‹ ë¢°í•  ìˆ˜ ìˆëŠ” ë°œì‹ ì ë„ë©”ì¸ ë³´ë„ˆìŠ¤
const trustedDomains = [
'koreanair.com', 'flyasiana.com', 'jejuair.net',
'united.com', 'delta.com', 'jal.com',
'booking.com', 'expedia.com', 'agoda.com',
'hotels.com', 'airbnb.com'
]

if (trustedDomains.some(domain => emailContext.senderDomain.includes(domain))) {
adjustedConfidence += 0.15
}

// ì²¨ë¶€íŒŒì¼ì´ ìˆëŠ” ê²½ìš° (e-ticket ë“±)
if (emailContext.hasAttachments) {
adjustedConfidence += 0.1
}

// ì „ë‹¬ëœ ì´ë©”ì¼ì˜ ê²½ìš° ì‹ ë¢°ë„ ê°ì†Œ
if (emailContext.isForwardedEmail) {
adjustedConfidence -= 0.1
}

// ì—¬ëŸ¬ ì˜ˆì•½ì´ í¬í•¨ëœ ê²½ìš° í˜¼ë€ ê°€ëŠ¥ì„±ìœ¼ë¡œ ì‹ ë¢°ë„ ê°ì†Œ
if (emailContext.hasMultipleBookings) {
adjustedConfidence -= 0.05
}

return Math.max(0, Math.min(1, adjustedConfidence))
}

/\*\*
ì¶”ì¶œëœ ë°ì´í„°ì˜ ì¼ê´€ì„± ê²€ì¦
/
export function validateDataConsistency(travelInfo: ExtractedTravelInfo): {
isConsistent: boolean
issues: string[]
} {
const issues: string[] = []

// ë‚ ì§œ ì¼ê´€ì„± ê²€ì¦
if (travelInfo.departureDate && travelInfo.returnDate) {
const depDate = new Date(normalizeDateString(travelInfo.departureDate) || '')
const retDate = new Date(normalizeDateString(travelInfo.returnDate) || '')

    if (depDate >= retDate) {
      issues.push('Return date must be after departure date')
    }

    // ê³¼ê±° ë‚ ì§œ í™•ì¸ (30ì¼ ì´ì „)
    const thirtyDaysAgo = new Date()
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30)

    if (depDate < thirtyDaysAgo) {
      issues.push('Departure date is more than 30 days in the past')
    }

    // ë„ˆë¬´ ë¨¼ ë¯¸ë˜ ë‚ ì§œ í™•ì¸ (2ë…„ ì´í›„)
    const twoYearsLater = new Date()
    twoYearsLater.setFullYear(twoYearsLater.getFullYear() + 2)

    if (depDate > twoYearsLater) {
      issues.push('Departure date is more than 2 years in the future')
    }

}

// í•­ê³µí¸ ë²ˆí˜¸ ê²€ì¦
if (travelInfo.flightNumber && !validateFlightNumber(travelInfo.flightNumber)) {
issues.push(`Invalid flight number: ${travelInfo.flightNumber}`)
}

// ê³µí•­ ì½”ë“œ ê²€ì¦
if (travelInfo.departure && !validateAirportCode(travelInfo.departure)) {
issues.push(`Invalid departure airport code: ${travelInfo.departure}`)
}

if (travelInfo.destination && !validateAirportCode(travelInfo.destination)) {
issues.push(`Invalid destination airport code: ${travelInfo.destination}`)
}

// ê°™ì€ ì¶œë°œì§€ì™€ ëª©ì ì§€ í™•ì¸
if (travelInfo.departure && travelInfo.destination &&
travelInfo.departure === travelInfo.destination) {
issues.push('Departure and destination airports cannot be the same')
}

// ì˜ˆì•½ ë²ˆí˜¸ ê²€ì¦
if (travelInfo.bookingReference && !validateBookingReference(travelInfo.bookingReference)) {
issues.push(`Invalid booking reference format: ${travelInfo.bookingReference}`)
}

return {
isConsistent: issues.length === 0,
issues
}
}

/\*\*
ì—¬í–‰ ì •ë³´ ìš°ì„ ìˆœìœ„ ê²°ì •
ì—¬ëŸ¬ ê°œì˜ ì—¬í–‰ ì •ë³´ê°€ ì¶”ì¶œëœ ê²½ìš° ê°€ì¥ ì‹ ë¢°í•  ìˆ˜ ìˆëŠ” ê²ƒì„ ì„ íƒ

**íŠ¹ì„±:** `exported`

#### `getDataCompleteness`

ì´ë©”ì¼ ì§€ëŠ¥í˜• ë¶„ì„ ë¼ì´ë¸ŒëŸ¬ë¦¬
ê³ ê¸‰ íŒ¨í„´ ë§¤ì¹­, ìì—°ì–´ ì²˜ë¦¬, ì»¨í…ìŠ¤íŠ¸ ë¶„ì„ì„ í†µí•œ ì—¬í–‰ ì •ë³´ ì¶”ì¶œ
/

import { ExtractedTravelInfo } from '@/types/gmail'
import { airportCodes, airlineCodes } from '@/data/travel-patterns'

/\*\*
ë‚ ì§œ ë¬¸ìì—´ì„ í‘œì¤€ í˜•ì‹ìœ¼ë¡œ ì •ê·œí™”
/
export function normalizeDateString(dateStr: string): string | null {
if (!dateStr) return null

// ë‹¤ì–‘í•œ ë‚ ì§œ í˜•ì‹ì„ ISO í˜•ì‹ìœ¼ë¡œ ë³€í™˜
const dateFormats = [
// YYYY-MM-DD
/(\d{4})-(\d{1,2})-(\d{1,2})/,
// MM/DD/YYYY
/(\d{1,2})\/(\d{1,2})\/(\d{4})/,
// DD/MM/YYYY
/(\d{1,2})\/(\d{1,2})\/(\d{4})/,
// YYYYë…„ MMì›” DDì¼
/(\d{4})ë…„\s*(\d{1,2})ì›”\s*(\d{1,2})ì¼/,
// MMM DD, YYYY
/(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\w*\s+(\d{1,2}),?\s+(\d{4})/i,
// DD MMM YYYY
/(\d{1,2})\s+(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\w*\s+(\d{4})/i
]

const monthMap: { [key: string]: string } = {
'jan': '01', 'feb': '02', 'mar': '03', 'apr': '04',
'may': '05', 'jun': '06', 'jul': '07', 'aug': '08',
'sep': '09', 'oct': '10', 'nov': '11', 'dec': '12'
}

for (const format of dateFormats) {
const match = dateStr.match(format)
if (match) {
if (format === dateFormats[0]) { // YYYY-MM-DD
return `${match[1]}-${match[2].padStart(2, '0')}-${match[3].padStart(2, '0')}`
} else if (format === dateFormats[1] || format === dateFormats[2]) { // MM/DD/YYYY
return `${match[3]}-${match[1].padStart(2, '0')}-${match[2].padStart(2, '0')}`
} else if (format === dateFormats[3]) { // í•œêµ­ì–´ í˜•ì‹
return `${match[1]}-${match[2].padStart(2, '0')}-${match[3].padStart(2, '0')}`
} else if (format === dateFormats[4]) { // MMM DD, YYYY
const month = monthMap[match[1].toLowerCase().substring(0, 3)]
return `${match[3]}-${month}-${match[2].padStart(2, '0')}`
} else if (format === dateFormats[5]) { // DD MMM YYYY
const month = monthMap[match[2].toLowerCase().substring(0, 3)]
return `${match[3]}-${month}-${match[1].padStart(2, '0')}`
}
}
}

return null
}

/\*\*
í•­ê³µí¸ ë²ˆí˜¸ì˜ ìœ íš¨ì„± ê²€ì¦
/
export function validateFlightNumber(flightNumber: string): boolean {
if (!flightNumber) return false

const normalizedFlight = flightNumber.toUpperCase().replace(/\s+/g, '')
const match = normalizedFlight.match(/^([A-Z]{2,3})(\d{1,4})$/)

if (!match) return false

const [, airlineCode, flightNum] = match

// í•­ê³µì‚¬ ì½”ë“œ ê²€ì¦
if (!(airlineCode in airlineCodes)) return false

// í•­ê³µí¸ ë²ˆí˜¸ ë²”ìœ„ ê²€ì¦ (ì¼ë°˜ì ìœ¼ë¡œ 1-9999)
const num = parseInt(flightNum)
return num >= 1 && num <= 9999
}

/\*\*
ê³µí•­ ì½”ë“œì˜ ìœ íš¨ì„± ê²€ì¦
/
export function validateAirportCode(airportCode: string): boolean {
if (!airportCode) return false

const normalizedCode = airportCode.toUpperCase()
return normalizedCode.length === 3 && /^[A-Z]{3}$/.test(normalizedCode) && normalizedCode in airportCodes
}

/\*\*
ì˜ˆì•½ ë²ˆí˜¸ì˜ ìœ íš¨ì„± ê²€ì¦
/
export function validateBookingReference(bookingRef: string): boolean {
if (!bookingRef) return false

// ì¼ë°˜ì ì¸ ì˜ˆì•½ ë²ˆí˜¸ íŒ¨í„´ (6-8ìë¦¬ ì˜ìˆ«ì)
return /^[A-Z0-9]{6,8}$/.test(bookingRef.toUpperCase())
}

/\*\*
ì»¨í…ìŠ¤íŠ¸ ê¸°ë°˜ ì‹ ë¢°ë„ ì¡°ì •
/
export function adjustConfidenceByContext(
travelInfo: ExtractedTravelInfo,
emailContext: {
senderDomain: string
hasMultipleBookings: boolean
isForwardedEmail: boolean
hasAttachments: boolean
}
): number {
let adjustedConfidence = travelInfo.confidence

// ì‹ ë¢°í•  ìˆ˜ ìˆëŠ” ë°œì‹ ì ë„ë©”ì¸ ë³´ë„ˆìŠ¤
const trustedDomains = [
'koreanair.com', 'flyasiana.com', 'jejuair.net',
'united.com', 'delta.com', 'jal.com',
'booking.com', 'expedia.com', 'agoda.com',
'hotels.com', 'airbnb.com'
]

if (trustedDomains.some(domain => emailContext.senderDomain.includes(domain))) {
adjustedConfidence += 0.15
}

// ì²¨ë¶€íŒŒì¼ì´ ìˆëŠ” ê²½ìš° (e-ticket ë“±)
if (emailContext.hasAttachments) {
adjustedConfidence += 0.1
}

// ì „ë‹¬ëœ ì´ë©”ì¼ì˜ ê²½ìš° ì‹ ë¢°ë„ ê°ì†Œ
if (emailContext.isForwardedEmail) {
adjustedConfidence -= 0.1
}

// ì—¬ëŸ¬ ì˜ˆì•½ì´ í¬í•¨ëœ ê²½ìš° í˜¼ë€ ê°€ëŠ¥ì„±ìœ¼ë¡œ ì‹ ë¢°ë„ ê°ì†Œ
if (emailContext.hasMultipleBookings) {
adjustedConfidence -= 0.05
}

return Math.max(0, Math.min(1, adjustedConfidence))
}

/\*\*
ì¶”ì¶œëœ ë°ì´í„°ì˜ ì¼ê´€ì„± ê²€ì¦
/
export function validateDataConsistency(travelInfo: ExtractedTravelInfo): {
isConsistent: boolean
issues: string[]
} {
const issues: string[] = []

// ë‚ ì§œ ì¼ê´€ì„± ê²€ì¦
if (travelInfo.departureDate && travelInfo.returnDate) {
const depDate = new Date(normalizeDateString(travelInfo.departureDate) || '')
const retDate = new Date(normalizeDateString(travelInfo.returnDate) || '')

    if (depDate >= retDate) {
      issues.push('Return date must be after departure date')
    }

    // ê³¼ê±° ë‚ ì§œ í™•ì¸ (30ì¼ ì´ì „)
    const thirtyDaysAgo = new Date()
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30)

    if (depDate < thirtyDaysAgo) {
      issues.push('Departure date is more than 30 days in the past')
    }

    // ë„ˆë¬´ ë¨¼ ë¯¸ë˜ ë‚ ì§œ í™•ì¸ (2ë…„ ì´í›„)
    const twoYearsLater = new Date()
    twoYearsLater.setFullYear(twoYearsLater.getFullYear() + 2)

    if (depDate > twoYearsLater) {
      issues.push('Departure date is more than 2 years in the future')
    }

}

// í•­ê³µí¸ ë²ˆí˜¸ ê²€ì¦
if (travelInfo.flightNumber && !validateFlightNumber(travelInfo.flightNumber)) {
issues.push(`Invalid flight number: ${travelInfo.flightNumber}`)
}

// ê³µí•­ ì½”ë“œ ê²€ì¦
if (travelInfo.departure && !validateAirportCode(travelInfo.departure)) {
issues.push(`Invalid departure airport code: ${travelInfo.departure}`)
}

if (travelInfo.destination && !validateAirportCode(travelInfo.destination)) {
issues.push(`Invalid destination airport code: ${travelInfo.destination}`)
}

// ê°™ì€ ì¶œë°œì§€ì™€ ëª©ì ì§€ í™•ì¸
if (travelInfo.departure && travelInfo.destination &&
travelInfo.departure === travelInfo.destination) {
issues.push('Departure and destination airports cannot be the same')
}

// ì˜ˆì•½ ë²ˆí˜¸ ê²€ì¦
if (travelInfo.bookingReference && !validateBookingReference(travelInfo.bookingReference)) {
issues.push(`Invalid booking reference format: ${travelInfo.bookingReference}`)
}

return {
isConsistent: issues.length === 0,
issues
}
}

/\*\*
ì—¬í–‰ ì •ë³´ ìš°ì„ ìˆœìœ„ ê²°ì •
ì—¬ëŸ¬ ê°œì˜ ì—¬í–‰ ì •ë³´ê°€ ì¶”ì¶œëœ ê²½ìš° ê°€ì¥ ì‹ ë¢°í•  ìˆ˜ ìˆëŠ” ê²ƒì„ ì„ íƒ
/
export function prioritizeTravelInfo(travelInfos: ExtractedTravelInfo[]): ExtractedTravelInfo[] {
return travelInfos
.map(info => {
// ë°ì´í„° ì¼ê´€ì„± ê²€ì¦
const validation = validateDataConsistency(info)

      // ì¼ê´€ì„±ì´ ì—†ëŠ” ë°ì´í„°ì˜ ì‹ ë¢°ë„ ê°ì†Œ
      if (!validation.isConsistent) {
        info.confidence = Math.max(0, info.confidence - (validation.issues.length * 0.1))
      }

      return info
    })
    .filter(info => info.confidence >= 0.2) // ìµœì†Œ ì‹ ë¢°ë„ í•„í„°ë§
    .sort((a, b) => {
      // 1ì°¨: ì‹ ë¢°ë„ ìˆœ
      if (Math.abs(a.confidence - b.confidence) > 0.1) {
        return b.confidence - a.confidence
      }

      // 2ì°¨: ì¶”ì¶œëœ ë°ì´í„° ì™„ì„±ë„ ìˆœ
      const aCompleteness = getDataCompleteness(a)
      const bCompleteness = getDataCompleteness(b)

      return bCompleteness - aCompleteness
    })

}

/\*\*
ë°ì´í„° ì™„ì„±ë„ ê³„ì‚°

#### `deduplicateAndMergeTravelInfo`

ì´ë©”ì¼ ì§€ëŠ¥í˜• ë¶„ì„ ë¼ì´ë¸ŒëŸ¬ë¦¬
ê³ ê¸‰ íŒ¨í„´ ë§¤ì¹­, ìì—°ì–´ ì²˜ë¦¬, ì»¨í…ìŠ¤íŠ¸ ë¶„ì„ì„ í†µí•œ ì—¬í–‰ ì •ë³´ ì¶”ì¶œ
/

import { ExtractedTravelInfo } from '@/types/gmail'
import { airportCodes, airlineCodes } from '@/data/travel-patterns'

/\*\*
ë‚ ì§œ ë¬¸ìì—´ì„ í‘œì¤€ í˜•ì‹ìœ¼ë¡œ ì •ê·œí™”
/
export function normalizeDateString(dateStr: string): string | null {
if (!dateStr) return null

// ë‹¤ì–‘í•œ ë‚ ì§œ í˜•ì‹ì„ ISO í˜•ì‹ìœ¼ë¡œ ë³€í™˜
const dateFormats = [
// YYYY-MM-DD
/(\d{4})-(\d{1,2})-(\d{1,2})/,
// MM/DD/YYYY
/(\d{1,2})\/(\d{1,2})\/(\d{4})/,
// DD/MM/YYYY
/(\d{1,2})\/(\d{1,2})\/(\d{4})/,
// YYYYë…„ MMì›” DDì¼
/(\d{4})ë…„\s*(\d{1,2})ì›”\s*(\d{1,2})ì¼/,
// MMM DD, YYYY
/(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\w*\s+(\d{1,2}),?\s+(\d{4})/i,
// DD MMM YYYY
/(\d{1,2})\s+(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\w*\s+(\d{4})/i
]

const monthMap: { [key: string]: string } = {
'jan': '01', 'feb': '02', 'mar': '03', 'apr': '04',
'may': '05', 'jun': '06', 'jul': '07', 'aug': '08',
'sep': '09', 'oct': '10', 'nov': '11', 'dec': '12'
}

for (const format of dateFormats) {
const match = dateStr.match(format)
if (match) {
if (format === dateFormats[0]) { // YYYY-MM-DD
return `${match[1]}-${match[2].padStart(2, '0')}-${match[3].padStart(2, '0')}`
} else if (format === dateFormats[1] || format === dateFormats[2]) { // MM/DD/YYYY
return `${match[3]}-${match[1].padStart(2, '0')}-${match[2].padStart(2, '0')}`
} else if (format === dateFormats[3]) { // í•œêµ­ì–´ í˜•ì‹
return `${match[1]}-${match[2].padStart(2, '0')}-${match[3].padStart(2, '0')}`
} else if (format === dateFormats[4]) { // MMM DD, YYYY
const month = monthMap[match[1].toLowerCase().substring(0, 3)]
return `${match[3]}-${month}-${match[2].padStart(2, '0')}`
} else if (format === dateFormats[5]) { // DD MMM YYYY
const month = monthMap[match[2].toLowerCase().substring(0, 3)]
return `${match[3]}-${month}-${match[1].padStart(2, '0')}`
}
}
}

return null
}

/\*\*
í•­ê³µí¸ ë²ˆí˜¸ì˜ ìœ íš¨ì„± ê²€ì¦
/
export function validateFlightNumber(flightNumber: string): boolean {
if (!flightNumber) return false

const normalizedFlight = flightNumber.toUpperCase().replace(/\s+/g, '')
const match = normalizedFlight.match(/^([A-Z]{2,3})(\d{1,4})$/)

if (!match) return false

const [, airlineCode, flightNum] = match

// í•­ê³µì‚¬ ì½”ë“œ ê²€ì¦
if (!(airlineCode in airlineCodes)) return false

// í•­ê³µí¸ ë²ˆí˜¸ ë²”ìœ„ ê²€ì¦ (ì¼ë°˜ì ìœ¼ë¡œ 1-9999)
const num = parseInt(flightNum)
return num >= 1 && num <= 9999
}

/\*\*
ê³µí•­ ì½”ë“œì˜ ìœ íš¨ì„± ê²€ì¦
/
export function validateAirportCode(airportCode: string): boolean {
if (!airportCode) return false

const normalizedCode = airportCode.toUpperCase()
return normalizedCode.length === 3 && /^[A-Z]{3}$/.test(normalizedCode) && normalizedCode in airportCodes
}

/\*\*
ì˜ˆì•½ ë²ˆí˜¸ì˜ ìœ íš¨ì„± ê²€ì¦
/
export function validateBookingReference(bookingRef: string): boolean {
if (!bookingRef) return false

// ì¼ë°˜ì ì¸ ì˜ˆì•½ ë²ˆí˜¸ íŒ¨í„´ (6-8ìë¦¬ ì˜ìˆ«ì)
return /^[A-Z0-9]{6,8}$/.test(bookingRef.toUpperCase())
}

/\*\*
ì»¨í…ìŠ¤íŠ¸ ê¸°ë°˜ ì‹ ë¢°ë„ ì¡°ì •
/
export function adjustConfidenceByContext(
travelInfo: ExtractedTravelInfo,
emailContext: {
senderDomain: string
hasMultipleBookings: boolean
isForwardedEmail: boolean
hasAttachments: boolean
}
): number {
let adjustedConfidence = travelInfo.confidence

// ì‹ ë¢°í•  ìˆ˜ ìˆëŠ” ë°œì‹ ì ë„ë©”ì¸ ë³´ë„ˆìŠ¤
const trustedDomains = [
'koreanair.com', 'flyasiana.com', 'jejuair.net',
'united.com', 'delta.com', 'jal.com',
'booking.com', 'expedia.com', 'agoda.com',
'hotels.com', 'airbnb.com'
]

if (trustedDomains.some(domain => emailContext.senderDomain.includes(domain))) {
adjustedConfidence += 0.15
}

// ì²¨ë¶€íŒŒì¼ì´ ìˆëŠ” ê²½ìš° (e-ticket ë“±)
if (emailContext.hasAttachments) {
adjustedConfidence += 0.1
}

// ì „ë‹¬ëœ ì´ë©”ì¼ì˜ ê²½ìš° ì‹ ë¢°ë„ ê°ì†Œ
if (emailContext.isForwardedEmail) {
adjustedConfidence -= 0.1
}

// ì—¬ëŸ¬ ì˜ˆì•½ì´ í¬í•¨ëœ ê²½ìš° í˜¼ë€ ê°€ëŠ¥ì„±ìœ¼ë¡œ ì‹ ë¢°ë„ ê°ì†Œ
if (emailContext.hasMultipleBookings) {
adjustedConfidence -= 0.05
}

return Math.max(0, Math.min(1, adjustedConfidence))
}

/\*\*
ì¶”ì¶œëœ ë°ì´í„°ì˜ ì¼ê´€ì„± ê²€ì¦
/
export function validateDataConsistency(travelInfo: ExtractedTravelInfo): {
isConsistent: boolean
issues: string[]
} {
const issues: string[] = []

// ë‚ ì§œ ì¼ê´€ì„± ê²€ì¦
if (travelInfo.departureDate && travelInfo.returnDate) {
const depDate = new Date(normalizeDateString(travelInfo.departureDate) || '')
const retDate = new Date(normalizeDateString(travelInfo.returnDate) || '')

    if (depDate >= retDate) {
      issues.push('Return date must be after departure date')
    }

    // ê³¼ê±° ë‚ ì§œ í™•ì¸ (30ì¼ ì´ì „)
    const thirtyDaysAgo = new Date()
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30)

    if (depDate < thirtyDaysAgo) {
      issues.push('Departure date is more than 30 days in the past')
    }

    // ë„ˆë¬´ ë¨¼ ë¯¸ë˜ ë‚ ì§œ í™•ì¸ (2ë…„ ì´í›„)
    const twoYearsLater = new Date()
    twoYearsLater.setFullYear(twoYearsLater.getFullYear() + 2)

    if (depDate > twoYearsLater) {
      issues.push('Departure date is more than 2 years in the future')
    }

}

// í•­ê³µí¸ ë²ˆí˜¸ ê²€ì¦
if (travelInfo.flightNumber && !validateFlightNumber(travelInfo.flightNumber)) {
issues.push(`Invalid flight number: ${travelInfo.flightNumber}`)
}

// ê³µí•­ ì½”ë“œ ê²€ì¦
if (travelInfo.departure && !validateAirportCode(travelInfo.departure)) {
issues.push(`Invalid departure airport code: ${travelInfo.departure}`)
}

if (travelInfo.destination && !validateAirportCode(travelInfo.destination)) {
issues.push(`Invalid destination airport code: ${travelInfo.destination}`)
}

// ê°™ì€ ì¶œë°œì§€ì™€ ëª©ì ì§€ í™•ì¸
if (travelInfo.departure && travelInfo.destination &&
travelInfo.departure === travelInfo.destination) {
issues.push('Departure and destination airports cannot be the same')
}

// ì˜ˆì•½ ë²ˆí˜¸ ê²€ì¦
if (travelInfo.bookingReference && !validateBookingReference(travelInfo.bookingReference)) {
issues.push(`Invalid booking reference format: ${travelInfo.bookingReference}`)
}

return {
isConsistent: issues.length === 0,
issues
}
}

/\*\*
ì—¬í–‰ ì •ë³´ ìš°ì„ ìˆœìœ„ ê²°ì •
ì—¬ëŸ¬ ê°œì˜ ì—¬í–‰ ì •ë³´ê°€ ì¶”ì¶œëœ ê²½ìš° ê°€ì¥ ì‹ ë¢°í•  ìˆ˜ ìˆëŠ” ê²ƒì„ ì„ íƒ
/
export function prioritizeTravelInfo(travelInfos: ExtractedTravelInfo[]): ExtractedTravelInfo[] {
return travelInfos
.map(info => {
// ë°ì´í„° ì¼ê´€ì„± ê²€ì¦
const validation = validateDataConsistency(info)

      // ì¼ê´€ì„±ì´ ì—†ëŠ” ë°ì´í„°ì˜ ì‹ ë¢°ë„ ê°ì†Œ
      if (!validation.isConsistent) {
        info.confidence = Math.max(0, info.confidence - (validation.issues.length * 0.1))
      }

      return info
    })
    .filter(info => info.confidence >= 0.2) // ìµœì†Œ ì‹ ë¢°ë„ í•„í„°ë§
    .sort((a, b) => {
      // 1ì°¨: ì‹ ë¢°ë„ ìˆœ
      if (Math.abs(a.confidence - b.confidence) > 0.1) {
        return b.confidence - a.confidence
      }

      // 2ì°¨: ì¶”ì¶œëœ ë°ì´í„° ì™„ì„±ë„ ìˆœ
      const aCompleteness = getDataCompleteness(a)
      const bCompleteness = getDataCompleteness(b)

      return bCompleteness - aCompleteness
    })

}

/\*\*
ë°ì´í„° ì™„ì„±ë„ ê³„ì‚°
/
function getDataCompleteness(travelInfo: ExtractedTravelInfo): number {
let score = 0
const fields = [
'departureDate', 'returnDate', 'destination', 'departure',
'flightNumber', 'bookingReference', 'hotelName', 'passengerName'
]

for (const field of fields) {
if (travelInfo[field as keyof ExtractedTravelInfo]) {
score += 1
}
}

return score / fields.length
}

/\*\*
ìŠ¤ë§ˆíŠ¸ ì¤‘ë³µ ì œê±°
ê°™ì€ ì—¬í–‰ì— ëŒ€í•œ ì—¬ëŸ¬ ì´ë©”ì¼ì—ì„œ ì¶”ì¶œëœ ì •ë³´ë¥¼ ë³‘í•©

**íŠ¹ì„±:** `exported`

#### `mergeTravelInfos`

ì´ë©”ì¼ ì§€ëŠ¥í˜• ë¶„ì„ ë¼ì´ë¸ŒëŸ¬ë¦¬
ê³ ê¸‰ íŒ¨í„´ ë§¤ì¹­, ìì—°ì–´ ì²˜ë¦¬, ì»¨í…ìŠ¤íŠ¸ ë¶„ì„ì„ í†µí•œ ì—¬í–‰ ì •ë³´ ì¶”ì¶œ
/

import { ExtractedTravelInfo } from '@/types/gmail'
import { airportCodes, airlineCodes } from '@/data/travel-patterns'

/\*\*
ë‚ ì§œ ë¬¸ìì—´ì„ í‘œì¤€ í˜•ì‹ìœ¼ë¡œ ì •ê·œí™”
/
export function normalizeDateString(dateStr: string): string | null {
if (!dateStr) return null

// ë‹¤ì–‘í•œ ë‚ ì§œ í˜•ì‹ì„ ISO í˜•ì‹ìœ¼ë¡œ ë³€í™˜
const dateFormats = [
// YYYY-MM-DD
/(\d{4})-(\d{1,2})-(\d{1,2})/,
// MM/DD/YYYY
/(\d{1,2})\/(\d{1,2})\/(\d{4})/,
// DD/MM/YYYY
/(\d{1,2})\/(\d{1,2})\/(\d{4})/,
// YYYYë…„ MMì›” DDì¼
/(\d{4})ë…„\s*(\d{1,2})ì›”\s*(\d{1,2})ì¼/,
// MMM DD, YYYY
/(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\w*\s+(\d{1,2}),?\s+(\d{4})/i,
// DD MMM YYYY
/(\d{1,2})\s+(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\w*\s+(\d{4})/i
]

const monthMap: { [key: string]: string } = {
'jan': '01', 'feb': '02', 'mar': '03', 'apr': '04',
'may': '05', 'jun': '06', 'jul': '07', 'aug': '08',
'sep': '09', 'oct': '10', 'nov': '11', 'dec': '12'
}

for (const format of dateFormats) {
const match = dateStr.match(format)
if (match) {
if (format === dateFormats[0]) { // YYYY-MM-DD
return `${match[1]}-${match[2].padStart(2, '0')}-${match[3].padStart(2, '0')}`
} else if (format === dateFormats[1] || format === dateFormats[2]) { // MM/DD/YYYY
return `${match[3]}-${match[1].padStart(2, '0')}-${match[2].padStart(2, '0')}`
} else if (format === dateFormats[3]) { // í•œêµ­ì–´ í˜•ì‹
return `${match[1]}-${match[2].padStart(2, '0')}-${match[3].padStart(2, '0')}`
} else if (format === dateFormats[4]) { // MMM DD, YYYY
const month = monthMap[match[1].toLowerCase().substring(0, 3)]
return `${match[3]}-${month}-${match[2].padStart(2, '0')}`
} else if (format === dateFormats[5]) { // DD MMM YYYY
const month = monthMap[match[2].toLowerCase().substring(0, 3)]
return `${match[3]}-${month}-${match[1].padStart(2, '0')}`
}
}
}

return null
}

/\*\*
í•­ê³µí¸ ë²ˆí˜¸ì˜ ìœ íš¨ì„± ê²€ì¦
/
export function validateFlightNumber(flightNumber: string): boolean {
if (!flightNumber) return false

const normalizedFlight = flightNumber.toUpperCase().replace(/\s+/g, '')
const match = normalizedFlight.match(/^([A-Z]{2,3})(\d{1,4})$/)

if (!match) return false

const [, airlineCode, flightNum] = match

// í•­ê³µì‚¬ ì½”ë“œ ê²€ì¦
if (!(airlineCode in airlineCodes)) return false

// í•­ê³µí¸ ë²ˆí˜¸ ë²”ìœ„ ê²€ì¦ (ì¼ë°˜ì ìœ¼ë¡œ 1-9999)
const num = parseInt(flightNum)
return num >= 1 && num <= 9999
}

/\*\*
ê³µí•­ ì½”ë“œì˜ ìœ íš¨ì„± ê²€ì¦
/
export function validateAirportCode(airportCode: string): boolean {
if (!airportCode) return false

const normalizedCode = airportCode.toUpperCase()
return normalizedCode.length === 3 && /^[A-Z]{3}$/.test(normalizedCode) && normalizedCode in airportCodes
}

/\*\*
ì˜ˆì•½ ë²ˆí˜¸ì˜ ìœ íš¨ì„± ê²€ì¦
/
export function validateBookingReference(bookingRef: string): boolean {
if (!bookingRef) return false

// ì¼ë°˜ì ì¸ ì˜ˆì•½ ë²ˆí˜¸ íŒ¨í„´ (6-8ìë¦¬ ì˜ìˆ«ì)
return /^[A-Z0-9]{6,8}$/.test(bookingRef.toUpperCase())
}

/\*\*
ì»¨í…ìŠ¤íŠ¸ ê¸°ë°˜ ì‹ ë¢°ë„ ì¡°ì •
/
export function adjustConfidenceByContext(
travelInfo: ExtractedTravelInfo,
emailContext: {
senderDomain: string
hasMultipleBookings: boolean
isForwardedEmail: boolean
hasAttachments: boolean
}
): number {
let adjustedConfidence = travelInfo.confidence

// ì‹ ë¢°í•  ìˆ˜ ìˆëŠ” ë°œì‹ ì ë„ë©”ì¸ ë³´ë„ˆìŠ¤
const trustedDomains = [
'koreanair.com', 'flyasiana.com', 'jejuair.net',
'united.com', 'delta.com', 'jal.com',
'booking.com', 'expedia.com', 'agoda.com',
'hotels.com', 'airbnb.com'
]

if (trustedDomains.some(domain => emailContext.senderDomain.includes(domain))) {
adjustedConfidence += 0.15
}

// ì²¨ë¶€íŒŒì¼ì´ ìˆëŠ” ê²½ìš° (e-ticket ë“±)
if (emailContext.hasAttachments) {
adjustedConfidence += 0.1
}

// ì „ë‹¬ëœ ì´ë©”ì¼ì˜ ê²½ìš° ì‹ ë¢°ë„ ê°ì†Œ
if (emailContext.isForwardedEmail) {
adjustedConfidence -= 0.1
}

// ì—¬ëŸ¬ ì˜ˆì•½ì´ í¬í•¨ëœ ê²½ìš° í˜¼ë€ ê°€ëŠ¥ì„±ìœ¼ë¡œ ì‹ ë¢°ë„ ê°ì†Œ
if (emailContext.hasMultipleBookings) {
adjustedConfidence -= 0.05
}

return Math.max(0, Math.min(1, adjustedConfidence))
}

/\*\*
ì¶”ì¶œëœ ë°ì´í„°ì˜ ì¼ê´€ì„± ê²€ì¦
/
export function validateDataConsistency(travelInfo: ExtractedTravelInfo): {
isConsistent: boolean
issues: string[]
} {
const issues: string[] = []

// ë‚ ì§œ ì¼ê´€ì„± ê²€ì¦
if (travelInfo.departureDate && travelInfo.returnDate) {
const depDate = new Date(normalizeDateString(travelInfo.departureDate) || '')
const retDate = new Date(normalizeDateString(travelInfo.returnDate) || '')

    if (depDate >= retDate) {
      issues.push('Return date must be after departure date')
    }

    // ê³¼ê±° ë‚ ì§œ í™•ì¸ (30ì¼ ì´ì „)
    const thirtyDaysAgo = new Date()
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30)

    if (depDate < thirtyDaysAgo) {
      issues.push('Departure date is more than 30 days in the past')
    }

    // ë„ˆë¬´ ë¨¼ ë¯¸ë˜ ë‚ ì§œ í™•ì¸ (2ë…„ ì´í›„)
    const twoYearsLater = new Date()
    twoYearsLater.setFullYear(twoYearsLater.getFullYear() + 2)

    if (depDate > twoYearsLater) {
      issues.push('Departure date is more than 2 years in the future')
    }

}

// í•­ê³µí¸ ë²ˆí˜¸ ê²€ì¦
if (travelInfo.flightNumber && !validateFlightNumber(travelInfo.flightNumber)) {
issues.push(`Invalid flight number: ${travelInfo.flightNumber}`)
}

// ê³µí•­ ì½”ë“œ ê²€ì¦
if (travelInfo.departure && !validateAirportCode(travelInfo.departure)) {
issues.push(`Invalid departure airport code: ${travelInfo.departure}`)
}

if (travelInfo.destination && !validateAirportCode(travelInfo.destination)) {
issues.push(`Invalid destination airport code: ${travelInfo.destination}`)
}

// ê°™ì€ ì¶œë°œì§€ì™€ ëª©ì ì§€ í™•ì¸
if (travelInfo.departure && travelInfo.destination &&
travelInfo.departure === travelInfo.destination) {
issues.push('Departure and destination airports cannot be the same')
}

// ì˜ˆì•½ ë²ˆí˜¸ ê²€ì¦
if (travelInfo.bookingReference && !validateBookingReference(travelInfo.bookingReference)) {
issues.push(`Invalid booking reference format: ${travelInfo.bookingReference}`)
}

return {
isConsistent: issues.length === 0,
issues
}
}

/\*\*
ì—¬í–‰ ì •ë³´ ìš°ì„ ìˆœìœ„ ê²°ì •
ì—¬ëŸ¬ ê°œì˜ ì—¬í–‰ ì •ë³´ê°€ ì¶”ì¶œëœ ê²½ìš° ê°€ì¥ ì‹ ë¢°í•  ìˆ˜ ìˆëŠ” ê²ƒì„ ì„ íƒ
/
export function prioritizeTravelInfo(travelInfos: ExtractedTravelInfo[]): ExtractedTravelInfo[] {
return travelInfos
.map(info => {
// ë°ì´í„° ì¼ê´€ì„± ê²€ì¦
const validation = validateDataConsistency(info)

      // ì¼ê´€ì„±ì´ ì—†ëŠ” ë°ì´í„°ì˜ ì‹ ë¢°ë„ ê°ì†Œ
      if (!validation.isConsistent) {
        info.confidence = Math.max(0, info.confidence - (validation.issues.length * 0.1))
      }

      return info
    })
    .filter(info => info.confidence >= 0.2) // ìµœì†Œ ì‹ ë¢°ë„ í•„í„°ë§
    .sort((a, b) => {
      // 1ì°¨: ì‹ ë¢°ë„ ìˆœ
      if (Math.abs(a.confidence - b.confidence) > 0.1) {
        return b.confidence - a.confidence
      }

      // 2ì°¨: ì¶”ì¶œëœ ë°ì´í„° ì™„ì„±ë„ ìˆœ
      const aCompleteness = getDataCompleteness(a)
      const bCompleteness = getDataCompleteness(b)

      return bCompleteness - aCompleteness
    })

}

/\*\*
ë°ì´í„° ì™„ì„±ë„ ê³„ì‚°
/
function getDataCompleteness(travelInfo: ExtractedTravelInfo): number {
let score = 0
const fields = [
'departureDate', 'returnDate', 'destination', 'departure',
'flightNumber', 'bookingReference', 'hotelName', 'passengerName'
]

for (const field of fields) {
if (travelInfo[field as keyof ExtractedTravelInfo]) {
score += 1
}
}

return score / fields.length
}

/\*\*
ìŠ¤ë§ˆíŠ¸ ì¤‘ë³µ ì œê±°
ê°™ì€ ì—¬í–‰ì— ëŒ€í•œ ì—¬ëŸ¬ ì´ë©”ì¼ì—ì„œ ì¶”ì¶œëœ ì •ë³´ë¥¼ ë³‘í•©
/
export function deduplicateAndMergeTravelInfo(travelInfos: ExtractedTravelInfo[]): ExtractedTravelInfo[] {
const merged: ExtractedTravelInfo[] = []

for (const current of travelInfos) {
let foundDuplicate = false

    for (let i = 0; i < merged.length; i++) {
      const existing = merged[i]

      // ì¤‘ë³µ íŒì • ê¸°ì¤€: ê°™ì€ í•­ê³µí¸ ë²ˆí˜¸ ë˜ëŠ” ê°™ì€ ì˜ˆì•½ ë²ˆí˜¸ ë˜ëŠ” ê°™ì€ ë‚ ì§œ+ê³µí•­ ì¡°í•©
      const isSameTrip =
        (current.flightNumber && existing.flightNumber && current.flightNumber === existing.flightNumber) ||
        (current.bookingReference && existing.bookingReference && current.bookingReference === existing.bookingReference) ||
        (current.departureDate && existing.departureDate && current.departure && existing.departure &&
         normalizeDateString(current.departureDate) === normalizeDateString(existing.departureDate) &&
         current.departure === existing.departure)

      if (isSameTrip) {
        // ë” ì‹ ë¢°ë„ê°€ ë†’ì€ ì •ë³´ë¡œ ë³‘í•©
        merged[i] = mergeTravelInfos(existing, current)
        foundDuplicate = true
        break
      }
    }

    if (!foundDuplicate) {
      merged.push(current)
    }

}

return merged
}

/\*\*
ë‘ ì—¬í–‰ ì •ë³´ë¥¼ ë³‘í•©

## error-handler.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/error/error-handler.ts`

**ì„¤ëª…:** Centralized Error Handling System
Provides consistent error handling across the application

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 6798 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 256
- ğŸ”§ í•¨ìˆ˜: 4ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 2ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 1ê°œ

**Exports:**

- `enum`
- `AppError`
- `createErrorResponse`
- `errors`
- `handleError`
- `asyncHandler`
- `handleClientError`

### ğŸ”§ Functions

#### `createErrorResponse`

**íŠ¹ì„±:** `exported`

#### `logError`

#### `handleError`

**íŠ¹ì„±:** `exported`

#### `handleClientError`

**íŠ¹ì„±:** `exported`

### ğŸ“¦ Classes

#### `export`

**íŠ¹ì„±:** `exported`

#### `AppError`

### ğŸ”— Interfaces

#### `interface`

## error-logger.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/error/error-logger.ts`

**ì„¤ëª…:** Error Logging and Monitoring System
Centralizes error logging with different severity levels and monitoring integration

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 6063 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 229
- ğŸ”§ í•¨ìˆ˜: 6ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 1ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 2ê°œ

**Exports:**

- `ErrorLogEntry`
- `ErrorLogger`
- `getErrorLogger`
- `logError`
- `logWarn`
- `logInfo`
- `trackErrorRate`
- `getErrorTrends`

### ğŸ”§ Functions

#### `getErrorLogger`

**íŠ¹ì„±:** `exported`

#### `logError`

**íŠ¹ì„±:** `exported`

#### `logWarn`

**íŠ¹ì„±:** `exported`

#### `logInfo`

**íŠ¹ì„±:** `exported`

#### `trackErrorRate`

**íŠ¹ì„±:** `exported`

#### `getErrorTrends`

**íŠ¹ì„±:** `exported`

### ğŸ“¦ Classes

#### `ConsoleErrorLogger`

### ğŸ”— Interfaces

#### `ErrorLogEntry`

**íŠ¹ì„±:** `exported`

#### `ErrorLogger`

**íŠ¹ì„±:** `exported`

## gmail-analytics.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/gmail-analytics.ts`

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 12270 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 437
- ğŸ”§ í•¨ìˆ˜: 4ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 2ê°œ

**Exports:**

- `TravelStats`
- `TravelInsight`
- `generateTravelStats`
- `generateTravelInsights`
- `generateTravelCalendar`
- `estimateTravelCosts`

### ğŸ”§ Functions

#### `generateTravelStats`

ì—¬í–‰ í†µê³„ ìƒì„±

**íŠ¹ì„±:** `exported`

#### `generateTravelInsights`

ì—¬í–‰ í†µê³„ ìƒì„±
/
export function generateTravelStats(travelInfos: TravelInfo[]): TravelStats {
const now = new Date()
const oneMonthFromNow = new Date(now)
oneMonthFromNow.setMonth(now.getMonth() + 1)

const sixMonthsAgo = new Date(now)
sixMonthsAgo.setMonth(now.getMonth() - 6)

const totalTrips = travelInfos.length
const destinations = new Map<string, number>()
const airlines = new Map<string, number>()
const upcomingTrips: TravelInfo[] = []
const recentTrips: TravelInfo[] = []
const monthlyTrips = new Map<string, number>()

for (const trip of travelInfos) {
// ëª©ì ì§€ ì¹´ìš´íŠ¸
if (trip.destination) {
destinations.set(trip.destination, (destinations.get(trip.destination) || 0) + 1)
}

    // í•­ê³µì‚¬ ì¹´ìš´íŠ¸
    if (trip.flightNumber) {
      const airlineCode = trip.flightNumber.substring(0, 2)
      airlines.set(airlineCode, (airlines.get(airlineCode) || 0) + 1)
    }

    if (trip.departureDate) {
      try {
        const departureDate = new Date(trip.departureDate)

        // ì˜ˆì •ëœ ì—¬í–‰
        if (departureDate > now && departureDate <= oneMonthFromNow) {
          upcomingTrips.push(trip)
        }

        // ìµœê·¼ ì—¬í–‰
        if (departureDate >= sixMonthsAgo && departureDate <= now) {
          recentTrips.push(trip)
        }

        // ì›”ë³„ í†µê³„
        const monthKey = `${departureDate.getFullYear()}-${(departureDate.getMonth() + 1).toString().padStart(2, '0')}`
        monthlyTrips.set(monthKey, (monthlyTrips.get(monthKey) || 0) + 1)

      } catch (error) {
        // Invalid date format
      }
    }

}

// ìƒìœ„ ëª©ì ì§€
const mostVisitedDestinations = Array.from(destinations.entries())
.map(([code, count]) => ({
code,
name: airportCodes[code as keyof typeof airportCodes] || code,
count
}))
.sort((a, b) => b.count - a.count)
.slice(0, 5)

// ì„ í˜¸ í•­ê³µì‚¬
const preferredAirlines = Array.from(airlines.entries())
.map(([code, count]) => ({
code,
name: airlineCodes[code as keyof typeof airlineCodes] || code,
count
}))
.sort((a, b) => b.count - a.count)
.slice(0, 5)

// ì—¬í–‰ ë¹ˆë„
const domesticAirports = ['ICN', 'GMP', 'CJU', 'PUS', 'TAE'] // í•œêµ­ ì£¼ìš” ê³µí•­
const domesticTrips = travelInfos.filter(trip =>
trip.destination && domesticAirports.includes(trip.destination)
).length
const internationalTrips = totalTrips - domesticTrips

const averageTripsPerMonth = monthlyTrips.size > 0 ?
Array.from(monthlyTrips.values()).reduce((sum, count) => sum + count, 0) / monthlyTrips.size : 0

// ì—¬í–‰ íŒ¨í„´ ë¶„ì„
const monthCounts = new Map<number, number>()
for (const trip of travelInfos) {
if (trip.departureDate) {
try {
const date = new Date(trip.departureDate)
const month = date.getMonth()
monthCounts.set(month, (monthCounts.get(month) || 0) + 1)
} catch (error) {
// ì˜ëª»ëœ ë‚ ì§œ í˜•ì‹ ë¬´ì‹œ
}
}
}

const monthNames = [
'1ì›”', '2ì›”', '3ì›”', '4ì›”', '5ì›”', '6ì›”',
'7ì›”', '8ì›”', '9ì›”', '10ì›”', '11ì›”', '12ì›”'
]

const sortedMonths = Array.from(monthCounts.entries())
.sort((a, b) => b[1] - a[1])

const busyMonths = sortedMonths.slice(0, 3).map(([month]) => monthNames[month])
const quietMonths = sortedMonths.slice(-3).map(([month]) => monthNames[month])

// í‰ê·  ì—¬í–‰ ê¸°ê°„ ê³„ì‚° (ì™•ë³µ ì—¬í–‰ ê¸°ì¤€)
let totalDuration = 0
let tripWithDuration = 0

for (const trip of travelInfos) {
if (trip.departureDate && trip.returnDate) {
try {
const depDate = new Date(trip.departureDate)
const retDate = new Date(trip.returnDate)
const duration = (retDate.getTime() - depDate.getTime()) / (1000 _ 60 _ 60 \* 24)

        if (duration > 0 && duration < 365) { // ìœ íš¨í•œ ê¸°ê°„ë§Œ
          totalDuration += duration
          tripWithDuration++
        }
      } catch (error) {
        // ì˜ëª»ëœ ë‚ ì§œ í˜•ì‹ ë¬´ì‹œ
      }
    }

}

const averageTripDuration = tripWithDuration > 0 ? Math.round(totalDuration / tripWithDuration) : 0

return {
totalTrips,
totalAirlines: airlines.size,
totalDestinations: destinations.size,
mostVisitedDestinations,
preferredAirlines,
travelFrequency: {
domestic: domesticTrips,
international: internationalTrips,
averageTripsPerMonth: Math.round(averageTripsPerMonth \* 10) / 10
},
upcomingTrips: upcomingTrips.sort((a, b) =>
new Date(a.departureDate || '').getTime() - new Date(b.departureDate || '').getTime()
),
recentTrips: recentTrips.sort((a, b) =>
new Date(b.departureDate || '').getTime() - new Date(a.departureDate || '').getTime()
).slice(0, 5),
travelPattern: {
busyMonths,
quietMonths,
averageTripDuration
}
}
}

/\*\*
ê°œì¸í™”ëœ ì—¬í–‰ ì¸ì‚¬ì´íŠ¸ ìƒì„±

**íŠ¹ì„±:** `exported`

#### `generateTravelCalendar`

ì—¬í–‰ í†µê³„ ìƒì„±
/
export function generateTravelStats(travelInfos: TravelInfo[]): TravelStats {
const now = new Date()
const oneMonthFromNow = new Date(now)
oneMonthFromNow.setMonth(now.getMonth() + 1)

const sixMonthsAgo = new Date(now)
sixMonthsAgo.setMonth(now.getMonth() - 6)

const totalTrips = travelInfos.length
const destinations = new Map<string, number>()
const airlines = new Map<string, number>()
const upcomingTrips: TravelInfo[] = []
const recentTrips: TravelInfo[] = []
const monthlyTrips = new Map<string, number>()

for (const trip of travelInfos) {
// ëª©ì ì§€ ì¹´ìš´íŠ¸
if (trip.destination) {
destinations.set(trip.destination, (destinations.get(trip.destination) || 0) + 1)
}

    // í•­ê³µì‚¬ ì¹´ìš´íŠ¸
    if (trip.flightNumber) {
      const airlineCode = trip.flightNumber.substring(0, 2)
      airlines.set(airlineCode, (airlines.get(airlineCode) || 0) + 1)
    }

    if (trip.departureDate) {
      try {
        const departureDate = new Date(trip.departureDate)

        // ì˜ˆì •ëœ ì—¬í–‰
        if (departureDate > now && departureDate <= oneMonthFromNow) {
          upcomingTrips.push(trip)
        }

        // ìµœê·¼ ì—¬í–‰
        if (departureDate >= sixMonthsAgo && departureDate <= now) {
          recentTrips.push(trip)
        }

        // ì›”ë³„ í†µê³„
        const monthKey = `${departureDate.getFullYear()}-${(departureDate.getMonth() + 1).toString().padStart(2, '0')}`
        monthlyTrips.set(monthKey, (monthlyTrips.get(monthKey) || 0) + 1)

      } catch (error) {
        // Invalid date format
      }
    }

}

// ìƒìœ„ ëª©ì ì§€
const mostVisitedDestinations = Array.from(destinations.entries())
.map(([code, count]) => ({
code,
name: airportCodes[code as keyof typeof airportCodes] || code,
count
}))
.sort((a, b) => b.count - a.count)
.slice(0, 5)

// ì„ í˜¸ í•­ê³µì‚¬
const preferredAirlines = Array.from(airlines.entries())
.map(([code, count]) => ({
code,
name: airlineCodes[code as keyof typeof airlineCodes] || code,
count
}))
.sort((a, b) => b.count - a.count)
.slice(0, 5)

// ì—¬í–‰ ë¹ˆë„
const domesticAirports = ['ICN', 'GMP', 'CJU', 'PUS', 'TAE'] // í•œêµ­ ì£¼ìš” ê³µí•­
const domesticTrips = travelInfos.filter(trip =>
trip.destination && domesticAirports.includes(trip.destination)
).length
const internationalTrips = totalTrips - domesticTrips

const averageTripsPerMonth = monthlyTrips.size > 0 ?
Array.from(monthlyTrips.values()).reduce((sum, count) => sum + count, 0) / monthlyTrips.size : 0

// ì—¬í–‰ íŒ¨í„´ ë¶„ì„
const monthCounts = new Map<number, number>()
for (const trip of travelInfos) {
if (trip.departureDate) {
try {
const date = new Date(trip.departureDate)
const month = date.getMonth()
monthCounts.set(month, (monthCounts.get(month) || 0) + 1)
} catch (error) {
// ì˜ëª»ëœ ë‚ ì§œ í˜•ì‹ ë¬´ì‹œ
}
}
}

const monthNames = [
'1ì›”', '2ì›”', '3ì›”', '4ì›”', '5ì›”', '6ì›”',
'7ì›”', '8ì›”', '9ì›”', '10ì›”', '11ì›”', '12ì›”'
]

const sortedMonths = Array.from(monthCounts.entries())
.sort((a, b) => b[1] - a[1])

const busyMonths = sortedMonths.slice(0, 3).map(([month]) => monthNames[month])
const quietMonths = sortedMonths.slice(-3).map(([month]) => monthNames[month])

// í‰ê·  ì—¬í–‰ ê¸°ê°„ ê³„ì‚° (ì™•ë³µ ì—¬í–‰ ê¸°ì¤€)
let totalDuration = 0
let tripWithDuration = 0

for (const trip of travelInfos) {
if (trip.departureDate && trip.returnDate) {
try {
const depDate = new Date(trip.departureDate)
const retDate = new Date(trip.returnDate)
const duration = (retDate.getTime() - depDate.getTime()) / (1000 _ 60 _ 60 \* 24)

        if (duration > 0 && duration < 365) { // ìœ íš¨í•œ ê¸°ê°„ë§Œ
          totalDuration += duration
          tripWithDuration++
        }
      } catch (error) {
        // ì˜ëª»ëœ ë‚ ì§œ í˜•ì‹ ë¬´ì‹œ
      }
    }

}

const averageTripDuration = tripWithDuration > 0 ? Math.round(totalDuration / tripWithDuration) : 0

return {
totalTrips,
totalAirlines: airlines.size,
totalDestinations: destinations.size,
mostVisitedDestinations,
preferredAirlines,
travelFrequency: {
domestic: domesticTrips,
international: internationalTrips,
averageTripsPerMonth: Math.round(averageTripsPerMonth \* 10) / 10
},
upcomingTrips: upcomingTrips.sort((a, b) =>
new Date(a.departureDate || '').getTime() - new Date(b.departureDate || '').getTime()
),
recentTrips: recentTrips.sort((a, b) =>
new Date(b.departureDate || '').getTime() - new Date(a.departureDate || '').getTime()
).slice(0, 5),
travelPattern: {
busyMonths,
quietMonths,
averageTripDuration
}
}
}

/\*\*
ê°œì¸í™”ëœ ì—¬í–‰ ì¸ì‚¬ì´íŠ¸ ìƒì„±
/
export function generateTravelInsights(stats: TravelStats, travelInfos: TravelInfo[]): TravelInsight[] {
const insights: TravelInsight[] = []
const now = new Date()

// ì˜ˆì •ëœ ì—¬í–‰ ì•Œë¦¼
if (stats.upcomingTrips.length > 0) {
const nextTrip = stats.upcomingTrips[0]
const daysUntilTrip = Math.ceil(
(new Date(nextTrip.departureDate || '').getTime() - now.getTime()) / (1000 _ 60 _ 60 \* 24)
)

    insights.push({
      type: 'info',
      title: 'ë‹¤ê°€ì˜¤ëŠ” ì—¬í–‰',
      description: `${daysUntilTrip}ì¼ í›„ ${nextTrip.destination ? airportCodes[nextTrip.destination as keyof typeof airportCodes] || nextTrip.destination : 'ëª©ì ì§€'}ë¡œ ì¶œë°œ ì˜ˆì •ì…ë‹ˆë‹¤.`,
      actionable: true,
      action: 'ì²´í¬ì¸ ì¤€ë¹„í•˜ê¸°'
    })

}

// ì—¬í–‰ ë¹ˆë„ ë¶„ì„
if (stats.travelFrequency.averageTripsPerMonth > 2) {
insights.push({
type: 'achievement',
title: 'ì—¬í–‰ ì• í˜¸ê°€',
description: `ì›”í‰ê·  ${stats.travelFrequency.averageTripsPerMonth}íšŒ ì—¬í–‰ì„ ë‹¤ë‹ˆì‹œëŠ” í™œë°œí•œ ì—¬í–‰ìì…ë‹ˆë‹¤!`
})
}

// ì„ í˜¸ í•­ê³µì‚¬ ë¶„ì„
if (stats.preferredAirlines.length > 0) {
const topAirline = stats.preferredAirlines[0]
if (topAirline.count >= 3) {
insights.push({
type: 'tip',
title: 'ë§ˆì¼ë¦¬ì§€ ìµœì í™”',
description: `${topAirline.name}ì„(ë¥¼) ìì£¼ ì´ìš©í•˜ì‹œë„¤ìš”. ë§ˆì¼ë¦¬ì§€ í”„ë¡œê·¸ë¨ì„ í™•ì¸í•´ë³´ì„¸ìš”.`,
actionable: true,
action: 'ë§ˆì¼ë¦¬ì§€ ì¡°íšŒí•˜ê¸°'
})
}
}

// ëª©ì ì§€ ë‹¤ì–‘ì„± ë¶„ì„
if (stats.totalDestinations >= 10) {
insights.push({
type: 'achievement',
title: 'ì„¸ê³„ ì—¬í–‰ê°€',
description: `${stats.totalDestinations}ê°œ ë„ì‹œë¥¼ ë°©ë¬¸í•˜ì…¨ìŠµë‹ˆë‹¤. ì •ë§ ë‹¤ì–‘í•œ ê²½í—˜ì„ ìŒ“ê³  ê³„ì‹œë„¤ìš”!`
})
}

// ê³„ì ˆë³„ ì—¬í–‰ íŒ¨í„´
if (stats.travelPattern.busyMonths.length > 0) {
insights.push({
type: 'info',
title: 'ì—¬í–‰ íŒ¨í„´ ë¶„ì„',
description: `${stats.travelPattern.busyMonths.join(', ')}ì— ì£¼ë¡œ ì—¬í–‰ì„ ë‹¤ë‹ˆì‹œëŠ” ê²½í–¥ì´ ìˆìŠµë‹ˆë‹¤.`
})
}

// í‰ê·  ì—¬í–‰ ê¸°ê°„ ë¶„ì„
if (stats.travelPattern.averageTripDuration > 0) {
let tripTypeDescription = ''
if (stats.travelPattern.averageTripDuration <= 3) {
tripTypeDescription = 'ì£¼ë¡œ ë‹¨ê¸° ì—¬í–‰ì„ ì„ í˜¸í•˜ì‹œë„¤ìš”.'
} else if (stats.travelPattern.averageTripDuration <= 7) {
tripTypeDescription = 'ì¼ì£¼ì¼ ë‚´ì™¸ì˜ ì ë‹¹í•œ ê¸¸ì´ ì—¬í–‰ì„ ì¦ê¸°ì‹œë„¤ìš”.'
} else {
tripTypeDescription = 'ì¥ê¸° ì—¬í–‰ì„ ì¦ê¸°ëŠ” ì—¬ìœ ë¡œìš´ ì—¬í–‰ìì‹œë„¤ìš”.'
}

    insights.push({
      type: 'info',
      title: 'ì—¬í–‰ ìŠ¤íƒ€ì¼',
      description: `í‰ê·  ${stats.travelPattern.averageTripDuration}ì¼ê°„ ì—¬í–‰í•˜ì‹œë©°, ${tripTypeDescription}`
    })

}

// êµ­ë‚´/í•´ì™¸ ì—¬í–‰ ë¹„ìœ¨
const totalTrips = stats.travelFrequency.domestic + stats.travelFrequency.international
if (totalTrips > 0) {
const internationalRatio = Math.round((stats.travelFrequency.international / totalTrips) \* 100)

    if (internationalRatio >= 70) {
      insights.push({
        type: 'tip',
        title: 'í•´ì™¸ì—¬í–‰ ì „ë¬¸ê°€',
        description: `í•´ì™¸ì—¬í–‰ ë¹„ìœ¨ì´ ${internationalRatio}%ì…ë‹ˆë‹¤. ì—¬í–‰ì ë³´í—˜ê³¼ ë¹„ì ê´€ë¦¬ì— ì‹ ê²½ì“°ì„¸ìš”.`,
        actionable: true,
        action: 'ë¹„ì í˜„í™© í™•ì¸í•˜ê¸°'
      })
    } else if (internationalRatio <= 30) {
      insights.push({
        type: 'tip',
        title: 'êµ­ë‚´ì—¬í–‰ ë§ˆë‹ˆì•„',
        description: `êµ­ë‚´ì—¬í–‰ì„ ë§ì´ ë‹¤ë‹ˆì‹œë„¤ìš”. ìˆ¨ê²¨ì§„ êµ­ë‚´ ëª…ì†Œë¥¼ ë” íƒí—˜í•´ë³´ì„¸ìš”!`
      })
    }

}

// ë°ì´í„° í’ˆì§ˆ ê²½ê³ 
const lowConfidenceTrips = travelInfos.filter(trip => trip.confidence < 0.5).length
if (lowConfidenceTrips > 0) {
insights.push({
type: 'warning',
title: 'ë°ì´í„° ì •í™•ì„±',
description: `${lowConfidenceTrips}ê°œì˜ ì—¬í–‰ ì •ë³´ê°€ ë¶ˆì™„ì „í•©ë‹ˆë‹¤. ìˆ˜ë™ìœ¼ë¡œ í™•ì¸í•´ë³´ì„¸ìš”.`,
actionable: true,
action: 'ë°ì´í„° ê²€í† í•˜ê¸°'
})
}

return insights
}

/\*\*
ì—¬í–‰ ë‹¬ë ¥ ë°ì´í„° ìƒì„± (ì›”ë³„ ë·°)

**íŠ¹ì„±:** `exported`

#### `estimateTravelCosts`

ì—¬í–‰ í†µê³„ ìƒì„±
/
export function generateTravelStats(travelInfos: TravelInfo[]): TravelStats {
const now = new Date()
const oneMonthFromNow = new Date(now)
oneMonthFromNow.setMonth(now.getMonth() + 1)

const sixMonthsAgo = new Date(now)
sixMonthsAgo.setMonth(now.getMonth() - 6)

const totalTrips = travelInfos.length
const destinations = new Map<string, number>()
const airlines = new Map<string, number>()
const upcomingTrips: TravelInfo[] = []
const recentTrips: TravelInfo[] = []
const monthlyTrips = new Map<string, number>()

for (const trip of travelInfos) {
// ëª©ì ì§€ ì¹´ìš´íŠ¸
if (trip.destination) {
destinations.set(trip.destination, (destinations.get(trip.destination) || 0) + 1)
}

    // í•­ê³µì‚¬ ì¹´ìš´íŠ¸
    if (trip.flightNumber) {
      const airlineCode = trip.flightNumber.substring(0, 2)
      airlines.set(airlineCode, (airlines.get(airlineCode) || 0) + 1)
    }

    if (trip.departureDate) {
      try {
        const departureDate = new Date(trip.departureDate)

        // ì˜ˆì •ëœ ì—¬í–‰
        if (departureDate > now && departureDate <= oneMonthFromNow) {
          upcomingTrips.push(trip)
        }

        // ìµœê·¼ ì—¬í–‰
        if (departureDate >= sixMonthsAgo && departureDate <= now) {
          recentTrips.push(trip)
        }

        // ì›”ë³„ í†µê³„
        const monthKey = `${departureDate.getFullYear()}-${(departureDate.getMonth() + 1).toString().padStart(2, '0')}`
        monthlyTrips.set(monthKey, (monthlyTrips.get(monthKey) || 0) + 1)

      } catch (error) {
        // Invalid date format
      }
    }

}

// ìƒìœ„ ëª©ì ì§€
const mostVisitedDestinations = Array.from(destinations.entries())
.map(([code, count]) => ({
code,
name: airportCodes[code as keyof typeof airportCodes] || code,
count
}))
.sort((a, b) => b.count - a.count)
.slice(0, 5)

// ì„ í˜¸ í•­ê³µì‚¬
const preferredAirlines = Array.from(airlines.entries())
.map(([code, count]) => ({
code,
name: airlineCodes[code as keyof typeof airlineCodes] || code,
count
}))
.sort((a, b) => b.count - a.count)
.slice(0, 5)

// ì—¬í–‰ ë¹ˆë„
const domesticAirports = ['ICN', 'GMP', 'CJU', 'PUS', 'TAE'] // í•œêµ­ ì£¼ìš” ê³µí•­
const domesticTrips = travelInfos.filter(trip =>
trip.destination && domesticAirports.includes(trip.destination)
).length
const internationalTrips = totalTrips - domesticTrips

const averageTripsPerMonth = monthlyTrips.size > 0 ?
Array.from(monthlyTrips.values()).reduce((sum, count) => sum + count, 0) / monthlyTrips.size : 0

// ì—¬í–‰ íŒ¨í„´ ë¶„ì„
const monthCounts = new Map<number, number>()
for (const trip of travelInfos) {
if (trip.departureDate) {
try {
const date = new Date(trip.departureDate)
const month = date.getMonth()
monthCounts.set(month, (monthCounts.get(month) || 0) + 1)
} catch (error) {
// ì˜ëª»ëœ ë‚ ì§œ í˜•ì‹ ë¬´ì‹œ
}
}
}

const monthNames = [
'1ì›”', '2ì›”', '3ì›”', '4ì›”', '5ì›”', '6ì›”',
'7ì›”', '8ì›”', '9ì›”', '10ì›”', '11ì›”', '12ì›”'
]

const sortedMonths = Array.from(monthCounts.entries())
.sort((a, b) => b[1] - a[1])

const busyMonths = sortedMonths.slice(0, 3).map(([month]) => monthNames[month])
const quietMonths = sortedMonths.slice(-3).map(([month]) => monthNames[month])

// í‰ê·  ì—¬í–‰ ê¸°ê°„ ê³„ì‚° (ì™•ë³µ ì—¬í–‰ ê¸°ì¤€)
let totalDuration = 0
let tripWithDuration = 0

for (const trip of travelInfos) {
if (trip.departureDate && trip.returnDate) {
try {
const depDate = new Date(trip.departureDate)
const retDate = new Date(trip.returnDate)
const duration = (retDate.getTime() - depDate.getTime()) / (1000 _ 60 _ 60 \* 24)

        if (duration > 0 && duration < 365) { // ìœ íš¨í•œ ê¸°ê°„ë§Œ
          totalDuration += duration
          tripWithDuration++
        }
      } catch (error) {
        // ì˜ëª»ëœ ë‚ ì§œ í˜•ì‹ ë¬´ì‹œ
      }
    }

}

const averageTripDuration = tripWithDuration > 0 ? Math.round(totalDuration / tripWithDuration) : 0

return {
totalTrips,
totalAirlines: airlines.size,
totalDestinations: destinations.size,
mostVisitedDestinations,
preferredAirlines,
travelFrequency: {
domestic: domesticTrips,
international: internationalTrips,
averageTripsPerMonth: Math.round(averageTripsPerMonth \* 10) / 10
},
upcomingTrips: upcomingTrips.sort((a, b) =>
new Date(a.departureDate || '').getTime() - new Date(b.departureDate || '').getTime()
),
recentTrips: recentTrips.sort((a, b) =>
new Date(b.departureDate || '').getTime() - new Date(a.departureDate || '').getTime()
).slice(0, 5),
travelPattern: {
busyMonths,
quietMonths,
averageTripDuration
}
}
}

/\*\*
ê°œì¸í™”ëœ ì—¬í–‰ ì¸ì‚¬ì´íŠ¸ ìƒì„±
/
export function generateTravelInsights(stats: TravelStats, travelInfos: TravelInfo[]): TravelInsight[] {
const insights: TravelInsight[] = []
const now = new Date()

// ì˜ˆì •ëœ ì—¬í–‰ ì•Œë¦¼
if (stats.upcomingTrips.length > 0) {
const nextTrip = stats.upcomingTrips[0]
const daysUntilTrip = Math.ceil(
(new Date(nextTrip.departureDate || '').getTime() - now.getTime()) / (1000 _ 60 _ 60 \* 24)
)

    insights.push({
      type: 'info',
      title: 'ë‹¤ê°€ì˜¤ëŠ” ì—¬í–‰',
      description: `${daysUntilTrip}ì¼ í›„ ${nextTrip.destination ? airportCodes[nextTrip.destination as keyof typeof airportCodes] || nextTrip.destination : 'ëª©ì ì§€'}ë¡œ ì¶œë°œ ì˜ˆì •ì…ë‹ˆë‹¤.`,
      actionable: true,
      action: 'ì²´í¬ì¸ ì¤€ë¹„í•˜ê¸°'
    })

}

// ì—¬í–‰ ë¹ˆë„ ë¶„ì„
if (stats.travelFrequency.averageTripsPerMonth > 2) {
insights.push({
type: 'achievement',
title: 'ì—¬í–‰ ì• í˜¸ê°€',
description: `ì›”í‰ê·  ${stats.travelFrequency.averageTripsPerMonth}íšŒ ì—¬í–‰ì„ ë‹¤ë‹ˆì‹œëŠ” í™œë°œí•œ ì—¬í–‰ìì…ë‹ˆë‹¤!`
})
}

// ì„ í˜¸ í•­ê³µì‚¬ ë¶„ì„
if (stats.preferredAirlines.length > 0) {
const topAirline = stats.preferredAirlines[0]
if (topAirline.count >= 3) {
insights.push({
type: 'tip',
title: 'ë§ˆì¼ë¦¬ì§€ ìµœì í™”',
description: `${topAirline.name}ì„(ë¥¼) ìì£¼ ì´ìš©í•˜ì‹œë„¤ìš”. ë§ˆì¼ë¦¬ì§€ í”„ë¡œê·¸ë¨ì„ í™•ì¸í•´ë³´ì„¸ìš”.`,
actionable: true,
action: 'ë§ˆì¼ë¦¬ì§€ ì¡°íšŒí•˜ê¸°'
})
}
}

// ëª©ì ì§€ ë‹¤ì–‘ì„± ë¶„ì„
if (stats.totalDestinations >= 10) {
insights.push({
type: 'achievement',
title: 'ì„¸ê³„ ì—¬í–‰ê°€',
description: `${stats.totalDestinations}ê°œ ë„ì‹œë¥¼ ë°©ë¬¸í•˜ì…¨ìŠµë‹ˆë‹¤. ì •ë§ ë‹¤ì–‘í•œ ê²½í—˜ì„ ìŒ“ê³  ê³„ì‹œë„¤ìš”!`
})
}

// ê³„ì ˆë³„ ì—¬í–‰ íŒ¨í„´
if (stats.travelPattern.busyMonths.length > 0) {
insights.push({
type: 'info',
title: 'ì—¬í–‰ íŒ¨í„´ ë¶„ì„',
description: `${stats.travelPattern.busyMonths.join(', ')}ì— ì£¼ë¡œ ì—¬í–‰ì„ ë‹¤ë‹ˆì‹œëŠ” ê²½í–¥ì´ ìˆìŠµë‹ˆë‹¤.`
})
}

// í‰ê·  ì—¬í–‰ ê¸°ê°„ ë¶„ì„
if (stats.travelPattern.averageTripDuration > 0) {
let tripTypeDescription = ''
if (stats.travelPattern.averageTripDuration <= 3) {
tripTypeDescription = 'ì£¼ë¡œ ë‹¨ê¸° ì—¬í–‰ì„ ì„ í˜¸í•˜ì‹œë„¤ìš”.'
} else if (stats.travelPattern.averageTripDuration <= 7) {
tripTypeDescription = 'ì¼ì£¼ì¼ ë‚´ì™¸ì˜ ì ë‹¹í•œ ê¸¸ì´ ì—¬í–‰ì„ ì¦ê¸°ì‹œë„¤ìš”.'
} else {
tripTypeDescription = 'ì¥ê¸° ì—¬í–‰ì„ ì¦ê¸°ëŠ” ì—¬ìœ ë¡œìš´ ì—¬í–‰ìì‹œë„¤ìš”.'
}

    insights.push({
      type: 'info',
      title: 'ì—¬í–‰ ìŠ¤íƒ€ì¼',
      description: `í‰ê·  ${stats.travelPattern.averageTripDuration}ì¼ê°„ ì—¬í–‰í•˜ì‹œë©°, ${tripTypeDescription}`
    })

}

// êµ­ë‚´/í•´ì™¸ ì—¬í–‰ ë¹„ìœ¨
const totalTrips = stats.travelFrequency.domestic + stats.travelFrequency.international
if (totalTrips > 0) {
const internationalRatio = Math.round((stats.travelFrequency.international / totalTrips) \* 100)

    if (internationalRatio >= 70) {
      insights.push({
        type: 'tip',
        title: 'í•´ì™¸ì—¬í–‰ ì „ë¬¸ê°€',
        description: `í•´ì™¸ì—¬í–‰ ë¹„ìœ¨ì´ ${internationalRatio}%ì…ë‹ˆë‹¤. ì—¬í–‰ì ë³´í—˜ê³¼ ë¹„ì ê´€ë¦¬ì— ì‹ ê²½ì“°ì„¸ìš”.`,
        actionable: true,
        action: 'ë¹„ì í˜„í™© í™•ì¸í•˜ê¸°'
      })
    } else if (internationalRatio <= 30) {
      insights.push({
        type: 'tip',
        title: 'êµ­ë‚´ì—¬í–‰ ë§ˆë‹ˆì•„',
        description: `êµ­ë‚´ì—¬í–‰ì„ ë§ì´ ë‹¤ë‹ˆì‹œë„¤ìš”. ìˆ¨ê²¨ì§„ êµ­ë‚´ ëª…ì†Œë¥¼ ë” íƒí—˜í•´ë³´ì„¸ìš”!`
      })
    }

}

// ë°ì´í„° í’ˆì§ˆ ê²½ê³ 
const lowConfidenceTrips = travelInfos.filter(trip => trip.confidence < 0.5).length
if (lowConfidenceTrips > 0) {
insights.push({
type: 'warning',
title: 'ë°ì´í„° ì •í™•ì„±',
description: `${lowConfidenceTrips}ê°œì˜ ì—¬í–‰ ì •ë³´ê°€ ë¶ˆì™„ì „í•©ë‹ˆë‹¤. ìˆ˜ë™ìœ¼ë¡œ í™•ì¸í•´ë³´ì„¸ìš”.`,
actionable: true,
action: 'ë°ì´í„° ê²€í† í•˜ê¸°'
})
}

return insights
}

/\*\*
ì—¬í–‰ ë‹¬ë ¥ ë°ì´í„° ìƒì„± (ì›”ë³„ ë·°)
/
export function generateTravelCalendar(travelInfos: TravelInfo[], year?: number, month?: number) {
const targetDate = new Date(year || new Date().getFullYear(), (month || new Date().getMonth()))
const startOfMonth = new Date(targetDate.getFullYear(), targetDate.getMonth(), 1)
const endOfMonth = new Date(targetDate.getFullYear(), targetDate.getMonth() + 1, 0)

const calendarEvents = []

for (const trip of travelInfos) {
if (trip.departureDate) {
try {
const depDate = new Date(trip.departureDate)

        // í•´ë‹¹ ì›”ì— í¬í•¨ë˜ëŠ” ì—¬í–‰ë§Œ í•„í„°ë§
        if (depDate >= startOfMonth && depDate <= endOfMonth) {
          calendarEvents.push({
            date: depDate.toISOString().split('T')[0],
            type: 'departure',
            title: `ì¶œë°œ: ${trip.destination ? airportCodes[trip.destination as keyof typeof airportCodes] || trip.destination : 'ëª©ì ì§€ ë¯¸ìƒ'}`,
            flightNumber: trip.flightNumber,
            confidence: trip.confidence,
            trip
          })
        }

        // ê·€êµ­ ë‚ ì§œë„ ì¶”ê°€
        if (trip.returnDate) {
          const retDate = new Date(trip.returnDate)
          if (retDate >= startOfMonth && retDate <= endOfMonth) {
            calendarEvents.push({
              date: retDate.toISOString().split('T')[0],
              type: 'return',
              title: `ê·€êµ­: ${trip.departure ? airportCodes[trip.departure as keyof typeof airportCodes] || trip.departure : 'ì¶œë°œì§€ ë¯¸ìƒ'}`,
              flightNumber: trip.flightNumber,
              confidence: trip.confidence,
              trip
            })
          }
        }
      } catch (error) {
        // Invalid date in trip
      }
    }

}

return calendarEvents.sort((a, b) => a.date.localeCompare(b.date))
}

/\*\*
ì—¬í–‰ ë¹„ìš© ì˜ˆì¸¡ (ê¸°ë³¸ì ì¸ ì¶”ì •)

**íŠ¹ì„±:** `exported`

### ğŸ”— Interfaces

#### `TravelStats`

**íŠ¹ì„±:** `exported`

#### `TravelInsight`

**íŠ¹ì„±:** `exported`

## gmail-middleware.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/gmail-middleware.ts`

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 5129 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 221
- ğŸ”§ í•¨ìˆ˜: 5ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 1ê°œ

**Exports:**

- `checkRateLimit`
- `async`
- `getRateLimitStatus`
- `sanitizeGmailResponse`

### ğŸ”§ Functions

#### `checkRateLimit`

ì‚¬ìš©ìë³„ ì†ë„ ì œí•œì„ í™•ì¸í•©ë‹ˆë‹¤.
@param userId ì‚¬ìš©ì ID
@param config ì†ë„ ì œí•œ ì„¤ì •

**íŠ¹ì„±:** `exported`

#### `withGmailAuth`

ì‚¬ìš©ìë³„ ì†ë„ ì œí•œì„ í™•ì¸í•©ë‹ˆë‹¤.
@param userId ì‚¬ìš©ì ID
@param config ì†ë„ ì œí•œ ì„¤ì •
/
export function checkRateLimit(userId: string, config: RateLimitConfig): boolean {
const now = Date.now()
const key = `gmail_${userId}`

const existing = rateLimitStore.get(key)

if (!existing || now > existing.resetTime) {
// ìƒˆë¡œìš´ ìœˆë„ìš° ì‹œì‘
rateLimitStore.set(key, {
count: 1,
resetTime: now + config.windowMs
})
return true
}

if (existing.count >= config.maxRequests) {
// ì†ë„ ì œí•œ ì´ˆê³¼
return false
}

// ìš”ì²­ ì¹´ìš´íŠ¸ ì¦ê°€
existing.count++
rateLimitStore.set(key, existing)
return true
}

/\*\*
Gmail API ìš”ì²­ì„ ìœ„í•œ ê³µí†µ ë¯¸ë“¤ì›¨ì–´

- ì¸ì¦ í™•ì¸
- ì†ë„ ì œí•œ
- ì—ëŸ¬ ì²˜ë¦¬

**íŠ¹ì„±:** `exported`, `async`

#### `getRateLimitStatus`

ì‚¬ìš©ìë³„ ì†ë„ ì œí•œì„ í™•ì¸í•©ë‹ˆë‹¤.
@param userId ì‚¬ìš©ì ID
@param config ì†ë„ ì œí•œ ì„¤ì •
/
export function checkRateLimit(userId: string, config: RateLimitConfig): boolean {
const now = Date.now()
const key = `gmail_${userId}`

const existing = rateLimitStore.get(key)

if (!existing || now > existing.resetTime) {
// ìƒˆë¡œìš´ ìœˆë„ìš° ì‹œì‘
rateLimitStore.set(key, {
count: 1,
resetTime: now + config.windowMs
})
return true
}

if (existing.count >= config.maxRequests) {
// ì†ë„ ì œí•œ ì´ˆê³¼
return false
}

// ìš”ì²­ ì¹´ìš´íŠ¸ ì¦ê°€
existing.count++
rateLimitStore.set(key, existing)
return true
}

/\*\*
Gmail API ìš”ì²­ì„ ìœ„í•œ ê³µí†µ ë¯¸ë“¤ì›¨ì–´

- ì¸ì¦ í™•ì¸
- ì†ë„ ì œí•œ
- ì—ëŸ¬ ì²˜ë¦¬
  /
  export async function withGmailAuth(
  request: NextRequest,
  handler: (session: any, request: NextRequest) => Promise<NextResponse>
  ) {
  try {
  // 1. ì„¸ì…˜ í™•ì¸
  const session = await getServerSession(authOptions)
  if (!session) {
  return NextResponse.json(
  {
  error: 'Unauthorized',
  message: 'ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤. Google ê³„ì •ìœ¼ë¡œ ë‹¤ì‹œ ë¡œê·¸ì¸í•´ì£¼ì„¸ìš”.'
  },
  { status: 401 }
  )
  }

      // 2. ì†ë„ ì œí•œ í™•ì¸
      const rateLimitConfig: RateLimitConfig = {
        windowMs: 60 * 1000, // 1ë¶„
        maxRequests: 30 // ë¶„ë‹¹ 30íšŒ
      }

      if (!checkRateLimit(session.user?.id || '', rateLimitConfig)) {
        return NextResponse.json(
          {
            error: 'Rate Limit Exceeded',
            message: 'ë„ˆë¬´ ë§ì€ ìš”ì²­ì´ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.'
          },
          { status: 429 }
        )
      }

      // 3. í•¸ë“¤ëŸ¬ ì‹¤í–‰
      return await handler(session, request)

  } catch (error) {
  // Gmail middleware error
  // Gmail API ì—ëŸ¬ ì²˜ë¦¬
  if (error && typeof error === 'object' && 'code' in error) {
  const gmailError = error as any

        switch (gmailError.code) {
          case 401:
            return NextResponse.json(
              {
                error: 'Gmail Authorization Failed',
                message: 'Gmail ê¶Œí•œì´ ë§Œë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ë¡œê·¸ì¸í•´ì£¼ì„¸ìš”.'
              },
              { status: 401 }
            )

          case 403:
            return NextResponse.json(
              {
                error: 'Gmail Permission Denied',
                message: 'Gmail ì ‘ê·¼ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤. ê¶Œí•œì„ í™•ì¸í•´ì£¼ì„¸ìš”.'
              },
              { status: 403 }
            )

          case 429:
            return NextResponse.json(
              {
                error: 'Gmail Rate Limit',
                message: 'Gmail API í˜¸ì¶œ í•œë„ë¥¼ ì´ˆê³¼í–ˆìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.'
              },
              { status: 429 }
            )

          case 500:
            return NextResponse.json(
              {
                error: 'Gmail Service Error',
                message: 'Gmail ì„œë¹„ìŠ¤ì— ì¼ì‹œì ì¸ ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.'
              },
              { status: 500 }
            )

          default:
            return NextResponse.json(
              {
                error: 'Gmail API Error',
                message: 'Gmail API í˜¸ì¶œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.'
              },
              { status: 500 }
            )
        }
      }

      // ì¼ë°˜ ì—ëŸ¬
      return NextResponse.json(
        {
          error: 'Internal Server Error',
          message: 'ì„œë²„ ë‚´ë¶€ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.'
        },
        { status: 500 }
      )

  }
  }

/\*\*
ì†ë„ ì œí•œ ìƒíƒœë¥¼ í™•ì¸í•©ë‹ˆë‹¤.
@param userId ì‚¬ìš©ì ID

**íŠ¹ì„±:** `exported`

#### `sanitizeGmailResponse`

ì‚¬ìš©ìë³„ ì†ë„ ì œí•œì„ í™•ì¸í•©ë‹ˆë‹¤.
@param userId ì‚¬ìš©ì ID
@param config ì†ë„ ì œí•œ ì„¤ì •
/
export function checkRateLimit(userId: string, config: RateLimitConfig): boolean {
const now = Date.now()
const key = `gmail_${userId}`

const existing = rateLimitStore.get(key)

if (!existing || now > existing.resetTime) {
// ìƒˆë¡œìš´ ìœˆë„ìš° ì‹œì‘
rateLimitStore.set(key, {
count: 1,
resetTime: now + config.windowMs
})
return true
}

if (existing.count >= config.maxRequests) {
// ì†ë„ ì œí•œ ì´ˆê³¼
return false
}

// ìš”ì²­ ì¹´ìš´íŠ¸ ì¦ê°€
existing.count++
rateLimitStore.set(key, existing)
return true
}

/\*\*
Gmail API ìš”ì²­ì„ ìœ„í•œ ê³µí†µ ë¯¸ë“¤ì›¨ì–´

- ì¸ì¦ í™•ì¸
- ì†ë„ ì œí•œ
- ì—ëŸ¬ ì²˜ë¦¬
  /
  export async function withGmailAuth(
  request: NextRequest,
  handler: (session: any, request: NextRequest) => Promise<NextResponse>
  ) {
  try {
  // 1. ì„¸ì…˜ í™•ì¸
  const session = await getServerSession(authOptions)
  if (!session) {
  return NextResponse.json(
  {
  error: 'Unauthorized',
  message: 'ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤. Google ê³„ì •ìœ¼ë¡œ ë‹¤ì‹œ ë¡œê·¸ì¸í•´ì£¼ì„¸ìš”.'
  },
  { status: 401 }
  )
  }

      // 2. ì†ë„ ì œí•œ í™•ì¸
      const rateLimitConfig: RateLimitConfig = {
        windowMs: 60 * 1000, // 1ë¶„
        maxRequests: 30 // ë¶„ë‹¹ 30íšŒ
      }

      if (!checkRateLimit(session.user?.id || '', rateLimitConfig)) {
        return NextResponse.json(
          {
            error: 'Rate Limit Exceeded',
            message: 'ë„ˆë¬´ ë§ì€ ìš”ì²­ì´ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.'
          },
          { status: 429 }
        )
      }

      // 3. í•¸ë“¤ëŸ¬ ì‹¤í–‰
      return await handler(session, request)

  } catch (error) {
  // Gmail middleware error
  // Gmail API ì—ëŸ¬ ì²˜ë¦¬
  if (error && typeof error === 'object' && 'code' in error) {
  const gmailError = error as any

        switch (gmailError.code) {
          case 401:
            return NextResponse.json(
              {
                error: 'Gmail Authorization Failed',
                message: 'Gmail ê¶Œí•œì´ ë§Œë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ë¡œê·¸ì¸í•´ì£¼ì„¸ìš”.'
              },
              { status: 401 }
            )

          case 403:
            return NextResponse.json(
              {
                error: 'Gmail Permission Denied',
                message: 'Gmail ì ‘ê·¼ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤. ê¶Œí•œì„ í™•ì¸í•´ì£¼ì„¸ìš”.'
              },
              { status: 403 }
            )

          case 429:
            return NextResponse.json(
              {
                error: 'Gmail Rate Limit',
                message: 'Gmail API í˜¸ì¶œ í•œë„ë¥¼ ì´ˆê³¼í–ˆìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.'
              },
              { status: 429 }
            )

          case 500:
            return NextResponse.json(
              {
                error: 'Gmail Service Error',
                message: 'Gmail ì„œë¹„ìŠ¤ì— ì¼ì‹œì ì¸ ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.'
              },
              { status: 500 }
            )

          default:
            return NextResponse.json(
              {
                error: 'Gmail API Error',
                message: 'Gmail API í˜¸ì¶œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.'
              },
              { status: 500 }
            )
        }
      }

      // ì¼ë°˜ ì—ëŸ¬
      return NextResponse.json(
        {
          error: 'Internal Server Error',
          message: 'ì„œë²„ ë‚´ë¶€ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.'
        },
        { status: 500 }
      )

  }
  }

/\*\*
ì†ë„ ì œí•œ ìƒíƒœë¥¼ í™•ì¸í•©ë‹ˆë‹¤.
@param userId ì‚¬ìš©ì ID
/
export function getRateLimitStatus(userId: string) {
const key = `gmail_${userId}`
const existing = rateLimitStore.get(key)
const now = Date.now()

if (!existing || now > existing.resetTime) {
return {
remaining: 30,
resetTime: now + 60 \* 1000,
total: 30
}
}

return {
remaining: Math.max(0, 30 - existing.count),
resetTime: existing.resetTime,
total: 30
}
}

/\*\*
Gmail API ì‘ë‹µì„ ì •ë¦¬í•©ë‹ˆë‹¤ (ê°œì¸ì •ë³´ ë³´í˜¸)
@param data ì›ë³¸ ë°ì´í„°

**íŠ¹ì„±:** `exported`

#### `maskEmail`

### ğŸ”— Interfaces

#### `RateLimitConfig`

## gmail.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/gmail.ts`

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 14078 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 516
- ğŸ”§ í•¨ìˆ˜: 8ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 2ê°œ

**Exports:**

- `EmailMessage`
- `TravelInfo`
- `createGmailClient`
- `async`
- `extractTravelInfo`

### ğŸ”§ Functions

#### `createGmailClient`

Gmail API í´ë¼ì´ì–¸íŠ¸ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
@param accessToken ì‚¬ìš©ìì˜ Google ì•¡ì„¸ìŠ¤ í† í°

**íŠ¹ì„±:** `exported`

#### `searchTravelEmails`

Gmail API í´ë¼ì´ì–¸íŠ¸ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
@param accessToken ì‚¬ìš©ìì˜ Google ì•¡ì„¸ìŠ¤ í† í°
/
export function createGmailClient(accessToken: string) {
const oauth2Client = new google.auth.OAuth2(
process.env.GOOGLE_CLIENT_ID,
process.env.GOOGLE_CLIENT_SECRET
)

oauth2Client.setCredentials({
access_token: accessToken
})

return google.gmail({ version: 'v1', auth: oauth2Client })
}

/\*\*
ì—¬í–‰ ê´€ë ¨ ì´ë©”ì¼ì„ ê²€ìƒ‰í•©ë‹ˆë‹¤.
@param accessToken ì‚¬ìš©ìì˜ Google ì•¡ì„¸ìŠ¤ í† í°
@param maxResults ìµœëŒ€ ê²°ê³¼ ìˆ˜ (ê¸°ë³¸ê°’: 50)

**íŠ¹ì„±:** `exported`, `async`

#### `extractTravelInfo`

Gmail API í´ë¼ì´ì–¸íŠ¸ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
@param accessToken ì‚¬ìš©ìì˜ Google ì•¡ì„¸ìŠ¤ í† í°
/
export function createGmailClient(accessToken: string) {
const oauth2Client = new google.auth.OAuth2(
process.env.GOOGLE_CLIENT_ID,
process.env.GOOGLE_CLIENT_SECRET
)

oauth2Client.setCredentials({
access_token: accessToken
})

return google.gmail({ version: 'v1', auth: oauth2Client })
}

/\*\*
ì—¬í–‰ ê´€ë ¨ ì´ë©”ì¼ì„ ê²€ìƒ‰í•©ë‹ˆë‹¤.
@param accessToken ì‚¬ìš©ìì˜ Google ì•¡ì„¸ìŠ¤ í† í°
@param maxResults ìµœëŒ€ ê²°ê³¼ ìˆ˜ (ê¸°ë³¸ê°’: 50)
/
export async function searchTravelEmails(
accessToken: string,
maxResults: number = 50
): Promise<EmailMessage[]> {
try {
const gmail = createGmailClient(accessToken)

      // ê³ ê¸‰ ì—¬í–‰ ê´€ë ¨ í‚¤ì›Œë“œë¡œ ê²€ìƒ‰ (í•œêµ­ì–´/ì˜ì–´ ì§€ì›)
    const searchQuery = [
      // í•­ê³µí¸ ê´€ë ¨
      'subject:(flight OR í•­ê³µí¸ OR í•­ê³µê¶Œ OR eticket OR "boarding pass" OR "íƒ‘ìŠ¹ê¶Œ")',
      'subject:(booking OR reservation OR confirmation OR ì˜ˆì•½ OR í™•ì¸)',
      'subject:(itinerary OR schedule OR ì¼ì •)',

      // í˜¸í…” ê´€ë ¨
      'subject:(hotel OR accommodation OR í˜¸í…” OR ìˆ™ë°•)',
      'subject:("check-in" OR "check-out" OR ì²´í¬ì¸ OR ì²´í¬ì•„ì›ƒ)',

      // ì£¼ìš” í•­ê³µì‚¬
      'from:(koreanair.com OR flyasiana.com OR jejuair.net)',
      'from:(united.com OR delta.com OR jal.com OR ana.co.jp)',

      // ì£¼ìš” ì˜ˆì•½ í”Œë«í¼
      'from:(booking.com OR expedia.com OR agoda.com OR hotels.com)',
      'from:(kayak.com OR priceline.com OR orbitz.com)',
      'from:(airbnb.com OR vrbo.com)',

      // ë Œí„°ì¹´
      'from:(hertz.com OR avis.com OR enterprise.com OR budget.com)',

      // ì—¬í–‰ì‚¬
      'from:(expedia.com OR travelocity.com OR orbitz.com)',

      // ì¼ë°˜ì ì¸ ì—¬í–‰ ê´€ë ¨ í‚¤ì›Œë“œ
      'subject:(trip OR travel OR vacation OR ì—¬í–‰ OR ì¶œì¥)',
      'subject:(departure OR arrival OR ì¶œë°œ OR ë„ì°©)'
    ].join(' OR ')

    const response = await gmail.users.messages.list({
      userId: 'me',
      q: searchQuery,
      maxResults
    })

    if (!response.data.messages) {
      return []
    }

    // ê° ë©”ì‹œì§€ì˜ ìƒì„¸ ì •ë³´ë¥¼ ê°€ì ¸ì˜¤ê¸°
    const messages: EmailMessage[] = []

    for (const message of response.data.messages.slice(0, maxResults)) {
      try {
        const messageDetail = await gmail.users.messages.get({
          userId: 'me',
          id: message.id!,
          format: 'full'
        })

        const headers = messageDetail.data.payload?.headers || []
        const subject = headers.find(h => h.name === 'Subject')?.value || 'No Subject'
        const from = headers.find(h => h.name === 'From')?.value || 'Unknown Sender'
        const to = headers.find(h => h.name === 'To')?.value || 'Unknown Recipient'
        const date = headers.find(h => h.name === 'Date')?.value || 'Unknown Date'

        // ì´ë©”ì¼ ë³¸ë¬¸ ì¶”ì¶œ
        let body = ''
        const payload = messageDetail.data.payload

        if (payload?.parts) {
          // ë©€í‹°íŒŒíŠ¸ ë©”ì‹œì§€
          for (const part of payload.parts) {
            if (part.mimeType === 'text/plain' && part.body?.data) {
              body += Buffer.from(part.body.data, 'base64').toString('utf-8')
            }
          }
        } else if (payload?.body?.data) {
          // ë‹¨ì¼ íŒŒíŠ¸ ë©”ì‹œì§€
          body = Buffer.from(payload.body.data, 'base64').toString('utf-8')
        }

        messages.push({
          id: message.id!,
          subject,
          from,
          to,
          date,
          body,
          snippet: messageDetail.data.snippet || ''
        })
      } catch (error) {
        // Error fetching message
        // ê°œë³„ ë©”ì‹œì§€ ì˜¤ë¥˜ëŠ” ê±´ë„ˆë›°ê³  ê³„ì† ì§„í–‰
      }
    }

    return messages

} catch (error) {
// Error searching travel emails
throw new Error('Gmail API ìš”ì²­ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.')
}
}

/\*\*
ê³ ê¸‰ ì—¬í–‰ ì •ë³´ ì¶”ì¶œ í•¨ìˆ˜
@param email ì´ë©”ì¼ ë©”ì‹œì§€

**íŠ¹ì„±:** `exported`

#### `extractSpecializedInfo`

Gmail API í´ë¼ì´ì–¸íŠ¸ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
@param accessToken ì‚¬ìš©ìì˜ Google ì•¡ì„¸ìŠ¤ í† í°
/
export function createGmailClient(accessToken: string) {
const oauth2Client = new google.auth.OAuth2(
process.env.GOOGLE_CLIENT_ID,
process.env.GOOGLE_CLIENT_SECRET
)

oauth2Client.setCredentials({
access_token: accessToken
})

return google.gmail({ version: 'v1', auth: oauth2Client })
}

/\*\*
ì—¬í–‰ ê´€ë ¨ ì´ë©”ì¼ì„ ê²€ìƒ‰í•©ë‹ˆë‹¤.
@param accessToken ì‚¬ìš©ìì˜ Google ì•¡ì„¸ìŠ¤ í† í°
@param maxResults ìµœëŒ€ ê²°ê³¼ ìˆ˜ (ê¸°ë³¸ê°’: 50)
/
export async function searchTravelEmails(
accessToken: string,
maxResults: number = 50
): Promise<EmailMessage[]> {
try {
const gmail = createGmailClient(accessToken)

      // ê³ ê¸‰ ì—¬í–‰ ê´€ë ¨ í‚¤ì›Œë“œë¡œ ê²€ìƒ‰ (í•œêµ­ì–´/ì˜ì–´ ì§€ì›)
    const searchQuery = [
      // í•­ê³µí¸ ê´€ë ¨
      'subject:(flight OR í•­ê³µí¸ OR í•­ê³µê¶Œ OR eticket OR "boarding pass" OR "íƒ‘ìŠ¹ê¶Œ")',
      'subject:(booking OR reservation OR confirmation OR ì˜ˆì•½ OR í™•ì¸)',
      'subject:(itinerary OR schedule OR ì¼ì •)',

      // í˜¸í…” ê´€ë ¨
      'subject:(hotel OR accommodation OR í˜¸í…” OR ìˆ™ë°•)',
      'subject:("check-in" OR "check-out" OR ì²´í¬ì¸ OR ì²´í¬ì•„ì›ƒ)',

      // ì£¼ìš” í•­ê³µì‚¬
      'from:(koreanair.com OR flyasiana.com OR jejuair.net)',
      'from:(united.com OR delta.com OR jal.com OR ana.co.jp)',

      // ì£¼ìš” ì˜ˆì•½ í”Œë«í¼
      'from:(booking.com OR expedia.com OR agoda.com OR hotels.com)',
      'from:(kayak.com OR priceline.com OR orbitz.com)',
      'from:(airbnb.com OR vrbo.com)',

      // ë Œí„°ì¹´
      'from:(hertz.com OR avis.com OR enterprise.com OR budget.com)',

      // ì—¬í–‰ì‚¬
      'from:(expedia.com OR travelocity.com OR orbitz.com)',

      // ì¼ë°˜ì ì¸ ì—¬í–‰ ê´€ë ¨ í‚¤ì›Œë“œ
      'subject:(trip OR travel OR vacation OR ì—¬í–‰ OR ì¶œì¥)',
      'subject:(departure OR arrival OR ì¶œë°œ OR ë„ì°©)'
    ].join(' OR ')

    const response = await gmail.users.messages.list({
      userId: 'me',
      q: searchQuery,
      maxResults
    })

    if (!response.data.messages) {
      return []
    }

    // ê° ë©”ì‹œì§€ì˜ ìƒì„¸ ì •ë³´ë¥¼ ê°€ì ¸ì˜¤ê¸°
    const messages: EmailMessage[] = []

    for (const message of response.data.messages.slice(0, maxResults)) {
      try {
        const messageDetail = await gmail.users.messages.get({
          userId: 'me',
          id: message.id!,
          format: 'full'
        })

        const headers = messageDetail.data.payload?.headers || []
        const subject = headers.find(h => h.name === 'Subject')?.value || 'No Subject'
        const from = headers.find(h => h.name === 'From')?.value || 'Unknown Sender'
        const to = headers.find(h => h.name === 'To')?.value || 'Unknown Recipient'
        const date = headers.find(h => h.name === 'Date')?.value || 'Unknown Date'

        // ì´ë©”ì¼ ë³¸ë¬¸ ì¶”ì¶œ
        let body = ''
        const payload = messageDetail.data.payload

        if (payload?.parts) {
          // ë©€í‹°íŒŒíŠ¸ ë©”ì‹œì§€
          for (const part of payload.parts) {
            if (part.mimeType === 'text/plain' && part.body?.data) {
              body += Buffer.from(part.body.data, 'base64').toString('utf-8')
            }
          }
        } else if (payload?.body?.data) {
          // ë‹¨ì¼ íŒŒíŠ¸ ë©”ì‹œì§€
          body = Buffer.from(payload.body.data, 'base64').toString('utf-8')
        }

        messages.push({
          id: message.id!,
          subject,
          from,
          to,
          date,
          body,
          snippet: messageDetail.data.snippet || ''
        })
      } catch (error) {
        // Error fetching message
        // ê°œë³„ ë©”ì‹œì§€ ì˜¤ë¥˜ëŠ” ê±´ë„ˆë›°ê³  ê³„ì† ì§„í–‰
      }
    }

    return messages

} catch (error) {
// Error searching travel emails
throw new Error('Gmail API ìš”ì²­ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.')
}
}

/\*\*
ê³ ê¸‰ ì—¬í–‰ ì •ë³´ ì¶”ì¶œ í•¨ìˆ˜
@param email ì´ë©”ì¼ ë©”ì‹œì§€
/
export function extractTravelInfo(email: EmailMessage): TravelInfo | null {
const fullText = `${email.subject} ${email.body} ${email.snippet}`
const normalizedText = fullText.toLowerCase()

// ê¸°ë³¸ ì—¬í–‰ ì •ë³´ ê°ì²´
const travelInfo: TravelInfo = {
emailId: email.id,
subject: email.subject,
from: email.from,
confidence: 0,
extractedData: {
dates: [],
airports: [],
flights: [],
bookingCodes: [],
matchedPatterns: []
}
}

// íŒ¨í„´ ë§¤ì¹­ìœ¼ë¡œ ì´ë©”ì¼ ì¹´í…Œê³ ë¦¬ ë° ê°€ì¤‘ì¹˜ ê²°ì •
let matchedPattern: TravelEmailPattern | null = null
let maxWeight = 0

for (const pattern of allTravelPatterns) {
let patternScore = 0

    // ë°œì‹ ì íŒ¨í„´ í™•ì¸
    for (const senderPattern of pattern.senderPatterns) {
      if (senderPattern.test(email.from)) {
        patternScore += 0.4
        travelInfo.extractedData.matchedPatterns.push(`sender:${pattern.name}`)
        break
      }
    }

    // ì œëª© íŒ¨í„´ í™•ì¸
    for (const subjectPattern of pattern.subjectPatterns) {
      if (subjectPattern.test(email.subject)) {
        patternScore += 0.3
        travelInfo.extractedData.matchedPatterns.push(`subject:${pattern.name}`)
        break
      }
    }

    // ë³¸ë¬¸ íŒ¨í„´ í™•ì¸
    for (const bodyPattern of pattern.bodyPatterns) {
      if (bodyPattern.test(normalizedText)) {
        patternScore += 0.3
        travelInfo.extractedData.matchedPatterns.push(`body:${pattern.name}`)
        break
      }
    }

    const weightedScore = patternScore * pattern.weight
    if (weightedScore > maxWeight) {
      maxWeight = weightedScore
      matchedPattern = pattern
      travelInfo.category = pattern.category
    }

}

// ê¸°ë³¸ ì‹ ë¢°ë„ ì„¤ì •
travelInfo.confidence = maxWeight

// íŠ¹í™”ëœ ì •ë³´ ì¶”ì¶œ
if (matchedPattern?.extractors) {
extractSpecializedInfo(fullText, normalizedText, matchedPattern, travelInfo)
}

// ì¼ë°˜ì ì¸ ì •ë³´ ì¶”ì¶œ (ëª¨ë“  ì´ë©”ì¼ì— ì ìš©)
extractGeneralTravelInfo(fullText, normalizedText, travelInfo)

// ì¶”ì¶œëœ ë°ì´í„° ê¸°ë°˜ ì‹ ë¢°ë„ ì¡°ì •
adjustConfidenceBasedOnExtractedData(travelInfo)

// ì‹ ë¢°ë„ê°€ ë„ˆë¬´ ë‚®ìœ¼ë©´ null ë°˜í™˜
if (travelInfo.confidence < 0.2) {
return null
}

return travelInfo
}

/\*\*
íŠ¹í™”ëœ íŒ¨í„´ ê¸°ë°˜ ì •ë³´ ì¶”ì¶œ

#### `extractGeneralTravelInfo`

Gmail API í´ë¼ì´ì–¸íŠ¸ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
@param accessToken ì‚¬ìš©ìì˜ Google ì•¡ì„¸ìŠ¤ í† í°
/
export function createGmailClient(accessToken: string) {
const oauth2Client = new google.auth.OAuth2(
process.env.GOOGLE_CLIENT_ID,
process.env.GOOGLE_CLIENT_SECRET
)

oauth2Client.setCredentials({
access_token: accessToken
})

return google.gmail({ version: 'v1', auth: oauth2Client })
}

/\*\*
ì—¬í–‰ ê´€ë ¨ ì´ë©”ì¼ì„ ê²€ìƒ‰í•©ë‹ˆë‹¤.
@param accessToken ì‚¬ìš©ìì˜ Google ì•¡ì„¸ìŠ¤ í† í°
@param maxResults ìµœëŒ€ ê²°ê³¼ ìˆ˜ (ê¸°ë³¸ê°’: 50)
/
export async function searchTravelEmails(
accessToken: string,
maxResults: number = 50
): Promise<EmailMessage[]> {
try {
const gmail = createGmailClient(accessToken)

      // ê³ ê¸‰ ì—¬í–‰ ê´€ë ¨ í‚¤ì›Œë“œë¡œ ê²€ìƒ‰ (í•œêµ­ì–´/ì˜ì–´ ì§€ì›)
    const searchQuery = [
      // í•­ê³µí¸ ê´€ë ¨
      'subject:(flight OR í•­ê³µí¸ OR í•­ê³µê¶Œ OR eticket OR "boarding pass" OR "íƒ‘ìŠ¹ê¶Œ")',
      'subject:(booking OR reservation OR confirmation OR ì˜ˆì•½ OR í™•ì¸)',
      'subject:(itinerary OR schedule OR ì¼ì •)',

      // í˜¸í…” ê´€ë ¨
      'subject:(hotel OR accommodation OR í˜¸í…” OR ìˆ™ë°•)',
      'subject:("check-in" OR "check-out" OR ì²´í¬ì¸ OR ì²´í¬ì•„ì›ƒ)',

      // ì£¼ìš” í•­ê³µì‚¬
      'from:(koreanair.com OR flyasiana.com OR jejuair.net)',
      'from:(united.com OR delta.com OR jal.com OR ana.co.jp)',

      // ì£¼ìš” ì˜ˆì•½ í”Œë«í¼
      'from:(booking.com OR expedia.com OR agoda.com OR hotels.com)',
      'from:(kayak.com OR priceline.com OR orbitz.com)',
      'from:(airbnb.com OR vrbo.com)',

      // ë Œí„°ì¹´
      'from:(hertz.com OR avis.com OR enterprise.com OR budget.com)',

      // ì—¬í–‰ì‚¬
      'from:(expedia.com OR travelocity.com OR orbitz.com)',

      // ì¼ë°˜ì ì¸ ì—¬í–‰ ê´€ë ¨ í‚¤ì›Œë“œ
      'subject:(trip OR travel OR vacation OR ì—¬í–‰ OR ì¶œì¥)',
      'subject:(departure OR arrival OR ì¶œë°œ OR ë„ì°©)'
    ].join(' OR ')

    const response = await gmail.users.messages.list({
      userId: 'me',
      q: searchQuery,
      maxResults
    })

    if (!response.data.messages) {
      return []
    }

    // ê° ë©”ì‹œì§€ì˜ ìƒì„¸ ì •ë³´ë¥¼ ê°€ì ¸ì˜¤ê¸°
    const messages: EmailMessage[] = []

    for (const message of response.data.messages.slice(0, maxResults)) {
      try {
        const messageDetail = await gmail.users.messages.get({
          userId: 'me',
          id: message.id!,
          format: 'full'
        })

        const headers = messageDetail.data.payload?.headers || []
        const subject = headers.find(h => h.name === 'Subject')?.value || 'No Subject'
        const from = headers.find(h => h.name === 'From')?.value || 'Unknown Sender'
        const to = headers.find(h => h.name === 'To')?.value || 'Unknown Recipient'
        const date = headers.find(h => h.name === 'Date')?.value || 'Unknown Date'

        // ì´ë©”ì¼ ë³¸ë¬¸ ì¶”ì¶œ
        let body = ''
        const payload = messageDetail.data.payload

        if (payload?.parts) {
          // ë©€í‹°íŒŒíŠ¸ ë©”ì‹œì§€
          for (const part of payload.parts) {
            if (part.mimeType === 'text/plain' && part.body?.data) {
              body += Buffer.from(part.body.data, 'base64').toString('utf-8')
            }
          }
        } else if (payload?.body?.data) {
          // ë‹¨ì¼ íŒŒíŠ¸ ë©”ì‹œì§€
          body = Buffer.from(payload.body.data, 'base64').toString('utf-8')
        }

        messages.push({
          id: message.id!,
          subject,
          from,
          to,
          date,
          body,
          snippet: messageDetail.data.snippet || ''
        })
      } catch (error) {
        // Error fetching message
        // ê°œë³„ ë©”ì‹œì§€ ì˜¤ë¥˜ëŠ” ê±´ë„ˆë›°ê³  ê³„ì† ì§„í–‰
      }
    }

    return messages

} catch (error) {
// Error searching travel emails
throw new Error('Gmail API ìš”ì²­ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.')
}
}

/\*\*
ê³ ê¸‰ ì—¬í–‰ ì •ë³´ ì¶”ì¶œ í•¨ìˆ˜
@param email ì´ë©”ì¼ ë©”ì‹œì§€
/
export function extractTravelInfo(email: EmailMessage): TravelInfo | null {
const fullText = `${email.subject} ${email.body} ${email.snippet}`
const normalizedText = fullText.toLowerCase()

// ê¸°ë³¸ ì—¬í–‰ ì •ë³´ ê°ì²´
const travelInfo: TravelInfo = {
emailId: email.id,
subject: email.subject,
from: email.from,
confidence: 0,
extractedData: {
dates: [],
airports: [],
flights: [],
bookingCodes: [],
matchedPatterns: []
}
}

// íŒ¨í„´ ë§¤ì¹­ìœ¼ë¡œ ì´ë©”ì¼ ì¹´í…Œê³ ë¦¬ ë° ê°€ì¤‘ì¹˜ ê²°ì •
let matchedPattern: TravelEmailPattern | null = null
let maxWeight = 0

for (const pattern of allTravelPatterns) {
let patternScore = 0

    // ë°œì‹ ì íŒ¨í„´ í™•ì¸
    for (const senderPattern of pattern.senderPatterns) {
      if (senderPattern.test(email.from)) {
        patternScore += 0.4
        travelInfo.extractedData.matchedPatterns.push(`sender:${pattern.name}`)
        break
      }
    }

    // ì œëª© íŒ¨í„´ í™•ì¸
    for (const subjectPattern of pattern.subjectPatterns) {
      if (subjectPattern.test(email.subject)) {
        patternScore += 0.3
        travelInfo.extractedData.matchedPatterns.push(`subject:${pattern.name}`)
        break
      }
    }

    // ë³¸ë¬¸ íŒ¨í„´ í™•ì¸
    for (const bodyPattern of pattern.bodyPatterns) {
      if (bodyPattern.test(normalizedText)) {
        patternScore += 0.3
        travelInfo.extractedData.matchedPatterns.push(`body:${pattern.name}`)
        break
      }
    }

    const weightedScore = patternScore * pattern.weight
    if (weightedScore > maxWeight) {
      maxWeight = weightedScore
      matchedPattern = pattern
      travelInfo.category = pattern.category
    }

}

// ê¸°ë³¸ ì‹ ë¢°ë„ ì„¤ì •
travelInfo.confidence = maxWeight

// íŠ¹í™”ëœ ì •ë³´ ì¶”ì¶œ
if (matchedPattern?.extractors) {
extractSpecializedInfo(fullText, normalizedText, matchedPattern, travelInfo)
}

// ì¼ë°˜ì ì¸ ì •ë³´ ì¶”ì¶œ (ëª¨ë“  ì´ë©”ì¼ì— ì ìš©)
extractGeneralTravelInfo(fullText, normalizedText, travelInfo)

// ì¶”ì¶œëœ ë°ì´í„° ê¸°ë°˜ ì‹ ë¢°ë„ ì¡°ì •
adjustConfidenceBasedOnExtractedData(travelInfo)

// ì‹ ë¢°ë„ê°€ ë„ˆë¬´ ë‚®ìœ¼ë©´ null ë°˜í™˜
if (travelInfo.confidence < 0.2) {
return null
}

return travelInfo
}

/\*\*
íŠ¹í™”ëœ íŒ¨í„´ ê¸°ë°˜ ì •ë³´ ì¶”ì¶œ
/
function extractSpecializedInfo(
fullText: string,
normalizedText: string,
pattern: TravelEmailPattern,
travelInfo: TravelInfo
) {
const extractors = pattern.extractors

// í•­ê³µí¸ ë²ˆí˜¸ ì¶”ì¶œ
if (extractors.flights) {
for (const flightPattern of extractors.flights) {
const matches = fullText.match(flightPattern)
if (matches) {
travelInfo.extractedData.flights.push(...matches.map(m => m.toUpperCase()))
if (!travelInfo.flightNumber) {
travelInfo.flightNumber = matches[0].toUpperCase()
}
}
}
}

// ì˜ˆì•½ ë²ˆí˜¸ ì¶”ì¶œ
if (extractors.bookingReference) {
for (const bookingPattern of extractors.bookingReference) {
const matches = fullText.match(bookingPattern)
if (matches && matches.length >= 2) {
travelInfo.extractedData.bookingCodes.push(matches[1])
if (!travelInfo.bookingReference) {
travelInfo.bookingReference = matches[1]
}
}
}
}

// ê³µí•­ ì½”ë“œ ì¶”ì¶œ
if (extractors.airports) {
for (const airportPattern of extractors.airports) {
const matches = fullText.match(airportPattern)
if (matches) {
const airports = matches.filter(code => code in airportCodes)
travelInfo.extractedData.airports.push(...airports)
if (airports.length >= 2 && !travelInfo.departure) {
travelInfo.departure = airports[0]
travelInfo.destination = airports[1]
}
}
}
}

// ë‚ ì§œ ì¶”ì¶œ
if (extractors.dates) {
for (const datePattern of extractors.dates) {
const matches = fullText.match(datePattern)
if (matches) {
travelInfo.extractedData.dates.push(...matches)
}
}
}
}

/\*\*
ì¼ë°˜ì ì¸ ì—¬í–‰ ì •ë³´ ì¶”ì¶œ (ëª¨ë“  ì´ë©”ì¼ì— ì ìš©)

#### `adjustConfidenceBasedOnExtractedData`

Gmail API í´ë¼ì´ì–¸íŠ¸ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
@param accessToken ì‚¬ìš©ìì˜ Google ì•¡ì„¸ìŠ¤ í† í°
/
export function createGmailClient(accessToken: string) {
const oauth2Client = new google.auth.OAuth2(
process.env.GOOGLE_CLIENT_ID,
process.env.GOOGLE_CLIENT_SECRET
)

oauth2Client.setCredentials({
access_token: accessToken
})

return google.gmail({ version: 'v1', auth: oauth2Client })
}

/\*\*
ì—¬í–‰ ê´€ë ¨ ì´ë©”ì¼ì„ ê²€ìƒ‰í•©ë‹ˆë‹¤.
@param accessToken ì‚¬ìš©ìì˜ Google ì•¡ì„¸ìŠ¤ í† í°
@param maxResults ìµœëŒ€ ê²°ê³¼ ìˆ˜ (ê¸°ë³¸ê°’: 50)
/
export async function searchTravelEmails(
accessToken: string,
maxResults: number = 50
): Promise<EmailMessage[]> {
try {
const gmail = createGmailClient(accessToken)

      // ê³ ê¸‰ ì—¬í–‰ ê´€ë ¨ í‚¤ì›Œë“œë¡œ ê²€ìƒ‰ (í•œêµ­ì–´/ì˜ì–´ ì§€ì›)
    const searchQuery = [
      // í•­ê³µí¸ ê´€ë ¨
      'subject:(flight OR í•­ê³µí¸ OR í•­ê³µê¶Œ OR eticket OR "boarding pass" OR "íƒ‘ìŠ¹ê¶Œ")',
      'subject:(booking OR reservation OR confirmation OR ì˜ˆì•½ OR í™•ì¸)',
      'subject:(itinerary OR schedule OR ì¼ì •)',

      // í˜¸í…” ê´€ë ¨
      'subject:(hotel OR accommodation OR í˜¸í…” OR ìˆ™ë°•)',
      'subject:("check-in" OR "check-out" OR ì²´í¬ì¸ OR ì²´í¬ì•„ì›ƒ)',

      // ì£¼ìš” í•­ê³µì‚¬
      'from:(koreanair.com OR flyasiana.com OR jejuair.net)',
      'from:(united.com OR delta.com OR jal.com OR ana.co.jp)',

      // ì£¼ìš” ì˜ˆì•½ í”Œë«í¼
      'from:(booking.com OR expedia.com OR agoda.com OR hotels.com)',
      'from:(kayak.com OR priceline.com OR orbitz.com)',
      'from:(airbnb.com OR vrbo.com)',

      // ë Œí„°ì¹´
      'from:(hertz.com OR avis.com OR enterprise.com OR budget.com)',

      // ì—¬í–‰ì‚¬
      'from:(expedia.com OR travelocity.com OR orbitz.com)',

      // ì¼ë°˜ì ì¸ ì—¬í–‰ ê´€ë ¨ í‚¤ì›Œë“œ
      'subject:(trip OR travel OR vacation OR ì—¬í–‰ OR ì¶œì¥)',
      'subject:(departure OR arrival OR ì¶œë°œ OR ë„ì°©)'
    ].join(' OR ')

    const response = await gmail.users.messages.list({
      userId: 'me',
      q: searchQuery,
      maxResults
    })

    if (!response.data.messages) {
      return []
    }

    // ê° ë©”ì‹œì§€ì˜ ìƒì„¸ ì •ë³´ë¥¼ ê°€ì ¸ì˜¤ê¸°
    const messages: EmailMessage[] = []

    for (const message of response.data.messages.slice(0, maxResults)) {
      try {
        const messageDetail = await gmail.users.messages.get({
          userId: 'me',
          id: message.id!,
          format: 'full'
        })

        const headers = messageDetail.data.payload?.headers || []
        const subject = headers.find(h => h.name === 'Subject')?.value || 'No Subject'
        const from = headers.find(h => h.name === 'From')?.value || 'Unknown Sender'
        const to = headers.find(h => h.name === 'To')?.value || 'Unknown Recipient'
        const date = headers.find(h => h.name === 'Date')?.value || 'Unknown Date'

        // ì´ë©”ì¼ ë³¸ë¬¸ ì¶”ì¶œ
        let body = ''
        const payload = messageDetail.data.payload

        if (payload?.parts) {
          // ë©€í‹°íŒŒíŠ¸ ë©”ì‹œì§€
          for (const part of payload.parts) {
            if (part.mimeType === 'text/plain' && part.body?.data) {
              body += Buffer.from(part.body.data, 'base64').toString('utf-8')
            }
          }
        } else if (payload?.body?.data) {
          // ë‹¨ì¼ íŒŒíŠ¸ ë©”ì‹œì§€
          body = Buffer.from(payload.body.data, 'base64').toString('utf-8')
        }

        messages.push({
          id: message.id!,
          subject,
          from,
          to,
          date,
          body,
          snippet: messageDetail.data.snippet || ''
        })
      } catch (error) {
        // Error fetching message
        // ê°œë³„ ë©”ì‹œì§€ ì˜¤ë¥˜ëŠ” ê±´ë„ˆë›°ê³  ê³„ì† ì§„í–‰
      }
    }

    return messages

} catch (error) {
// Error searching travel emails
throw new Error('Gmail API ìš”ì²­ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.')
}
}

/\*\*
ê³ ê¸‰ ì—¬í–‰ ì •ë³´ ì¶”ì¶œ í•¨ìˆ˜
@param email ì´ë©”ì¼ ë©”ì‹œì§€
/
export function extractTravelInfo(email: EmailMessage): TravelInfo | null {
const fullText = `${email.subject} ${email.body} ${email.snippet}`
const normalizedText = fullText.toLowerCase()

// ê¸°ë³¸ ì—¬í–‰ ì •ë³´ ê°ì²´
const travelInfo: TravelInfo = {
emailId: email.id,
subject: email.subject,
from: email.from,
confidence: 0,
extractedData: {
dates: [],
airports: [],
flights: [],
bookingCodes: [],
matchedPatterns: []
}
}

// íŒ¨í„´ ë§¤ì¹­ìœ¼ë¡œ ì´ë©”ì¼ ì¹´í…Œê³ ë¦¬ ë° ê°€ì¤‘ì¹˜ ê²°ì •
let matchedPattern: TravelEmailPattern | null = null
let maxWeight = 0

for (const pattern of allTravelPatterns) {
let patternScore = 0

    // ë°œì‹ ì íŒ¨í„´ í™•ì¸
    for (const senderPattern of pattern.senderPatterns) {
      if (senderPattern.test(email.from)) {
        patternScore += 0.4
        travelInfo.extractedData.matchedPatterns.push(`sender:${pattern.name}`)
        break
      }
    }

    // ì œëª© íŒ¨í„´ í™•ì¸
    for (const subjectPattern of pattern.subjectPatterns) {
      if (subjectPattern.test(email.subject)) {
        patternScore += 0.3
        travelInfo.extractedData.matchedPatterns.push(`subject:${pattern.name}`)
        break
      }
    }

    // ë³¸ë¬¸ íŒ¨í„´ í™•ì¸
    for (const bodyPattern of pattern.bodyPatterns) {
      if (bodyPattern.test(normalizedText)) {
        patternScore += 0.3
        travelInfo.extractedData.matchedPatterns.push(`body:${pattern.name}`)
        break
      }
    }

    const weightedScore = patternScore * pattern.weight
    if (weightedScore > maxWeight) {
      maxWeight = weightedScore
      matchedPattern = pattern
      travelInfo.category = pattern.category
    }

}

// ê¸°ë³¸ ì‹ ë¢°ë„ ì„¤ì •
travelInfo.confidence = maxWeight

// íŠ¹í™”ëœ ì •ë³´ ì¶”ì¶œ
if (matchedPattern?.extractors) {
extractSpecializedInfo(fullText, normalizedText, matchedPattern, travelInfo)
}

// ì¼ë°˜ì ì¸ ì •ë³´ ì¶”ì¶œ (ëª¨ë“  ì´ë©”ì¼ì— ì ìš©)
extractGeneralTravelInfo(fullText, normalizedText, travelInfo)

// ì¶”ì¶œëœ ë°ì´í„° ê¸°ë°˜ ì‹ ë¢°ë„ ì¡°ì •
adjustConfidenceBasedOnExtractedData(travelInfo)

// ì‹ ë¢°ë„ê°€ ë„ˆë¬´ ë‚®ìœ¼ë©´ null ë°˜í™˜
if (travelInfo.confidence < 0.2) {
return null
}

return travelInfo
}

/\*\*
íŠ¹í™”ëœ íŒ¨í„´ ê¸°ë°˜ ì •ë³´ ì¶”ì¶œ
/
function extractSpecializedInfo(
fullText: string,
normalizedText: string,
pattern: TravelEmailPattern,
travelInfo: TravelInfo
) {
const extractors = pattern.extractors

// í•­ê³µí¸ ë²ˆí˜¸ ì¶”ì¶œ
if (extractors.flights) {
for (const flightPattern of extractors.flights) {
const matches = fullText.match(flightPattern)
if (matches) {
travelInfo.extractedData.flights.push(...matches.map(m => m.toUpperCase()))
if (!travelInfo.flightNumber) {
travelInfo.flightNumber = matches[0].toUpperCase()
}
}
}
}

// ì˜ˆì•½ ë²ˆí˜¸ ì¶”ì¶œ
if (extractors.bookingReference) {
for (const bookingPattern of extractors.bookingReference) {
const matches = fullText.match(bookingPattern)
if (matches && matches.length >= 2) {
travelInfo.extractedData.bookingCodes.push(matches[1])
if (!travelInfo.bookingReference) {
travelInfo.bookingReference = matches[1]
}
}
}
}

// ê³µí•­ ì½”ë“œ ì¶”ì¶œ
if (extractors.airports) {
for (const airportPattern of extractors.airports) {
const matches = fullText.match(airportPattern)
if (matches) {
const airports = matches.filter(code => code in airportCodes)
travelInfo.extractedData.airports.push(...airports)
if (airports.length >= 2 && !travelInfo.departure) {
travelInfo.departure = airports[0]
travelInfo.destination = airports[1]
}
}
}
}

// ë‚ ì§œ ì¶”ì¶œ
if (extractors.dates) {
for (const datePattern of extractors.dates) {
const matches = fullText.match(datePattern)
if (matches) {
travelInfo.extractedData.dates.push(...matches)
}
}
}
}

/\*\*
ì¼ë°˜ì ì¸ ì—¬í–‰ ì •ë³´ ì¶”ì¶œ (ëª¨ë“  ì´ë©”ì¼ì— ì ìš©)
/
function extractGeneralTravelInfo(
fullText: string,
normalizedText: string,
travelInfo: TravelInfo
) {
// ë‚ ì§œ íŒ¨í„´ ê²€ìƒ‰
for (const datePattern of datePatterns) {
const matches = fullText.match(datePattern)
if (matches) {
travelInfo.extractedData.dates.push(...matches)
}
}

// í•­ê³µí¸ ë²ˆí˜¸ ì¼ë°˜ íŒ¨í„´
const generalFlightPattern = /\b([A-Z]{2,3})\s\*(\d{3,4})\b/g
const flightMatches = fullText.match(generalFlightPattern)
if (flightMatches) {
const validFlights = flightMatches.filter(flight => {
const airlineCode = flight.match(/^([A-Z]{2,3})/)?.[1]
return airlineCode && airlineCode in airlineCodes
})
travelInfo.extractedData.flights.push(...validFlights.map(f => f.toUpperCase()))
}

// ê³µí•­ ì½”ë“œ ì¼ë°˜ íŒ¨í„´
const generalAirportPattern = /\b([A-Z]{3})\b/g
const airportMatches = fullText.match(generalAirportPattern)
if (airportMatches) {
const validAirports = airportMatches.filter(code => code in airportCodes)
travelInfo.extractedData.airports.push(...validAirports)
}

// ì˜ˆì•½ ë²ˆí˜¸ ì¼ë°˜ íŒ¨í„´
const generalBookingPatterns = [
/(confirmation|booking|reference|reservation)\s*(?:number|code|id)?[:\s]*([A-Z0-9]{6,})/gi,
/(ì˜ˆì•½|í™•ì¸)\s*(?:ë²ˆí˜¸|ì½”ë“œ)?[:\s]*([A-Z0-9]{6,})/gi,
/PNR[:\s]\*([A-Z0-9]{6,})/gi
]

for (const pattern of generalBookingPatterns) {
const matches = fullText.match(pattern)
if (matches) {
matches.forEach(match => {
const code = match.match(/([A-Z0-9]{6,})$/)?.[1]
if (code) {
travelInfo.extractedData.bookingCodes.push(code)
}
})
}
}

// ìŠ¹ê° ì´ë¦„ ì¶”ì¶œ (ì¼ë°˜ì ì¸ íŒ¨í„´)
const passengerPatterns = [
/passenger[:\s]_([A-Z][a-z]+\s+[A-Z][a-z]+)/gi,
/ìŠ¹ê°[:\s]_([ê°€-í£]+\s*[ê°€-í£]+)/gi,
/traveler[:\s]*([A-Z][a-z]+\s+[A-Z][a-z]+)/gi
]

for (const pattern of passengerPatterns) {
const match = fullText.match(pattern)
if (match && match.length >= 2 && !travelInfo.passengerName) {
travelInfo.passengerName = match[1].trim()
break
}
}

// í˜¸í…” ì´ë¦„ ì¶”ì¶œ
const hotelPatterns = [
/hotel[:\s]_([A-Za-z\s&]+?)(?:\n|\r|,|\.)/gi,
/(?:staying at|accommodation)[:\s]_([A-Za-z\s&]+?)(?:\n|\r|,|\.)/gi
]

for (const pattern of hotelPatterns) {
const match = fullText.match(pattern)
if (match && match.length >= 2 && !travelInfo.hotelName) {
travelInfo.hotelName = match[1].trim()
break
}
}
}

/\*\*
ì¶”ì¶œëœ ë°ì´í„°ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì‹ ë¢°ë„ ì¡°ì •

#### `analyzeTravelEmails`

Gmail API í´ë¼ì´ì–¸íŠ¸ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
@param accessToken ì‚¬ìš©ìì˜ Google ì•¡ì„¸ìŠ¤ í† í°
/
export function createGmailClient(accessToken: string) {
const oauth2Client = new google.auth.OAuth2(
process.env.GOOGLE_CLIENT_ID,
process.env.GOOGLE_CLIENT_SECRET
)

oauth2Client.setCredentials({
access_token: accessToken
})

return google.gmail({ version: 'v1', auth: oauth2Client })
}

/\*\*
ì—¬í–‰ ê´€ë ¨ ì´ë©”ì¼ì„ ê²€ìƒ‰í•©ë‹ˆë‹¤.
@param accessToken ì‚¬ìš©ìì˜ Google ì•¡ì„¸ìŠ¤ í† í°
@param maxResults ìµœëŒ€ ê²°ê³¼ ìˆ˜ (ê¸°ë³¸ê°’: 50)
/
export async function searchTravelEmails(
accessToken: string,
maxResults: number = 50
): Promise<EmailMessage[]> {
try {
const gmail = createGmailClient(accessToken)

      // ê³ ê¸‰ ì—¬í–‰ ê´€ë ¨ í‚¤ì›Œë“œë¡œ ê²€ìƒ‰ (í•œêµ­ì–´/ì˜ì–´ ì§€ì›)
    const searchQuery = [
      // í•­ê³µí¸ ê´€ë ¨
      'subject:(flight OR í•­ê³µí¸ OR í•­ê³µê¶Œ OR eticket OR "boarding pass" OR "íƒ‘ìŠ¹ê¶Œ")',
      'subject:(booking OR reservation OR confirmation OR ì˜ˆì•½ OR í™•ì¸)',
      'subject:(itinerary OR schedule OR ì¼ì •)',

      // í˜¸í…” ê´€ë ¨
      'subject:(hotel OR accommodation OR í˜¸í…” OR ìˆ™ë°•)',
      'subject:("check-in" OR "check-out" OR ì²´í¬ì¸ OR ì²´í¬ì•„ì›ƒ)',

      // ì£¼ìš” í•­ê³µì‚¬
      'from:(koreanair.com OR flyasiana.com OR jejuair.net)',
      'from:(united.com OR delta.com OR jal.com OR ana.co.jp)',

      // ì£¼ìš” ì˜ˆì•½ í”Œë«í¼
      'from:(booking.com OR expedia.com OR agoda.com OR hotels.com)',
      'from:(kayak.com OR priceline.com OR orbitz.com)',
      'from:(airbnb.com OR vrbo.com)',

      // ë Œí„°ì¹´
      'from:(hertz.com OR avis.com OR enterprise.com OR budget.com)',

      // ì—¬í–‰ì‚¬
      'from:(expedia.com OR travelocity.com OR orbitz.com)',

      // ì¼ë°˜ì ì¸ ì—¬í–‰ ê´€ë ¨ í‚¤ì›Œë“œ
      'subject:(trip OR travel OR vacation OR ì—¬í–‰ OR ì¶œì¥)',
      'subject:(departure OR arrival OR ì¶œë°œ OR ë„ì°©)'
    ].join(' OR ')

    const response = await gmail.users.messages.list({
      userId: 'me',
      q: searchQuery,
      maxResults
    })

    if (!response.data.messages) {
      return []
    }

    // ê° ë©”ì‹œì§€ì˜ ìƒì„¸ ì •ë³´ë¥¼ ê°€ì ¸ì˜¤ê¸°
    const messages: EmailMessage[] = []

    for (const message of response.data.messages.slice(0, maxResults)) {
      try {
        const messageDetail = await gmail.users.messages.get({
          userId: 'me',
          id: message.id!,
          format: 'full'
        })

        const headers = messageDetail.data.payload?.headers || []
        const subject = headers.find(h => h.name === 'Subject')?.value || 'No Subject'
        const from = headers.find(h => h.name === 'From')?.value || 'Unknown Sender'
        const to = headers.find(h => h.name === 'To')?.value || 'Unknown Recipient'
        const date = headers.find(h => h.name === 'Date')?.value || 'Unknown Date'

        // ì´ë©”ì¼ ë³¸ë¬¸ ì¶”ì¶œ
        let body = ''
        const payload = messageDetail.data.payload

        if (payload?.parts) {
          // ë©€í‹°íŒŒíŠ¸ ë©”ì‹œì§€
          for (const part of payload.parts) {
            if (part.mimeType === 'text/plain' && part.body?.data) {
              body += Buffer.from(part.body.data, 'base64').toString('utf-8')
            }
          }
        } else if (payload?.body?.data) {
          // ë‹¨ì¼ íŒŒíŠ¸ ë©”ì‹œì§€
          body = Buffer.from(payload.body.data, 'base64').toString('utf-8')
        }

        messages.push({
          id: message.id!,
          subject,
          from,
          to,
          date,
          body,
          snippet: messageDetail.data.snippet || ''
        })
      } catch (error) {
        // Error fetching message
        // ê°œë³„ ë©”ì‹œì§€ ì˜¤ë¥˜ëŠ” ê±´ë„ˆë›°ê³  ê³„ì† ì§„í–‰
      }
    }

    return messages

} catch (error) {
// Error searching travel emails
throw new Error('Gmail API ìš”ì²­ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.')
}
}

/\*\*
ê³ ê¸‰ ì—¬í–‰ ì •ë³´ ì¶”ì¶œ í•¨ìˆ˜
@param email ì´ë©”ì¼ ë©”ì‹œì§€
/
export function extractTravelInfo(email: EmailMessage): TravelInfo | null {
const fullText = `${email.subject} ${email.body} ${email.snippet}`
const normalizedText = fullText.toLowerCase()

// ê¸°ë³¸ ì—¬í–‰ ì •ë³´ ê°ì²´
const travelInfo: TravelInfo = {
emailId: email.id,
subject: email.subject,
from: email.from,
confidence: 0,
extractedData: {
dates: [],
airports: [],
flights: [],
bookingCodes: [],
matchedPatterns: []
}
}

// íŒ¨í„´ ë§¤ì¹­ìœ¼ë¡œ ì´ë©”ì¼ ì¹´í…Œê³ ë¦¬ ë° ê°€ì¤‘ì¹˜ ê²°ì •
let matchedPattern: TravelEmailPattern | null = null
let maxWeight = 0

for (const pattern of allTravelPatterns) {
let patternScore = 0

    // ë°œì‹ ì íŒ¨í„´ í™•ì¸
    for (const senderPattern of pattern.senderPatterns) {
      if (senderPattern.test(email.from)) {
        patternScore += 0.4
        travelInfo.extractedData.matchedPatterns.push(`sender:${pattern.name}`)
        break
      }
    }

    // ì œëª© íŒ¨í„´ í™•ì¸
    for (const subjectPattern of pattern.subjectPatterns) {
      if (subjectPattern.test(email.subject)) {
        patternScore += 0.3
        travelInfo.extractedData.matchedPatterns.push(`subject:${pattern.name}`)
        break
      }
    }

    // ë³¸ë¬¸ íŒ¨í„´ í™•ì¸
    for (const bodyPattern of pattern.bodyPatterns) {
      if (bodyPattern.test(normalizedText)) {
        patternScore += 0.3
        travelInfo.extractedData.matchedPatterns.push(`body:${pattern.name}`)
        break
      }
    }

    const weightedScore = patternScore * pattern.weight
    if (weightedScore > maxWeight) {
      maxWeight = weightedScore
      matchedPattern = pattern
      travelInfo.category = pattern.category
    }

}

// ê¸°ë³¸ ì‹ ë¢°ë„ ì„¤ì •
travelInfo.confidence = maxWeight

// íŠ¹í™”ëœ ì •ë³´ ì¶”ì¶œ
if (matchedPattern?.extractors) {
extractSpecializedInfo(fullText, normalizedText, matchedPattern, travelInfo)
}

// ì¼ë°˜ì ì¸ ì •ë³´ ì¶”ì¶œ (ëª¨ë“  ì´ë©”ì¼ì— ì ìš©)
extractGeneralTravelInfo(fullText, normalizedText, travelInfo)

// ì¶”ì¶œëœ ë°ì´í„° ê¸°ë°˜ ì‹ ë¢°ë„ ì¡°ì •
adjustConfidenceBasedOnExtractedData(travelInfo)

// ì‹ ë¢°ë„ê°€ ë„ˆë¬´ ë‚®ìœ¼ë©´ null ë°˜í™˜
if (travelInfo.confidence < 0.2) {
return null
}

return travelInfo
}

/\*\*
íŠ¹í™”ëœ íŒ¨í„´ ê¸°ë°˜ ì •ë³´ ì¶”ì¶œ
/
function extractSpecializedInfo(
fullText: string,
normalizedText: string,
pattern: TravelEmailPattern,
travelInfo: TravelInfo
) {
const extractors = pattern.extractors

// í•­ê³µí¸ ë²ˆí˜¸ ì¶”ì¶œ
if (extractors.flights) {
for (const flightPattern of extractors.flights) {
const matches = fullText.match(flightPattern)
if (matches) {
travelInfo.extractedData.flights.push(...matches.map(m => m.toUpperCase()))
if (!travelInfo.flightNumber) {
travelInfo.flightNumber = matches[0].toUpperCase()
}
}
}
}

// ì˜ˆì•½ ë²ˆí˜¸ ì¶”ì¶œ
if (extractors.bookingReference) {
for (const bookingPattern of extractors.bookingReference) {
const matches = fullText.match(bookingPattern)
if (matches && matches.length >= 2) {
travelInfo.extractedData.bookingCodes.push(matches[1])
if (!travelInfo.bookingReference) {
travelInfo.bookingReference = matches[1]
}
}
}
}

// ê³µí•­ ì½”ë“œ ì¶”ì¶œ
if (extractors.airports) {
for (const airportPattern of extractors.airports) {
const matches = fullText.match(airportPattern)
if (matches) {
const airports = matches.filter(code => code in airportCodes)
travelInfo.extractedData.airports.push(...airports)
if (airports.length >= 2 && !travelInfo.departure) {
travelInfo.departure = airports[0]
travelInfo.destination = airports[1]
}
}
}
}

// ë‚ ì§œ ì¶”ì¶œ
if (extractors.dates) {
for (const datePattern of extractors.dates) {
const matches = fullText.match(datePattern)
if (matches) {
travelInfo.extractedData.dates.push(...matches)
}
}
}
}

/\*\*
ì¼ë°˜ì ì¸ ì—¬í–‰ ì •ë³´ ì¶”ì¶œ (ëª¨ë“  ì´ë©”ì¼ì— ì ìš©)
/
function extractGeneralTravelInfo(
fullText: string,
normalizedText: string,
travelInfo: TravelInfo
) {
// ë‚ ì§œ íŒ¨í„´ ê²€ìƒ‰
for (const datePattern of datePatterns) {
const matches = fullText.match(datePattern)
if (matches) {
travelInfo.extractedData.dates.push(...matches)
}
}

// í•­ê³µí¸ ë²ˆí˜¸ ì¼ë°˜ íŒ¨í„´
const generalFlightPattern = /\b([A-Z]{2,3})\s\*(\d{3,4})\b/g
const flightMatches = fullText.match(generalFlightPattern)
if (flightMatches) {
const validFlights = flightMatches.filter(flight => {
const airlineCode = flight.match(/^([A-Z]{2,3})/)?.[1]
return airlineCode && airlineCode in airlineCodes
})
travelInfo.extractedData.flights.push(...validFlights.map(f => f.toUpperCase()))
}

// ê³µí•­ ì½”ë“œ ì¼ë°˜ íŒ¨í„´
const generalAirportPattern = /\b([A-Z]{3})\b/g
const airportMatches = fullText.match(generalAirportPattern)
if (airportMatches) {
const validAirports = airportMatches.filter(code => code in airportCodes)
travelInfo.extractedData.airports.push(...validAirports)
}

// ì˜ˆì•½ ë²ˆí˜¸ ì¼ë°˜ íŒ¨í„´
const generalBookingPatterns = [
/(confirmation|booking|reference|reservation)\s*(?:number|code|id)?[:\s]*([A-Z0-9]{6,})/gi,
/(ì˜ˆì•½|í™•ì¸)\s*(?:ë²ˆí˜¸|ì½”ë“œ)?[:\s]*([A-Z0-9]{6,})/gi,
/PNR[:\s]\*([A-Z0-9]{6,})/gi
]

for (const pattern of generalBookingPatterns) {
const matches = fullText.match(pattern)
if (matches) {
matches.forEach(match => {
const code = match.match(/([A-Z0-9]{6,})$/)?.[1]
if (code) {
travelInfo.extractedData.bookingCodes.push(code)
}
})
}
}

// ìŠ¹ê° ì´ë¦„ ì¶”ì¶œ (ì¼ë°˜ì ì¸ íŒ¨í„´)
const passengerPatterns = [
/passenger[:\s]_([A-Z][a-z]+\s+[A-Z][a-z]+)/gi,
/ìŠ¹ê°[:\s]_([ê°€-í£]+\s*[ê°€-í£]+)/gi,
/traveler[:\s]*([A-Z][a-z]+\s+[A-Z][a-z]+)/gi
]

for (const pattern of passengerPatterns) {
const match = fullText.match(pattern)
if (match && match.length >= 2 && !travelInfo.passengerName) {
travelInfo.passengerName = match[1].trim()
break
}
}

// í˜¸í…” ì´ë¦„ ì¶”ì¶œ
const hotelPatterns = [
/hotel[:\s]_([A-Za-z\s&]+?)(?:\n|\r|,|\.)/gi,
/(?:staying at|accommodation)[:\s]_([A-Za-z\s&]+?)(?:\n|\r|,|\.)/gi
]

for (const pattern of hotelPatterns) {
const match = fullText.match(pattern)
if (match && match.length >= 2 && !travelInfo.hotelName) {
travelInfo.hotelName = match[1].trim()
break
}
}
}

/\*\*
ì¶”ì¶œëœ ë°ì´í„°ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì‹ ë¢°ë„ ì¡°ì •
/
function adjustConfidenceBasedOnExtractedData(travelInfo: TravelInfo) {
const extracted = travelInfo.extractedData

// ì¶”ì¶œëœ ë°ì´í„°ì— ë”°ë¥¸ ë³´ë„ˆìŠ¤ ì ìˆ˜
if (extracted.flights.length > 0) {
travelInfo.confidence += 0.2
if (!travelInfo.flightNumber && extracted.flights.length > 0) {
travelInfo.flightNumber = extracted.flights[0]
}
}

if (extracted.airports.length >= 2) {
travelInfo.confidence += 0.15
if (!travelInfo.departure && !travelInfo.destination) {
travelInfo.departure = extracted.airports[0]
travelInfo.destination = extracted.airports[1]
}
}

if (extracted.dates.length >= 1) {
travelInfo.confidence += 0.1
if (!travelInfo.departureDate) {
travelInfo.departureDate = extracted.dates[0]
}
if (extracted.dates.length >= 2 && !travelInfo.returnDate) {
travelInfo.returnDate = extracted.dates[1]
}
}

if (extracted.bookingCodes.length > 0) {
travelInfo.confidence += 0.1
if (!travelInfo.bookingReference) {
travelInfo.bookingReference = extracted.bookingCodes[0]
}
}

// ë§¤ì¹˜ëœ íŒ¨í„´ ìˆ˜ì— ë”°ë¥¸ ë³´ë„ˆìŠ¤
if (extracted.matchedPatterns.length > 1) {
travelInfo.confidence += 0.05 \* (extracted.matchedPatterns.length - 1)
}

// ìµœëŒ€ ì‹ ë¢°ë„ ì œí•œ
travelInfo.confidence = Math.min(travelInfo.confidence, 1.0)
}

/\*\*
ê³ ê¸‰ ì—¬í–‰ ì´ë©”ì¼ ë¶„ì„ - ì§€ëŠ¥í˜• íŒ¨í„´ ë§¤ì¹­ ë° ì¤‘ë³µ ì œê±°
@param accessToken ì‚¬ìš©ìì˜ Google ì•¡ì„¸ìŠ¤ í† í°
@param maxResults ìµœëŒ€ ê²€ìƒ‰ ê²°ê³¼ ìˆ˜

**íŠ¹ì„±:** `exported`, `async`

#### `checkGmailConnection`

Gmail API í´ë¼ì´ì–¸íŠ¸ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
@param accessToken ì‚¬ìš©ìì˜ Google ì•¡ì„¸ìŠ¤ í† í°
/
export function createGmailClient(accessToken: string) {
const oauth2Client = new google.auth.OAuth2(
process.env.GOOGLE_CLIENT_ID,
process.env.GOOGLE_CLIENT_SECRET
)

oauth2Client.setCredentials({
access_token: accessToken
})

return google.gmail({ version: 'v1', auth: oauth2Client })
}

/\*\*
ì—¬í–‰ ê´€ë ¨ ì´ë©”ì¼ì„ ê²€ìƒ‰í•©ë‹ˆë‹¤.
@param accessToken ì‚¬ìš©ìì˜ Google ì•¡ì„¸ìŠ¤ í† í°
@param maxResults ìµœëŒ€ ê²°ê³¼ ìˆ˜ (ê¸°ë³¸ê°’: 50)
/
export async function searchTravelEmails(
accessToken: string,
maxResults: number = 50
): Promise<EmailMessage[]> {
try {
const gmail = createGmailClient(accessToken)

      // ê³ ê¸‰ ì—¬í–‰ ê´€ë ¨ í‚¤ì›Œë“œë¡œ ê²€ìƒ‰ (í•œêµ­ì–´/ì˜ì–´ ì§€ì›)
    const searchQuery = [
      // í•­ê³µí¸ ê´€ë ¨
      'subject:(flight OR í•­ê³µí¸ OR í•­ê³µê¶Œ OR eticket OR "boarding pass" OR "íƒ‘ìŠ¹ê¶Œ")',
      'subject:(booking OR reservation OR confirmation OR ì˜ˆì•½ OR í™•ì¸)',
      'subject:(itinerary OR schedule OR ì¼ì •)',

      // í˜¸í…” ê´€ë ¨
      'subject:(hotel OR accommodation OR í˜¸í…” OR ìˆ™ë°•)',
      'subject:("check-in" OR "check-out" OR ì²´í¬ì¸ OR ì²´í¬ì•„ì›ƒ)',

      // ì£¼ìš” í•­ê³µì‚¬
      'from:(koreanair.com OR flyasiana.com OR jejuair.net)',
      'from:(united.com OR delta.com OR jal.com OR ana.co.jp)',

      // ì£¼ìš” ì˜ˆì•½ í”Œë«í¼
      'from:(booking.com OR expedia.com OR agoda.com OR hotels.com)',
      'from:(kayak.com OR priceline.com OR orbitz.com)',
      'from:(airbnb.com OR vrbo.com)',

      // ë Œí„°ì¹´
      'from:(hertz.com OR avis.com OR enterprise.com OR budget.com)',

      // ì—¬í–‰ì‚¬
      'from:(expedia.com OR travelocity.com OR orbitz.com)',

      // ì¼ë°˜ì ì¸ ì—¬í–‰ ê´€ë ¨ í‚¤ì›Œë“œ
      'subject:(trip OR travel OR vacation OR ì—¬í–‰ OR ì¶œì¥)',
      'subject:(departure OR arrival OR ì¶œë°œ OR ë„ì°©)'
    ].join(' OR ')

    const response = await gmail.users.messages.list({
      userId: 'me',
      q: searchQuery,
      maxResults
    })

    if (!response.data.messages) {
      return []
    }

    // ê° ë©”ì‹œì§€ì˜ ìƒì„¸ ì •ë³´ë¥¼ ê°€ì ¸ì˜¤ê¸°
    const messages: EmailMessage[] = []

    for (const message of response.data.messages.slice(0, maxResults)) {
      try {
        const messageDetail = await gmail.users.messages.get({
          userId: 'me',
          id: message.id!,
          format: 'full'
        })

        const headers = messageDetail.data.payload?.headers || []
        const subject = headers.find(h => h.name === 'Subject')?.value || 'No Subject'
        const from = headers.find(h => h.name === 'From')?.value || 'Unknown Sender'
        const to = headers.find(h => h.name === 'To')?.value || 'Unknown Recipient'
        const date = headers.find(h => h.name === 'Date')?.value || 'Unknown Date'

        // ì´ë©”ì¼ ë³¸ë¬¸ ì¶”ì¶œ
        let body = ''
        const payload = messageDetail.data.payload

        if (payload?.parts) {
          // ë©€í‹°íŒŒíŠ¸ ë©”ì‹œì§€
          for (const part of payload.parts) {
            if (part.mimeType === 'text/plain' && part.body?.data) {
              body += Buffer.from(part.body.data, 'base64').toString('utf-8')
            }
          }
        } else if (payload?.body?.data) {
          // ë‹¨ì¼ íŒŒíŠ¸ ë©”ì‹œì§€
          body = Buffer.from(payload.body.data, 'base64').toString('utf-8')
        }

        messages.push({
          id: message.id!,
          subject,
          from,
          to,
          date,
          body,
          snippet: messageDetail.data.snippet || ''
        })
      } catch (error) {
        // Error fetching message
        // ê°œë³„ ë©”ì‹œì§€ ì˜¤ë¥˜ëŠ” ê±´ë„ˆë›°ê³  ê³„ì† ì§„í–‰
      }
    }

    return messages

} catch (error) {
// Error searching travel emails
throw new Error('Gmail API ìš”ì²­ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.')
}
}

/\*\*
ê³ ê¸‰ ì—¬í–‰ ì •ë³´ ì¶”ì¶œ í•¨ìˆ˜
@param email ì´ë©”ì¼ ë©”ì‹œì§€
/
export function extractTravelInfo(email: EmailMessage): TravelInfo | null {
const fullText = `${email.subject} ${email.body} ${email.snippet}`
const normalizedText = fullText.toLowerCase()

// ê¸°ë³¸ ì—¬í–‰ ì •ë³´ ê°ì²´
const travelInfo: TravelInfo = {
emailId: email.id,
subject: email.subject,
from: email.from,
confidence: 0,
extractedData: {
dates: [],
airports: [],
flights: [],
bookingCodes: [],
matchedPatterns: []
}
}

// íŒ¨í„´ ë§¤ì¹­ìœ¼ë¡œ ì´ë©”ì¼ ì¹´í…Œê³ ë¦¬ ë° ê°€ì¤‘ì¹˜ ê²°ì •
let matchedPattern: TravelEmailPattern | null = null
let maxWeight = 0

for (const pattern of allTravelPatterns) {
let patternScore = 0

    // ë°œì‹ ì íŒ¨í„´ í™•ì¸
    for (const senderPattern of pattern.senderPatterns) {
      if (senderPattern.test(email.from)) {
        patternScore += 0.4
        travelInfo.extractedData.matchedPatterns.push(`sender:${pattern.name}`)
        break
      }
    }

    // ì œëª© íŒ¨í„´ í™•ì¸
    for (const subjectPattern of pattern.subjectPatterns) {
      if (subjectPattern.test(email.subject)) {
        patternScore += 0.3
        travelInfo.extractedData.matchedPatterns.push(`subject:${pattern.name}`)
        break
      }
    }

    // ë³¸ë¬¸ íŒ¨í„´ í™•ì¸
    for (const bodyPattern of pattern.bodyPatterns) {
      if (bodyPattern.test(normalizedText)) {
        patternScore += 0.3
        travelInfo.extractedData.matchedPatterns.push(`body:${pattern.name}`)
        break
      }
    }

    const weightedScore = patternScore * pattern.weight
    if (weightedScore > maxWeight) {
      maxWeight = weightedScore
      matchedPattern = pattern
      travelInfo.category = pattern.category
    }

}

// ê¸°ë³¸ ì‹ ë¢°ë„ ì„¤ì •
travelInfo.confidence = maxWeight

// íŠ¹í™”ëœ ì •ë³´ ì¶”ì¶œ
if (matchedPattern?.extractors) {
extractSpecializedInfo(fullText, normalizedText, matchedPattern, travelInfo)
}

// ì¼ë°˜ì ì¸ ì •ë³´ ì¶”ì¶œ (ëª¨ë“  ì´ë©”ì¼ì— ì ìš©)
extractGeneralTravelInfo(fullText, normalizedText, travelInfo)

// ì¶”ì¶œëœ ë°ì´í„° ê¸°ë°˜ ì‹ ë¢°ë„ ì¡°ì •
adjustConfidenceBasedOnExtractedData(travelInfo)

// ì‹ ë¢°ë„ê°€ ë„ˆë¬´ ë‚®ìœ¼ë©´ null ë°˜í™˜
if (travelInfo.confidence < 0.2) {
return null
}

return travelInfo
}

/\*\*
íŠ¹í™”ëœ íŒ¨í„´ ê¸°ë°˜ ì •ë³´ ì¶”ì¶œ
/
function extractSpecializedInfo(
fullText: string,
normalizedText: string,
pattern: TravelEmailPattern,
travelInfo: TravelInfo
) {
const extractors = pattern.extractors

// í•­ê³µí¸ ë²ˆí˜¸ ì¶”ì¶œ
if (extractors.flights) {
for (const flightPattern of extractors.flights) {
const matches = fullText.match(flightPattern)
if (matches) {
travelInfo.extractedData.flights.push(...matches.map(m => m.toUpperCase()))
if (!travelInfo.flightNumber) {
travelInfo.flightNumber = matches[0].toUpperCase()
}
}
}
}

// ì˜ˆì•½ ë²ˆí˜¸ ì¶”ì¶œ
if (extractors.bookingReference) {
for (const bookingPattern of extractors.bookingReference) {
const matches = fullText.match(bookingPattern)
if (matches && matches.length >= 2) {
travelInfo.extractedData.bookingCodes.push(matches[1])
if (!travelInfo.bookingReference) {
travelInfo.bookingReference = matches[1]
}
}
}
}

// ê³µí•­ ì½”ë“œ ì¶”ì¶œ
if (extractors.airports) {
for (const airportPattern of extractors.airports) {
const matches = fullText.match(airportPattern)
if (matches) {
const airports = matches.filter(code => code in airportCodes)
travelInfo.extractedData.airports.push(...airports)
if (airports.length >= 2 && !travelInfo.departure) {
travelInfo.departure = airports[0]
travelInfo.destination = airports[1]
}
}
}
}

// ë‚ ì§œ ì¶”ì¶œ
if (extractors.dates) {
for (const datePattern of extractors.dates) {
const matches = fullText.match(datePattern)
if (matches) {
travelInfo.extractedData.dates.push(...matches)
}
}
}
}

/\*\*
ì¼ë°˜ì ì¸ ì—¬í–‰ ì •ë³´ ì¶”ì¶œ (ëª¨ë“  ì´ë©”ì¼ì— ì ìš©)
/
function extractGeneralTravelInfo(
fullText: string,
normalizedText: string,
travelInfo: TravelInfo
) {
// ë‚ ì§œ íŒ¨í„´ ê²€ìƒ‰
for (const datePattern of datePatterns) {
const matches = fullText.match(datePattern)
if (matches) {
travelInfo.extractedData.dates.push(...matches)
}
}

// í•­ê³µí¸ ë²ˆí˜¸ ì¼ë°˜ íŒ¨í„´
const generalFlightPattern = /\b([A-Z]{2,3})\s\*(\d{3,4})\b/g
const flightMatches = fullText.match(generalFlightPattern)
if (flightMatches) {
const validFlights = flightMatches.filter(flight => {
const airlineCode = flight.match(/^([A-Z]{2,3})/)?.[1]
return airlineCode && airlineCode in airlineCodes
})
travelInfo.extractedData.flights.push(...validFlights.map(f => f.toUpperCase()))
}

// ê³µí•­ ì½”ë“œ ì¼ë°˜ íŒ¨í„´
const generalAirportPattern = /\b([A-Z]{3})\b/g
const airportMatches = fullText.match(generalAirportPattern)
if (airportMatches) {
const validAirports = airportMatches.filter(code => code in airportCodes)
travelInfo.extractedData.airports.push(...validAirports)
}

// ì˜ˆì•½ ë²ˆí˜¸ ì¼ë°˜ íŒ¨í„´
const generalBookingPatterns = [
/(confirmation|booking|reference|reservation)\s*(?:number|code|id)?[:\s]*([A-Z0-9]{6,})/gi,
/(ì˜ˆì•½|í™•ì¸)\s*(?:ë²ˆí˜¸|ì½”ë“œ)?[:\s]*([A-Z0-9]{6,})/gi,
/PNR[:\s]\*([A-Z0-9]{6,})/gi
]

for (const pattern of generalBookingPatterns) {
const matches = fullText.match(pattern)
if (matches) {
matches.forEach(match => {
const code = match.match(/([A-Z0-9]{6,})$/)?.[1]
if (code) {
travelInfo.extractedData.bookingCodes.push(code)
}
})
}
}

// ìŠ¹ê° ì´ë¦„ ì¶”ì¶œ (ì¼ë°˜ì ì¸ íŒ¨í„´)
const passengerPatterns = [
/passenger[:\s]_([A-Z][a-z]+\s+[A-Z][a-z]+)/gi,
/ìŠ¹ê°[:\s]_([ê°€-í£]+\s*[ê°€-í£]+)/gi,
/traveler[:\s]*([A-Z][a-z]+\s+[A-Z][a-z]+)/gi
]

for (const pattern of passengerPatterns) {
const match = fullText.match(pattern)
if (match && match.length >= 2 && !travelInfo.passengerName) {
travelInfo.passengerName = match[1].trim()
break
}
}

// í˜¸í…” ì´ë¦„ ì¶”ì¶œ
const hotelPatterns = [
/hotel[:\s]_([A-Za-z\s&]+?)(?:\n|\r|,|\.)/gi,
/(?:staying at|accommodation)[:\s]_([A-Za-z\s&]+?)(?:\n|\r|,|\.)/gi
]

for (const pattern of hotelPatterns) {
const match = fullText.match(pattern)
if (match && match.length >= 2 && !travelInfo.hotelName) {
travelInfo.hotelName = match[1].trim()
break
}
}
}

/\*\*
ì¶”ì¶œëœ ë°ì´í„°ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì‹ ë¢°ë„ ì¡°ì •
/
function adjustConfidenceBasedOnExtractedData(travelInfo: TravelInfo) {
const extracted = travelInfo.extractedData

// ì¶”ì¶œëœ ë°ì´í„°ì— ë”°ë¥¸ ë³´ë„ˆìŠ¤ ì ìˆ˜
if (extracted.flights.length > 0) {
travelInfo.confidence += 0.2
if (!travelInfo.flightNumber && extracted.flights.length > 0) {
travelInfo.flightNumber = extracted.flights[0]
}
}

if (extracted.airports.length >= 2) {
travelInfo.confidence += 0.15
if (!travelInfo.departure && !travelInfo.destination) {
travelInfo.departure = extracted.airports[0]
travelInfo.destination = extracted.airports[1]
}
}

if (extracted.dates.length >= 1) {
travelInfo.confidence += 0.1
if (!travelInfo.departureDate) {
travelInfo.departureDate = extracted.dates[0]
}
if (extracted.dates.length >= 2 && !travelInfo.returnDate) {
travelInfo.returnDate = extracted.dates[1]
}
}

if (extracted.bookingCodes.length > 0) {
travelInfo.confidence += 0.1
if (!travelInfo.bookingReference) {
travelInfo.bookingReference = extracted.bookingCodes[0]
}
}

// ë§¤ì¹˜ëœ íŒ¨í„´ ìˆ˜ì— ë”°ë¥¸ ë³´ë„ˆìŠ¤
if (extracted.matchedPatterns.length > 1) {
travelInfo.confidence += 0.05 \* (extracted.matchedPatterns.length - 1)
}

// ìµœëŒ€ ì‹ ë¢°ë„ ì œí•œ
travelInfo.confidence = Math.min(travelInfo.confidence, 1.0)
}

/\*\*
ê³ ê¸‰ ì—¬í–‰ ì´ë©”ì¼ ë¶„ì„ - ì§€ëŠ¥í˜• íŒ¨í„´ ë§¤ì¹­ ë° ì¤‘ë³µ ì œê±°
@param accessToken ì‚¬ìš©ìì˜ Google ì•¡ì„¸ìŠ¤ í† í°
@param maxResults ìµœëŒ€ ê²€ìƒ‰ ê²°ê³¼ ìˆ˜
/
export async function analyzeTravelEmails(
accessToken: string,
maxResults: number = 20
): Promise<TravelInfo[]> {
try {
const emails = await searchTravelEmails(accessToken, maxResults)
const travelInfos: TravelInfo[] = []

    for (const email of emails) {
      const travelInfo = extractTravelInfo(email)
      if (travelInfo) {
        // ì´ë©”ì¼ ì»¨í…ìŠ¤íŠ¸ ì •ë³´ ì¶”ê°€
        const emailContext = {
          senderDomain: email.from.split('@')[1] || '',
          hasMultipleBookings: email.body.toLowerCase().split('booking').length > 2,
          isForwardedEmail: email.subject.toLowerCase().includes('fwd:') || email.subject.toLowerCase().includes('fw:'),
          hasAttachments: false // Gmail APIì—ì„œ ì²¨ë¶€íŒŒì¼ ì •ë³´ í™•ì¸ í•„ìš”
        }

        // ì»¨í…ìŠ¤íŠ¸ ê¸°ë°˜ ì‹ ë¢°ë„ ì¡°ì • (email-intelligence ë¼ì´ë¸ŒëŸ¬ë¦¬ ì‚¬ìš©)
        // travelInfo.confidence = adjustConfidenceByContext(travelInfo, emailContext)

        travelInfos.push(travelInfo)
      }
    }

    // ì§€ëŠ¥í˜• ì¤‘ë³µ ì œê±° ë° ë³‘í•© (í–¥í›„ êµ¬í˜„)
    // const mergedInfos = deduplicateAndMergeTravelInfo(travelInfos)

    // ìš°ì„ ìˆœìœ„ ì •ë ¬ (í–¥í›„ êµ¬í˜„)
    // return prioritizeTravelInfo(mergedInfos)

    // í˜„ì¬ëŠ” ê¸°ë³¸ ì‹ ë¢°ë„ ìˆœìœ¼ë¡œ ì •ë ¬
    return travelInfos.sort((a, b) => b.confidence - a.confidence)

} catch (error) {
// Error analyzing travel emails
throw new Error('ì´ë©”ì¼ ë¶„ì„ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.')
}
}

/\*\*
Gmail API ì—°ê²° ìƒíƒœë¥¼ í™•ì¸í•©ë‹ˆë‹¤.
@param accessToken ì‚¬ìš©ìì˜ Google ì•¡ì„¸ìŠ¤ í† í°

**íŠ¹ì„±:** `exported`, `async`

### ğŸ”— Interfaces

#### `EmailMessage`

**íŠ¹ì„±:** `exported`

#### `TravelInfo`

**íŠ¹ì„±:** `exported`

## i18n.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/i18n.ts`

**ì„¤ëª…:** Simple i18n system for DINO

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 6818 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 350
- ğŸ”§ í•¨ìˆ˜: 4ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 1ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 1ê°œ

**Exports:**

- `getCurrentLocale`
- `setLocale`
- `getSupportedLocales`
- `t`
- `type`

### ğŸ”§ Functions

#### `getCurrentLocale`

**íŠ¹ì„±:** `exported`

#### `setLocale`

**íŠ¹ì„±:** `exported`

#### `getSupportedLocales`

**íŠ¹ì„±:** `exported`

#### `t`

**íŠ¹ì„±:** `exported`

### ğŸ”— Interfaces

#### `Translations`

### ğŸ·ï¸ Types

- `Locale`

## performance.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/middleware/performance.ts`

**ì„¤ëª…:** Performance middleware for API routes
Provides caching, compression, rate limiting, and monitoring

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 10621 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 373
- ğŸ”§ í•¨ìˆ˜: 6ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 1ê°œ

**Exports:**

- `performanceMiddleware`
- `compressJSON`
- `withPerformance`
- `optimizeQuery`
- `async`

### ğŸ”§ Functions

#### `performanceMiddleware`

**íŠ¹ì„±:** `exported`

#### `processJSONResponse`

**íŠ¹ì„±:** `async`

#### `generateCacheKey`

#### `getClientIP`

#### `recordMetrics`

#### `compressJSON`

**íŠ¹ì„±:** `exported`

### ğŸ”— Interfaces

#### `PerformanceMiddlewareOptions`

## alerts-v2.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/monitoring/alerts-v2.ts`

**ì„¤ëª…:** Simplified alerts module for testing

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 5726 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 214
- ğŸ”§ í•¨ìˆ˜: 0ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 1ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 4ê°œ

**Exports:**

- `enum`
- `Alert`
- `AlertChannel`
- `AlertRule`
- `AlertConfig`
- `AlertManager`

### ğŸ“¦ Classes

#### `AlertManager`

**íŠ¹ì„±:** `exported`

### ğŸ”— Interfaces

#### `Alert`

**íŠ¹ì„±:** `exported`

#### `AlertChannel`

**íŠ¹ì„±:** `exported`

#### `AlertRule`

**íŠ¹ì„±:** `exported`

#### `AlertConfig`

**íŠ¹ì„±:** `exported`

## alerts.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/monitoring/alerts.ts`

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 6081 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 235
- ğŸ”§ í•¨ìˆ˜: 6ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 2ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 1ê°œ

**Exports:**

- `AlertType`
- `AlertCategory`
- `alertThresholds`
- `async`
- `checkPerformanceAlerts`
- `checkSecurityAlerts`
- `checkUsageAlerts`
- `startAlertMonitoring`

### ğŸ”§ Functions

#### `sendAlert`

**íŠ¹ì„±:** `exported`, `async`

#### `checkPerformanceAlerts`

**íŠ¹ì„±:** `exported`

#### `checkSecurityAlerts`

**íŠ¹ì„±:** `exported`

#### `checkUsageAlerts`

**íŠ¹ì„±:** `exported`

#### `logAlert`

**íŠ¹ì„±:** `async`

#### `startAlertMonitoring`

**íŠ¹ì„±:** `exported`

### ğŸ”— Interfaces

#### `Alert`

### ğŸ·ï¸ Types

- `AlertType` (exported)
- `AlertCategory` (exported)

## logger.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/monitoring/logger.ts`

**ì„¤ëª…:** Structured Logging System
Provides consistent logging with different levels and structured data

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 6299 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 249
- ğŸ”§ í•¨ìˆ˜: 1ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 1ê°œ
- ğŸ·ï¸ íƒ€ì…: 1ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 2ê°œ

**Exports:**

- `LogLevel`
- `LogContext`
- `LogEntry`
- `Logger`
- `loggers`
- `createRequestLogger`

### ğŸ”§ Functions

#### `createRequestLogger`

**íŠ¹ì„±:** `exported`

### ğŸ“¦ Classes

#### `Logger`

**íŠ¹ì„±:** `exported`

### ğŸ”— Interfaces

#### `LogContext`

**íŠ¹ì„±:** `exported`

#### `LogEntry`

**íŠ¹ì„±:** `exported`

### ğŸ·ï¸ Types

- `LogLevel` (exported)

## metrics-collector-v2.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/monitoring/metrics-collector-v2.ts`

**ì„¤ëª…:** New metrics collector for testing

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 4423 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 190
- ğŸ”§ í•¨ìˆ˜: 0ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 1ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 4ê°œ

**Exports:**

- `enum`
- `Metric`
- `MetricsStorage`
- `MetricsConfig`
- `MetricsCollector`

### ğŸ“¦ Classes

#### `MetricsCollector`

**íŠ¹ì„±:** `exported`

### ğŸ”— Interfaces

#### `Metric`

**íŠ¹ì„±:** `exported`

#### `MetricsStorage`

**íŠ¹ì„±:** `exported`

#### `MetricsConfig`

**íŠ¹ì„±:** `exported`

#### `Timer`

## metrics-collector.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/monitoring/metrics-collector.ts`

**ì„¤ëª…:** Metrics Collection System
Collects and aggregates application metrics for monitoring

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 7317 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 283
- ğŸ”§ í•¨ìˆ˜: 0ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 1ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 2ê°œ

**Exports:**

- `Metric`
- `MetricAggregation`
- `MetricsCollector`
- `metrics`
- `httpMetrics`
- `dbMetrics`
- `businessMetrics`

### ğŸ“¦ Classes

#### `MetricsCollector`

**íŠ¹ì„±:** `exported`

### ğŸ”— Interfaces

#### `Metric`

Metrics Collection System
Collects and aggregates application metrics for monitoring

**íŠ¹ì„±:** `exported`

#### `MetricAggregation`

**íŠ¹ì„±:** `exported`

## monitoring-init.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/monitoring/monitoring-init.ts`

**ì„¤ëª…:** Monitoring System Initialization
ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ ì´ˆê¸°í™”

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 8442 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 315
- ğŸ”§ í•¨ìˆ˜: 0ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 1ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 0ê°œ

**Exports:**

- `monitoringSystem`

### ğŸ“¦ Classes

#### `MonitoringSystem`

## sentry.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/monitoring/sentry.ts`

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 2456 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 105
- ğŸ”§ í•¨ìˆ˜: 7ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 0ê°œ

**Exports:**

- `initSentry`
- `setSentryUser`
- `clearSentryUser`
- `captureError`
- `captureMessage`
- `startTransaction`
- `addBreadcrumb`

### ğŸ”§ Functions

#### `initSentry`

**íŠ¹ì„±:** `exported`

#### `setSentryUser`

**íŠ¹ì„±:** `exported`

#### `clearSentryUser`

**íŠ¹ì„±:** `exported`

#### `captureError`

**íŠ¹ì„±:** `exported`

#### `captureMessage`

**íŠ¹ì„±:** `exported`

#### `startTransaction`

**íŠ¹ì„±:** `exported`

#### `addBreadcrumb`

**íŠ¹ì„±:** `exported`

## monitoring.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/monitoring.ts`

**ì„¤ëª…:** Production Performance Monitoring System
Tracks Core Web Vitals, API performance, and user interactions

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 9481 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 352
- ğŸ”§ í•¨ìˆ˜: 6ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 2ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 3ê°œ

**Exports:**

- `performanceMonitor`
- `usePerformanceTracking`
- `createAPIPerformanceMiddleware`
- `ErrorBoundary`
- `initializeMonitoring`
- `type`

### ğŸ”§ Functions

#### `usePerformanceTracking`

**íŠ¹ì„±:** `exported`

#### `trackAction`

#### `trackAPICall`

#### `trackError`

#### `createAPIPerformanceMiddleware`

**íŠ¹ì„±:** `exported`

#### `initializeMonitoring`

**íŠ¹ì„±:** `exported`

### ğŸ“¦ Classes

#### `PerformanceMonitor`

#### `ErrorBoundary`

**íŠ¹ì„±:** `exported`

### ğŸ”— Interfaces

#### `PerformanceMetric`

Production Performance Monitoring System
Tracks Core Web Vitals, API performance, and user interactions

#### `APIMetric`

#### `ErrorMetric`

## alert-manager.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/notifications/alert-manager.ts`

**ì„¤ëª…:** Integrated Alert and Notification System
í†µí•© ì•Œë¦¼ ë° ê²½ê³  ì‹œìŠ¤í…œ

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 13356 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 488
- ğŸ”§ í•¨ìˆ˜: 0ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 1ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 3ê°œ

**Exports:**

- `alertManager`
- `systemAlert`
- `type`

### ğŸ“¦ Classes

#### `AlertManager`

### ğŸ”— Interfaces

#### `AlertChannel`

Integrated Alert and Notification System
í†µí•© ì•Œë¦¼ ë° ê²½ê³  ì‹œìŠ¤í…œ

#### `Alert`

#### `NotificationTemplate`

## visa-alerts.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/notifications/visa-alerts.ts`

**ì„¤ëª…:** Visa Alerts System

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 9996 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 361
- ğŸ”§ í•¨ìˆ˜: 2ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 1ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 3ê°œ

**Exports:**

- `VisaAlert`
- `visaAlerts`
- `async`
- `type`

### ğŸ”§ Functions

#### `checkVisaAlerts`

**íŠ¹ì„±:** `exported`, `async`

#### `sendVisaAlert`

**íŠ¹ì„±:** `exported`, `async`

### ğŸ“¦ Classes

#### `VisaAlertsService`

### ğŸ”— Interfaces

#### `VisaAlert`

**íŠ¹ì„±:** `exported`

#### `Visa`

#### `Trip`

## notifications.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/notifications.ts`

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 6683 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 232
- ğŸ”§ í•¨ìˆ˜: 7ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 0ê°œ

**Exports:**

- `DEFAULT_PREFERENCES`
- `isQuietHours`
- `checkVisaExpiry`
- `checkSchengenWarnings`
- `checkUpcomingTrips`
- `formatNotification`
- `async`
- `showBrowserNotification`

### ğŸ”§ Functions

#### `isQuietHours`

**íŠ¹ì„±:** `exported`

#### `checkVisaExpiry`

**íŠ¹ì„±:** `exported`

#### `checkSchengenWarnings`

**íŠ¹ì„±:** `exported`

#### `checkUpcomingTrips`

**íŠ¹ì„±:** `exported`

#### `formatNotification`

**íŠ¹ì„±:** `exported`

#### `requestNotificationPermission`

**íŠ¹ì„±:** `exported`, `async`

#### `showBrowserNotification`

**íŠ¹ì„±:** `exported`

## offline-api-client.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/offline-api-client.ts`

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 8027 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 289
- ğŸ”§ í•¨ìˆ˜: 0ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 1ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 0ê°œ

**Exports:**

- `OfflineApiClient`

### ğŸ“¦ Classes

#### `OfflineApiClient`

**íŠ¹ì„±:** `exported`

## offline-storage.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/offline-storage.ts`

**ì„¤ëª…:** IndexedDBë¥¼ ì‚¬ìš©í•œ ì˜¤í”„ë¼ì¸ ë°ì´í„° ì €ì¥

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 7755 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 256
- ğŸ”§ í•¨ìˆ˜: 0ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 1ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 0ê°œ

**Exports:**

- `offlineStorage`

### ğŸ“¦ Classes

#### `OfflineStorage`

## api-cache.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/performance/api-cache.ts`

**ì„¤ëª…:** Advanced API caching and optimization system
Implements in-memory LRU cache with TTL and Redis-like functionality

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 12382 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 503
- ğŸ”§ í•¨ìˆ˜: 4ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 4ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 3ê°œ

**Exports:**

- `PerformanceCache`
- `apiCache`
- `CacheResponse`
- `requestDeduplicator`
- `rateLimiter`
- `async`
- `compressResponse`
- `decompressResponse`
- `APIPerformanceMonitor`
- `apiMonitor`

### ğŸ”§ Functions

#### `CacheResponse`

**íŠ¹ì„±:** `exported`

#### `optimizedFetch`

**íŠ¹ì„±:** `exported`, `async`

#### `compressResponse`

**íŠ¹ì„±:** `exported`

#### `decompressResponse`

**íŠ¹ì„±:** `exported`

### ğŸ“¦ Classes

#### `PerformanceCache`

**íŠ¹ì„±:** `exported`

#### `RequestDeduplicator`

#### `RateLimiter`

#### `APIPerformanceMonitor`

**íŠ¹ì„±:** `exported`

### ğŸ”— Interfaces

#### `CacheEntry`

Advanced API caching and optimization system
Implements in-memory LRU cache with TTL and Redis-like functionality

#### `CacheStats`

#### `OptimizedFetchOptions`

## database-optimizer.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/performance/database-optimizer.ts`

**ì„¤ëª…:** Database performance optimization utilities
Provides query optimization, connection pooling, and performance monitoring

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 14700 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 540
- ğŸ”§ í•¨ìˆ˜: 0ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 4ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 2ê°œ

**Exports:**

- `QueryOptimizer`
- `ConnectionPoolManager`
- `OptimizedQueries`
- `dbOptimizer`
- `optimizedPrisma`
- `withDatabaseMonitoring`

### ğŸ“¦ Classes

#### `DatabaseOptimizer`

#### `QueryOptimizer`

**íŠ¹ì„±:** `exported`

#### `ConnectionPoolManager`

**íŠ¹ì„±:** `exported`

#### `OptimizedQueries`

**íŠ¹ì„±:** `exported`

### ğŸ”— Interfaces

#### `QueryMetrics`

#### `ConnectionPoolConfig`

## dynamic-imports.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/performance/dynamic-imports.ts`

**ì„¤ëª…:** Dynamic imports for code splitting and performance optimization
Lazy loading components to reduce initial bundle size

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 5694 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 207
- ğŸ”§ í•¨ìˆ˜: 6ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 1ê°œ

**Exports:**

- `DynamicSchengenCalculator`
- `DynamicTravelRecordsTable`
- `DynamicGmailAnalyzer`
- `DynamicCalendarSync`
- `DynamicMonitoringDashboard`
- `DynamicChart`
- `DynamicLineChart`
- `DynamicBarChart`
- `DynamicDatePicker`
- `DynamicRichTextEditor`
- `DynamicPerformanceMonitor`
- `DynamicBundleAnalyzer`
- `createDynamicComponent`
- `preloadCriticalComponents`
- `addResourceHints`

### ğŸ”§ Functions

#### `LoadingSpinner`

#### `preloadCriticalComponents`

**íŠ¹ì„±:** `exported`

#### `preloadOnHover`

#### `addResourceHints`

**íŠ¹ì„±:** `exported`

#### `dnsPrefetch`

#### `preconnect`

### ğŸ”— Interfaces

#### `DynamicComponentOptions`

## resource-optimization.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/performance/resource-optimization.ts`

**ì„¤ëª…:** Resource optimization utilities for critical path performance

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 13207 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 470
- ğŸ”§ í•¨ìˆ˜: 19ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 1ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 0ê°œ

**Exports:**

- `preloadCriticalResources`
- `registerServiceWorker`
- `inlineCriticalCSS`
- `ResourceOptimizer`
- `optimizeWebVitals`
- `initializePerformanceOptimizations`
- `monitorPerformanceBudget`

### ğŸ”§ Functions

#### `preloadCriticalResources`

**íŠ¹ì„±:** `exported`

#### `preloadFont`

#### `preloadCSS`

#### `preloadJS`

#### `dnsPrefetch`

#### `preconnect`

#### `registerServiceWorker`

**íŠ¹ì„±:** `exported`, `async`

#### `inlineCriticalCSS`

**íŠ¹ì„±:** `exported`

#### `optimizeWebVitals`

**íŠ¹ì„±:** `exported`

#### `optimizeLCP`

#### `deferCSS`

#### `optimizeCLS`

#### `reserveSpace`

#### `optimizeFID`

#### `breakUpLongTasks`

#### `runTask`

#### `scheduleTask`

#### `initializePerformanceOptimizations`

**íŠ¹ì„±:** `exported`

#### `monitorPerformanceBudget`

**íŠ¹ì„±:** `exported`

### ğŸ“¦ Classes

#### `ResourceOptimizer`

**íŠ¹ì„±:** `exported`

## prisma.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/prisma.ts`

**ì„¤ëª…:** Use the optimized connection pool instead of direct Prisma client

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 729 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 21
- ğŸ”§ í•¨ìˆ˜: 0ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 0ê°œ

**Exports:**

- `for`

## schengen-calculator.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/schengen-calculator.ts`

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 8383 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 266
- ğŸ”§ í•¨ìˆ˜: 9ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 2ê°œ

**Exports:**

- `SchengenVisit`
- `isSchengenCountry`
- `calculateSchengenStatus`
- `getSchengenWarnings`
- `calculateMaxStayDays`
- `getNextEntryDate`
- `FutureTripValidation`
- `validateFutureTrip`
- `getSafeTravelDates`

### ğŸ”§ Functions

#### `isSchengenCountry`

**íŠ¹ì„±:** `exported`

#### `calculateDaysBetween`

#### `calculateSchengenStatus`

**íŠ¹ì„±:** `exported`

#### `getSchengenWarnings`

**íŠ¹ì„±:** `exported`

#### `calculateMaxStayDays`

**íŠ¹ì„±:** `exported`

#### `getNextEntryDate`

**íŠ¹ì„±:** `exported`

#### `validateFutureTrip`

**íŠ¹ì„±:** `exported`

#### `calculateSchengenStatusOnDate`

#### `getSafeTravelDates`

**íŠ¹ì„±:** `exported`

### ğŸ”— Interfaces

#### `SchengenVisit`

**íŠ¹ì„±:** `exported`

#### `FutureTripValidation`

**íŠ¹ì„±:** `exported`

## api-security.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/security/api-security.ts`

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 6814 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 267
- ğŸ”§ í•¨ìˆ˜: 5ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 1ê°œ

**Exports:**

- `ApiSecurityOptions`
- `withApiSecurity`
- `validators`
- `validateTripData`
- `sanitizeInput`
- `createApiResponse`
- `createErrorResponse`

### ğŸ”§ Functions

#### `withApiSecurity`

API Security utilities for DiNoCal
Provides authentication, authorization, and input validation
/

export interface ApiSecurityOptions {
requireAuth?: boolean
allowedMethods?: string[]
rateLimitKey?: string
validateInput?: boolean
}

/\*\*
Secure API route wrapper with comprehensive security checks

**íŠ¹ì„±:** `exported`

#### `validateTripData`

API Security utilities for DiNoCal
Provides authentication, authorization, and input validation
/

export interface ApiSecurityOptions {
requireAuth?: boolean
allowedMethods?: string[]
rateLimitKey?: string
validateInput?: boolean
}

/\*\*
Secure API route wrapper with comprehensive security checks
/
export function withApiSecurity(
handler: (req: NextRequest, context?: any) => Promise<NextResponse>,
options: ApiSecurityOptions = {}
) {
return async (req: NextRequest, context?: any) => {
const {
requireAuth = true,
allowedMethods = ['GET', 'POST', 'PUT', 'DELETE'],
validateInput = true
} = options

    try {
      // Method validation
      if (!allowedMethods.includes(req.method || '')) {
        return NextResponse.json(
          { success: false, error: 'Method not allowed' },
          { status: 405, headers: { Allow: allowedMethods.join(', ') } }
        )
      }

      // Authentication check
      if (requireAuth) {
        const session = await getServerSession(authOptions)
        if (!session?.user) {
          return NextResponse.json(
            { success: false, error: 'Authentication required' },
            { status: 401 }
          )
        }

        // Add user to context
        context = { ...context, user: session.user }
      }

      // Input validation
      if (validateInput && (req.method === 'POST' || req.method === 'PUT')) {
        const contentType = req.headers.get('content-type')
        if (contentType && !contentType.includes('application/json')) {
          return NextResponse.json(
            { success: false, error: 'Content-Type must be application/json' },
            { status: 400 }
          )
        }
      }

      // CSRF protection for state-changing operations
      if (['POST', 'PUT', 'DELETE'].includes(req.method || '')) {
        const origin = req.headers.get('origin')
        const host = req.headers.get('host')

        if (origin && !isAllowedOrigin(origin, host)) {
          return NextResponse.json(
            { success: false, error: 'Invalid origin' },
            { status: 403 }
          )
        }
      }

      // Call the actual handler
      return await handler(req, context)

    } catch (error) {
      // API Security Error occurred

      return NextResponse.json(
        { success: false, error: 'Internal server error' },
        { status: 500 }
      )
    }

}
}

/\*\*
Input validation helpers
/
export const validators = {
email: (email: string): boolean => {
const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
return emailRegex.test(email)
},

date: (dateString: string): boolean => {
const date = new Date(dateString)
return !isNaN(date.getTime()) && !!dateString.match(/^\d{4}-\d{2}-\d{2}$/)
},

visaType: (type: string): boolean => {
const allowedTypes = [
'Tourist', 'Business', 'Student', 'Work', 'Transit', 'Diplomatic',
'Official', 'Journalist', 'Medical', 'Family', 'Investor', 'Artist',
'Researcher', 'Other'
]
return allowedTypes.includes(type)
},

country: (country: string): boolean => {
return typeof country === 'string' && country.length > 0 && country.length < 100
},

passportCountry: (code: string): boolean => {
const allowedCodes = ['KR', 'US', 'JP', 'CN', 'DE', 'FR', 'GB', 'CA', 'AU', 'OTHER']
return allowedCodes.includes(code)
},

maxDays: (days: number): boolean => {
return Number.isInteger(days) && days > 0 && days <= 365
},

notes: (notes: string): boolean => {
return typeof notes === 'string' && notes.length <= 500
}
}

/\*\*
Validate trip form data

**íŠ¹ì„±:** `exported`

#### `sanitizeInput`

API Security utilities for DiNoCal
Provides authentication, authorization, and input validation
/

export interface ApiSecurityOptions {
requireAuth?: boolean
allowedMethods?: string[]
rateLimitKey?: string
validateInput?: boolean
}

/\*\*
Secure API route wrapper with comprehensive security checks
/
export function withApiSecurity(
handler: (req: NextRequest, context?: any) => Promise<NextResponse>,
options: ApiSecurityOptions = {}
) {
return async (req: NextRequest, context?: any) => {
const {
requireAuth = true,
allowedMethods = ['GET', 'POST', 'PUT', 'DELETE'],
validateInput = true
} = options

    try {
      // Method validation
      if (!allowedMethods.includes(req.method || '')) {
        return NextResponse.json(
          { success: false, error: 'Method not allowed' },
          { status: 405, headers: { Allow: allowedMethods.join(', ') } }
        )
      }

      // Authentication check
      if (requireAuth) {
        const session = await getServerSession(authOptions)
        if (!session?.user) {
          return NextResponse.json(
            { success: false, error: 'Authentication required' },
            { status: 401 }
          )
        }

        // Add user to context
        context = { ...context, user: session.user }
      }

      // Input validation
      if (validateInput && (req.method === 'POST' || req.method === 'PUT')) {
        const contentType = req.headers.get('content-type')
        if (contentType && !contentType.includes('application/json')) {
          return NextResponse.json(
            { success: false, error: 'Content-Type must be application/json' },
            { status: 400 }
          )
        }
      }

      // CSRF protection for state-changing operations
      if (['POST', 'PUT', 'DELETE'].includes(req.method || '')) {
        const origin = req.headers.get('origin')
        const host = req.headers.get('host')

        if (origin && !isAllowedOrigin(origin, host)) {
          return NextResponse.json(
            { success: false, error: 'Invalid origin' },
            { status: 403 }
          )
        }
      }

      // Call the actual handler
      return await handler(req, context)

    } catch (error) {
      // API Security Error occurred

      return NextResponse.json(
        { success: false, error: 'Internal server error' },
        { status: 500 }
      )
    }

}
}

/\*\*
Input validation helpers
/
export const validators = {
email: (email: string): boolean => {
const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
return emailRegex.test(email)
},

date: (dateString: string): boolean => {
const date = new Date(dateString)
return !isNaN(date.getTime()) && !!dateString.match(/^\d{4}-\d{2}-\d{2}$/)
},

visaType: (type: string): boolean => {
const allowedTypes = [
'Tourist', 'Business', 'Student', 'Work', 'Transit', 'Diplomatic',
'Official', 'Journalist', 'Medical', 'Family', 'Investor', 'Artist',
'Researcher', 'Other'
]
return allowedTypes.includes(type)
},

country: (country: string): boolean => {
return typeof country === 'string' && country.length > 0 && country.length < 100
},

passportCountry: (code: string): boolean => {
const allowedCodes = ['KR', 'US', 'JP', 'CN', 'DE', 'FR', 'GB', 'CA', 'AU', 'OTHER']
return allowedCodes.includes(code)
},

maxDays: (days: number): boolean => {
return Number.isInteger(days) && days > 0 && days <= 365
},

notes: (notes: string): boolean => {
return typeof notes === 'string' && notes.length <= 500
}
}

/\*\*
Validate trip form data
/
export function validateTripData(data: any): { isValid: boolean; errors: string[] } {
const errors: string[] = []

if (!data.country || !validators.country(data.country)) {
errors.push('Valid country is required')
}

if (!data.entryDate || !validators.date(data.entryDate)) {
errors.push('Valid entry date is required')
}

if (data.exitDate && !validators.date(data.exitDate)) {
errors.push('Exit date must be a valid date')
}

if (!data.visaType || !validators.visaType(data.visaType)) {
errors.push('Valid visa type is required')
}

if (!data.maxDays || !validators.maxDays(data.maxDays)) {
errors.push('Max days must be between 1 and 365')
}

if (!data.passportCountry || !validators.passportCountry(data.passportCountry)) {
errors.push('Valid passport country is required')
}

if (data.notes && !validators.notes(data.notes)) {
errors.push('Notes must be 500 characters or less')
}

// Date logic validation
if (data.entryDate && data.exitDate) {
const entry = new Date(data.entryDate)
const exit = new Date(data.exitDate)
if (exit <= entry) {
errors.push('Exit date must be after entry date')
}
}

return {
isValid: errors.length === 0,
errors
}
}

/\*\*
Sanitize user input

**íŠ¹ì„±:** `exported`

#### `isAllowedOrigin`

API Security utilities for DiNoCal
Provides authentication, authorization, and input validation
/

export interface ApiSecurityOptions {
requireAuth?: boolean
allowedMethods?: string[]
rateLimitKey?: string
validateInput?: boolean
}

/\*\*
Secure API route wrapper with comprehensive security checks
/
export function withApiSecurity(
handler: (req: NextRequest, context?: any) => Promise<NextResponse>,
options: ApiSecurityOptions = {}
) {
return async (req: NextRequest, context?: any) => {
const {
requireAuth = true,
allowedMethods = ['GET', 'POST', 'PUT', 'DELETE'],
validateInput = true
} = options

    try {
      // Method validation
      if (!allowedMethods.includes(req.method || '')) {
        return NextResponse.json(
          { success: false, error: 'Method not allowed' },
          { status: 405, headers: { Allow: allowedMethods.join(', ') } }
        )
      }

      // Authentication check
      if (requireAuth) {
        const session = await getServerSession(authOptions)
        if (!session?.user) {
          return NextResponse.json(
            { success: false, error: 'Authentication required' },
            { status: 401 }
          )
        }

        // Add user to context
        context = { ...context, user: session.user }
      }

      // Input validation
      if (validateInput && (req.method === 'POST' || req.method === 'PUT')) {
        const contentType = req.headers.get('content-type')
        if (contentType && !contentType.includes('application/json')) {
          return NextResponse.json(
            { success: false, error: 'Content-Type must be application/json' },
            { status: 400 }
          )
        }
      }

      // CSRF protection for state-changing operations
      if (['POST', 'PUT', 'DELETE'].includes(req.method || '')) {
        const origin = req.headers.get('origin')
        const host = req.headers.get('host')

        if (origin && !isAllowedOrigin(origin, host)) {
          return NextResponse.json(
            { success: false, error: 'Invalid origin' },
            { status: 403 }
          )
        }
      }

      // Call the actual handler
      return await handler(req, context)

    } catch (error) {
      // API Security Error occurred

      return NextResponse.json(
        { success: false, error: 'Internal server error' },
        { status: 500 }
      )
    }

}
}

/\*\*
Input validation helpers
/
export const validators = {
email: (email: string): boolean => {
const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
return emailRegex.test(email)
},

date: (dateString: string): boolean => {
const date = new Date(dateString)
return !isNaN(date.getTime()) && !!dateString.match(/^\d{4}-\d{2}-\d{2}$/)
},

visaType: (type: string): boolean => {
const allowedTypes = [
'Tourist', 'Business', 'Student', 'Work', 'Transit', 'Diplomatic',
'Official', 'Journalist', 'Medical', 'Family', 'Investor', 'Artist',
'Researcher', 'Other'
]
return allowedTypes.includes(type)
},

country: (country: string): boolean => {
return typeof country === 'string' && country.length > 0 && country.length < 100
},

passportCountry: (code: string): boolean => {
const allowedCodes = ['KR', 'US', 'JP', 'CN', 'DE', 'FR', 'GB', 'CA', 'AU', 'OTHER']
return allowedCodes.includes(code)
},

maxDays: (days: number): boolean => {
return Number.isInteger(days) && days > 0 && days <= 365
},

notes: (notes: string): boolean => {
return typeof notes === 'string' && notes.length <= 500
}
}

/\*\*
Validate trip form data
/
export function validateTripData(data: any): { isValid: boolean; errors: string[] } {
const errors: string[] = []

if (!data.country || !validators.country(data.country)) {
errors.push('Valid country is required')
}

if (!data.entryDate || !validators.date(data.entryDate)) {
errors.push('Valid entry date is required')
}

if (data.exitDate && !validators.date(data.exitDate)) {
errors.push('Exit date must be a valid date')
}

if (!data.visaType || !validators.visaType(data.visaType)) {
errors.push('Valid visa type is required')
}

if (!data.maxDays || !validators.maxDays(data.maxDays)) {
errors.push('Max days must be between 1 and 365')
}

if (!data.passportCountry || !validators.passportCountry(data.passportCountry)) {
errors.push('Valid passport country is required')
}

if (data.notes && !validators.notes(data.notes)) {
errors.push('Notes must be 500 characters or less')
}

// Date logic validation
if (data.entryDate && data.exitDate) {
const entry = new Date(data.entryDate)
const exit = new Date(data.exitDate)
if (exit <= entry) {
errors.push('Exit date must be after entry date')
}
}

return {
isValid: errors.length === 0,
errors
}
}

/\*\*
Sanitize user input
/
export function sanitizeInput(input: any): any {
if (typeof input === 'string') {
return input.trim().replace(/[<>]/g, '')
}

if (Array.isArray(input)) {
return input.map(sanitizeInput)
}

if (typeof input === 'object' && input !== null) {
const sanitized: any = {}
for (const [key, value] of Object.entries(input)) {
sanitized[key] = sanitizeInput(value)
}
return sanitized
}

return input
}

/\*\*
Check if origin is allowed

#### `createErrorResponse`

API Security utilities for DiNoCal
Provides authentication, authorization, and input validation
/

export interface ApiSecurityOptions {
requireAuth?: boolean
allowedMethods?: string[]
rateLimitKey?: string
validateInput?: boolean
}

/\*\*
Secure API route wrapper with comprehensive security checks
/
export function withApiSecurity(
handler: (req: NextRequest, context?: any) => Promise<NextResponse>,
options: ApiSecurityOptions = {}
) {
return async (req: NextRequest, context?: any) => {
const {
requireAuth = true,
allowedMethods = ['GET', 'POST', 'PUT', 'DELETE'],
validateInput = true
} = options

    try {
      // Method validation
      if (!allowedMethods.includes(req.method || '')) {
        return NextResponse.json(
          { success: false, error: 'Method not allowed' },
          { status: 405, headers: { Allow: allowedMethods.join(', ') } }
        )
      }

      // Authentication check
      if (requireAuth) {
        const session = await getServerSession(authOptions)
        if (!session?.user) {
          return NextResponse.json(
            { success: false, error: 'Authentication required' },
            { status: 401 }
          )
        }

        // Add user to context
        context = { ...context, user: session.user }
      }

      // Input validation
      if (validateInput && (req.method === 'POST' || req.method === 'PUT')) {
        const contentType = req.headers.get('content-type')
        if (contentType && !contentType.includes('application/json')) {
          return NextResponse.json(
            { success: false, error: 'Content-Type must be application/json' },
            { status: 400 }
          )
        }
      }

      // CSRF protection for state-changing operations
      if (['POST', 'PUT', 'DELETE'].includes(req.method || '')) {
        const origin = req.headers.get('origin')
        const host = req.headers.get('host')

        if (origin && !isAllowedOrigin(origin, host)) {
          return NextResponse.json(
            { success: false, error: 'Invalid origin' },
            { status: 403 }
          )
        }
      }

      // Call the actual handler
      return await handler(req, context)

    } catch (error) {
      // API Security Error occurred

      return NextResponse.json(
        { success: false, error: 'Internal server error' },
        { status: 500 }
      )
    }

}
}

/\*\*
Input validation helpers
/
export const validators = {
email: (email: string): boolean => {
const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
return emailRegex.test(email)
},

date: (dateString: string): boolean => {
const date = new Date(dateString)
return !isNaN(date.getTime()) && !!dateString.match(/^\d{4}-\d{2}-\d{2}$/)
},

visaType: (type: string): boolean => {
const allowedTypes = [
'Tourist', 'Business', 'Student', 'Work', 'Transit', 'Diplomatic',
'Official', 'Journalist', 'Medical', 'Family', 'Investor', 'Artist',
'Researcher', 'Other'
]
return allowedTypes.includes(type)
},

country: (country: string): boolean => {
return typeof country === 'string' && country.length > 0 && country.length < 100
},

passportCountry: (code: string): boolean => {
const allowedCodes = ['KR', 'US', 'JP', 'CN', 'DE', 'FR', 'GB', 'CA', 'AU', 'OTHER']
return allowedCodes.includes(code)
},

maxDays: (days: number): boolean => {
return Number.isInteger(days) && days > 0 && days <= 365
},

notes: (notes: string): boolean => {
return typeof notes === 'string' && notes.length <= 500
}
}

/\*\*
Validate trip form data
/
export function validateTripData(data: any): { isValid: boolean; errors: string[] } {
const errors: string[] = []

if (!data.country || !validators.country(data.country)) {
errors.push('Valid country is required')
}

if (!data.entryDate || !validators.date(data.entryDate)) {
errors.push('Valid entry date is required')
}

if (data.exitDate && !validators.date(data.exitDate)) {
errors.push('Exit date must be a valid date')
}

if (!data.visaType || !validators.visaType(data.visaType)) {
errors.push('Valid visa type is required')
}

if (!data.maxDays || !validators.maxDays(data.maxDays)) {
errors.push('Max days must be between 1 and 365')
}

if (!data.passportCountry || !validators.passportCountry(data.passportCountry)) {
errors.push('Valid passport country is required')
}

if (data.notes && !validators.notes(data.notes)) {
errors.push('Notes must be 500 characters or less')
}

// Date logic validation
if (data.entryDate && data.exitDate) {
const entry = new Date(data.entryDate)
const exit = new Date(data.exitDate)
if (exit <= entry) {
errors.push('Exit date must be after entry date')
}
}

return {
isValid: errors.length === 0,
errors
}
}

/\*\*
Sanitize user input
/
export function sanitizeInput(input: any): any {
if (typeof input === 'string') {
return input.trim().replace(/[<>]/g, '')
}

if (Array.isArray(input)) {
return input.map(sanitizeInput)
}

if (typeof input === 'object' && input !== null) {
const sanitized: any = {}
for (const [key, value] of Object.entries(input)) {
sanitized[key] = sanitizeInput(value)
}
return sanitized
}

return input
}

/\*\*
Check if origin is allowed
/
function isAllowedOrigin(origin: string, host: string | null): boolean {
const allowedOrigins = [
'http://localhost:3000',
'https://dinocal.vercel.app',
'https://dinocal.app'
]

// Allow same-origin requests
if (host && (origin === `https://${host}` || origin === `http://${host}`)) {
return true
}

return allowedOrigins.includes(origin)
}

/\*\*
Generate secure API response
/
export function createApiResponse<T>(
data: T,
success = true,
message?: string,
status = 200
): NextResponse {
const response = NextResponse.json(
{
success,
data: success ? data : undefined,
error: success ? undefined : data,
message,
timestamp: new Date().toISOString()
},
{ status }
)

// Add security headers
response.headers.set('X-Content-Type-Options', 'nosniff')
response.headers.set('X-Frame-Options', 'DENY')

return response
}

/\*\*
Error response helper

**íŠ¹ì„±:** `exported`

### ğŸ”— Interfaces

#### `ApiSecurityOptions`

API Security utilities for DiNoCal
Provides authentication, authorization, and input validation

**íŠ¹ì„±:** `exported`

## auth-middleware.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/security/auth-middleware.ts`

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 9014 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 366
- ğŸ”§ í•¨ìˆ˜: 1ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 1ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 1ê°œ

**Exports:**

- `AuthContext`
- `AuthMiddleware`
- `async`

### ğŸ”§ Functions

#### `securityMiddleware`

**íŠ¹ì„±:** `exported`, `async`

### ğŸ“¦ Classes

#### `AuthMiddleware`

**íŠ¹ì„±:** `exported`

### ğŸ”— Interfaces

#### `AuthContext`

**íŠ¹ì„±:** `exported`

## auth-security.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/security/auth-security.ts`

**ì„¤ëª…:** Authentication Security Enhancements
CSRF protection, session management, and rate limiting

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 6305 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 215
- ğŸ”§ í•¨ìˆ˜: 1ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 2ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 1ê°œ

**Exports:**

- `CSRFProtection`
- `sessionConfig`
- `rateLimiters`
- `async`

### ğŸ”§ Functions

#### `withAuth`

**íŠ¹ì„±:** `exported`, `async`

### ğŸ“¦ Classes

#### `CSRFProtection`

**íŠ¹ì„±:** `exported`

#### `RateLimiter`

### ğŸ”— Interfaces

#### `RateLimitConfig`

## csrf-protection.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/security/csrf-protection.ts`

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 9802 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 390
- ğŸ”§ í•¨ìˆ˜: 2ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 1ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 0ê°œ

**Exports:**

- `CSRFProtection`
- `async`
- `generateCSRFResponse`

### ğŸ”§ Functions

#### `csrfProtection`

**íŠ¹ì„±:** `exported`, `async`

#### `generateCSRFResponse`

**íŠ¹ì„±:** `exported`

### ğŸ“¦ Classes

#### `CSRFProtection`

**íŠ¹ì„±:** `exported`

## env-validator.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/security/env-validator.ts`

**ì„¤ëª…:** Environment Variable Security Validator
Ensures all required environment variables are present and valid

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 3569 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 113
- ğŸ”§ í•¨ìˆ˜: 4ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 1ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 0ê°œ

**Exports:**

- `ValidatedEnv`
- `validateEnv`
- `isProduction`
- `isDebugMode`
- `getSafeEnv`

### ğŸ”§ Functions

#### `validateEnv`

**íŠ¹ì„±:** `exported`

#### `isProduction`

**íŠ¹ì„±:** `exported`

#### `isDebugMode`

**íŠ¹ì„±:** `exported`

#### `getSafeEnv`

**íŠ¹ì„±:** `exported`

### ğŸ·ï¸ Types

- `ValidatedEnv` (exported)

## input-sanitizer.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/security/input-sanitizer.ts`

**ì„¤ëª…:** Server-side HTML sanitization utilities

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 7827 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 325
- ğŸ”§ í•¨ìˆ˜: 1ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 1ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 0ê°œ

**Exports:**

- `InputSanitizer`
- `async`

### ğŸ”§ Functions

#### `sanitizeRequestBody`

**íŠ¹ì„±:** `exported`, `async`

### ğŸ“¦ Classes

#### `InputSanitizer`

**íŠ¹ì„±:** `exported`

## input-validation.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/security/input-validation.ts`

**ì„¤ëª…:** Input Validation and Sanitization
Comprehensive security for all user inputs

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 6188 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 204
- ğŸ”§ í•¨ìˆ˜: 2ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 0ê°œ

**Exports:**

- `validationPatterns`
- `tripValidation`
- `userValidation`
- `apiValidation`
- `sanitizeSQLIdentifier`
- `sanitizeHTML`
- `fileValidation`
- `async`
- `createValidationMiddleware`

### ğŸ”§ Functions

#### `sanitizeSQLIdentifier`

**íŠ¹ì„±:** `exported`

#### `sanitizeHTML`

**íŠ¹ì„±:** `exported`

## rate-limiter.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/security/rate-limiter.ts`

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 6805 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 271
- ğŸ”§ í•¨ìˆ˜: 2ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 2ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 2ê°œ

**Exports:**

- `RateLimiter`
- `async`
- `logSecurityEvent`

### ğŸ”§ Functions

#### `applyRateLimit`

**íŠ¹ì„±:** `exported`, `async`

#### `logSecurityEvent`

**íŠ¹ì„±:** `exported`

### ğŸ“¦ Classes

#### `MemoryRateLimiter`

#### `RateLimiter`

**íŠ¹ì„±:** `exported`

### ğŸ”— Interfaces

#### `RateLimitConfig`

#### `RateLimitData`

## security.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/security.ts`

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 4175 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 162
- ğŸ”§ í•¨ìˆ˜: 8ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 1ê°œ

**Exports:**

- `RateLimitConfig`
- `DEFAULT_RATE_LIMIT`
- `STRICT_RATE_LIMIT`
- `checkRateLimit`
- `getClientIP`
- `sanitizeHTML`
- `sanitizeText`
- `validateContentType`
- `checkRequestSize`
- `securityHeaders`
- `sanitizeTripData`
- `logSecurityEvent`

### ğŸ”§ Functions

#### `checkRateLimit`

Rate limiting middleware

**íŠ¹ì„±:** `exported`

#### `getClientIP`

Rate limiting middleware
/
export function checkRateLimit(request: NextRequest, config: RateLimitConfig = DEFAULT_RATE_LIMIT): boolean {
const ip = getClientIP(request)
const key = `rate_limit:${ip}`
const now = Date.now()

const existing = rateLimitStore.get(key)

if (!existing || now > existing.resetTime) {
// Reset window
rateLimitStore.set(key, {
count: 1,
resetTime: now + config.windowMs
})
return true
}

if (existing.count >= config.maxRequests) {
return false // Rate limit exceeded
}

// Increment count
existing.count += 1
rateLimitStore.set(key, existing)
return true
}

/\*\*
Extract client IP address

**íŠ¹ì„±:** `exported`

#### `sanitizeHTML`

Rate limiting middleware
/
export function checkRateLimit(request: NextRequest, config: RateLimitConfig = DEFAULT_RATE_LIMIT): boolean {
const ip = getClientIP(request)
const key = `rate_limit:${ip}`
const now = Date.now()

const existing = rateLimitStore.get(key)

if (!existing || now > existing.resetTime) {
// Reset window
rateLimitStore.set(key, {
count: 1,
resetTime: now + config.windowMs
})
return true
}

if (existing.count >= config.maxRequests) {
return false // Rate limit exceeded
}

// Increment count
existing.count += 1
rateLimitStore.set(key, existing)
return true
}

/\*\*
Extract client IP address
/
export function getClientIP(request: NextRequest): string {
const xForwardedFor = request.headers.get('x-forwarded-for')
const xRealIP = request.headers.get('x-real-ip')

if (xForwardedFor) {
return xForwardedFor.split(',')[0].trim()
}

if (xRealIP) {
return xRealIP
}

return request.ip || 'unknown'
}

/\*\*
Sanitize HTML content to prevent XSS

**íŠ¹ì„±:** `exported`

#### `sanitizeText`

Rate limiting middleware
/
export function checkRateLimit(request: NextRequest, config: RateLimitConfig = DEFAULT_RATE_LIMIT): boolean {
const ip = getClientIP(request)
const key = `rate_limit:${ip}`
const now = Date.now()

const existing = rateLimitStore.get(key)

if (!existing || now > existing.resetTime) {
// Reset window
rateLimitStore.set(key, {
count: 1,
resetTime: now + config.windowMs
})
return true
}

if (existing.count >= config.maxRequests) {
return false // Rate limit exceeded
}

// Increment count
existing.count += 1
rateLimitStore.set(key, existing)
return true
}

/\*\*
Extract client IP address
/
export function getClientIP(request: NextRequest): string {
const xForwardedFor = request.headers.get('x-forwarded-for')
const xRealIP = request.headers.get('x-real-ip')

if (xForwardedFor) {
return xForwardedFor.split(',')[0].trim()
}

if (xRealIP) {
return xRealIP
}

return request.ip || 'unknown'
}

/\*\*
Sanitize HTML content to prevent XSS
/
export function sanitizeHTML(input: string): string {
if (typeof input !== 'string') {
return ''
}

// Remove all HTML tags
return input.replace(/<[^>]\*>/g, '')
}

/\*\*
Sanitize and validate text input

**íŠ¹ì„±:** `exported`

#### `validateContentType`

Rate limiting middleware
/
export function checkRateLimit(request: NextRequest, config: RateLimitConfig = DEFAULT_RATE_LIMIT): boolean {
const ip = getClientIP(request)
const key = `rate_limit:${ip}`
const now = Date.now()

const existing = rateLimitStore.get(key)

if (!existing || now > existing.resetTime) {
// Reset window
rateLimitStore.set(key, {
count: 1,
resetTime: now + config.windowMs
})
return true
}

if (existing.count >= config.maxRequests) {
return false // Rate limit exceeded
}

// Increment count
existing.count += 1
rateLimitStore.set(key, existing)
return true
}

/\*\*
Extract client IP address
/
export function getClientIP(request: NextRequest): string {
const xForwardedFor = request.headers.get('x-forwarded-for')
const xRealIP = request.headers.get('x-real-ip')

if (xForwardedFor) {
return xForwardedFor.split(',')[0].trim()
}

if (xRealIP) {
return xRealIP
}

return request.ip || 'unknown'
}

/\*\*
Sanitize HTML content to prevent XSS
/
export function sanitizeHTML(input: string): string {
if (typeof input !== 'string') {
return ''
}

// Remove all HTML tags
return input.replace(/<[^>]\*>/g, '')
}

/\*\*
Sanitize and validate text input
/
export function sanitizeText(input: unknown, maxLength: number = 1000): string {
if (typeof input !== 'string') {
return ''
}

// Remove dangerous characters and limit length
const sanitized = input
.replace(/[<>\"'&]/g, '') // Remove HTML/SQL injection chars
.replace(/javascript:/gi, '') // Remove javascript: protocol
.replace(/on\w+=/gi, '') // Remove event handlers
.trim()
.slice(0, maxLength)

return sanitized
}

/\*\*
Validate request content type

**íŠ¹ì„±:** `exported`

#### `checkRequestSize`

Rate limiting middleware
/
export function checkRateLimit(request: NextRequest, config: RateLimitConfig = DEFAULT_RATE_LIMIT): boolean {
const ip = getClientIP(request)
const key = `rate_limit:${ip}`
const now = Date.now()

const existing = rateLimitStore.get(key)

if (!existing || now > existing.resetTime) {
// Reset window
rateLimitStore.set(key, {
count: 1,
resetTime: now + config.windowMs
})
return true
}

if (existing.count >= config.maxRequests) {
return false // Rate limit exceeded
}

// Increment count
existing.count += 1
rateLimitStore.set(key, existing)
return true
}

/\*\*
Extract client IP address
/
export function getClientIP(request: NextRequest): string {
const xForwardedFor = request.headers.get('x-forwarded-for')
const xRealIP = request.headers.get('x-real-ip')

if (xForwardedFor) {
return xForwardedFor.split(',')[0].trim()
}

if (xRealIP) {
return xRealIP
}

return request.ip || 'unknown'
}

/\*\*
Sanitize HTML content to prevent XSS
/
export function sanitizeHTML(input: string): string {
if (typeof input !== 'string') {
return ''
}

// Remove all HTML tags
return input.replace(/<[^>]\*>/g, '')
}

/\*\*
Sanitize and validate text input
/
export function sanitizeText(input: unknown, maxLength: number = 1000): string {
if (typeof input !== 'string') {
return ''
}

// Remove dangerous characters and limit length
const sanitized = input
.replace(/[<>\"'&]/g, '') // Remove HTML/SQL injection chars
.replace(/javascript:/gi, '') // Remove javascript: protocol
.replace(/on\w+=/gi, '') // Remove event handlers
.trim()
.slice(0, maxLength)

return sanitized
}

/\*\*
Validate request content type
/
export function validateContentType(request: NextRequest, allowedTypes: string[] = ['application/json']): boolean {
const contentType = request.headers.get('content-type')

if (!contentType) {
return false
}

return allowedTypes.some(type => contentType.includes(type))
}

/\*\*
Check request size limit

**íŠ¹ì„±:** `exported`

#### `sanitizeTripData`

Rate limiting middleware
/
export function checkRateLimit(request: NextRequest, config: RateLimitConfig = DEFAULT_RATE_LIMIT): boolean {
const ip = getClientIP(request)
const key = `rate_limit:${ip}`
const now = Date.now()

const existing = rateLimitStore.get(key)

if (!existing || now > existing.resetTime) {
// Reset window
rateLimitStore.set(key, {
count: 1,
resetTime: now + config.windowMs
})
return true
}

if (existing.count >= config.maxRequests) {
return false // Rate limit exceeded
}

// Increment count
existing.count += 1
rateLimitStore.set(key, existing)
return true
}

/\*\*
Extract client IP address
/
export function getClientIP(request: NextRequest): string {
const xForwardedFor = request.headers.get('x-forwarded-for')
const xRealIP = request.headers.get('x-real-ip')

if (xForwardedFor) {
return xForwardedFor.split(',')[0].trim()
}

if (xRealIP) {
return xRealIP
}

return request.ip || 'unknown'
}

/\*\*
Sanitize HTML content to prevent XSS
/
export function sanitizeHTML(input: string): string {
if (typeof input !== 'string') {
return ''
}

// Remove all HTML tags
return input.replace(/<[^>]\*>/g, '')
}

/\*\*
Sanitize and validate text input
/
export function sanitizeText(input: unknown, maxLength: number = 1000): string {
if (typeof input !== 'string') {
return ''
}

// Remove dangerous characters and limit length
const sanitized = input
.replace(/[<>\"'&]/g, '') // Remove HTML/SQL injection chars
.replace(/javascript:/gi, '') // Remove javascript: protocol
.replace(/on\w+=/gi, '') // Remove event handlers
.trim()
.slice(0, maxLength)

return sanitized
}

/\*\*
Validate request content type
/
export function validateContentType(request: NextRequest, allowedTypes: string[] = ['application/json']): boolean {
const contentType = request.headers.get('content-type')

if (!contentType) {
return false
}

return allowedTypes.some(type => contentType.includes(type))
}

/\*_
Check request size limit
/
export function checkRequestSize(request: NextRequest, maxSizeBytes: number = 1024 _ 1024): boolean {
const contentLength = request.headers.get('content-length')

if (!contentLength) {
return true // Allow requests without content-length
}

return parseInt(contentLength) <= maxSizeBytes
}

/\*\*
Security headers for API responses
/
export const securityHeaders = {
'X-Content-Type-Options': 'nosniff',
'X-Frame-Options': 'DENY',
'X-XSS-Protection': '1; mode=block',
'Cache-Control': 'private, no-cache, no-store, must-revalidate',
'Pragma': 'no-cache',
'Expires': '0'
}

/\*\*
Validate and sanitize trip data

**íŠ¹ì„±:** `exported`

#### `logSecurityEvent`

Rate limiting middleware
/
export function checkRateLimit(request: NextRequest, config: RateLimitConfig = DEFAULT_RATE_LIMIT): boolean {
const ip = getClientIP(request)
const key = `rate_limit:${ip}`
const now = Date.now()

const existing = rateLimitStore.get(key)

if (!existing || now > existing.resetTime) {
// Reset window
rateLimitStore.set(key, {
count: 1,
resetTime: now + config.windowMs
})
return true
}

if (existing.count >= config.maxRequests) {
return false // Rate limit exceeded
}

// Increment count
existing.count += 1
rateLimitStore.set(key, existing)
return true
}

/\*\*
Extract client IP address
/
export function getClientIP(request: NextRequest): string {
const xForwardedFor = request.headers.get('x-forwarded-for')
const xRealIP = request.headers.get('x-real-ip')

if (xForwardedFor) {
return xForwardedFor.split(',')[0].trim()
}

if (xRealIP) {
return xRealIP
}

return request.ip || 'unknown'
}

/\*\*
Sanitize HTML content to prevent XSS
/
export function sanitizeHTML(input: string): string {
if (typeof input !== 'string') {
return ''
}

// Remove all HTML tags
return input.replace(/<[^>]\*>/g, '')
}

/\*\*
Sanitize and validate text input
/
export function sanitizeText(input: unknown, maxLength: number = 1000): string {
if (typeof input !== 'string') {
return ''
}

// Remove dangerous characters and limit length
const sanitized = input
.replace(/[<>\"'&]/g, '') // Remove HTML/SQL injection chars
.replace(/javascript:/gi, '') // Remove javascript: protocol
.replace(/on\w+=/gi, '') // Remove event handlers
.trim()
.slice(0, maxLength)

return sanitized
}

/\*\*
Validate request content type
/
export function validateContentType(request: NextRequest, allowedTypes: string[] = ['application/json']): boolean {
const contentType = request.headers.get('content-type')

if (!contentType) {
return false
}

return allowedTypes.some(type => contentType.includes(type))
}

/\*_
Check request size limit
/
export function checkRequestSize(request: NextRequest, maxSizeBytes: number = 1024 _ 1024): boolean {
const contentLength = request.headers.get('content-length')

if (!contentLength) {
return true // Allow requests without content-length
}

return parseInt(contentLength) <= maxSizeBytes
}

/\*\*
Security headers for API responses
/
export const securityHeaders = {
'X-Content-Type-Options': 'nosniff',
'X-Frame-Options': 'DENY',
'X-XSS-Protection': '1; mode=block',
'Cache-Control': 'private, no-cache, no-store, must-revalidate',
'Pragma': 'no-cache',
'Expires': '0'
}

/\*\*
Validate and sanitize trip data
/
export function sanitizeTripData(data: any) {
return {
country: sanitizeText(data.country, 100),
entryDate: data.entryDate, // Date validation handled by Zod
exitDate: data.exitDate,
visaType: sanitizeText(data.visaType, 50),
maxDays: typeof data.maxDays === 'number' ? Math.max(1, Math.min(365, data.maxDays)) : 30,
passportCountry: sanitizeText(data.passportCountry, 10),
notes: data.notes ? sanitizeHTML(data.notes).slice(0, 2000) : null
}
}

/\*\*
Log security events

**íŠ¹ì„±:** `exported`

### ğŸ”— Interfaces

#### `RateLimitConfig`

**íŠ¹ì„±:** `exported`

## travel-manager.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/travel-manager.ts`

**ì„¤ëª…:** PURPOSE: ì—¬í–‰ ê´€ë¦¬ í•µì‹¬ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ - ì—¬í–‰ CRUD, ì†…ê² ê³„ì‚°, ë¶„ì„ ê¸°ëŠ¥

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 15694 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 573
- ğŸ”§ í•¨ìˆ˜: 3ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 1ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 3ê°œ

**Exports:**

- `TravelManagerOptions`
- `TripSummary`
- `TravelInsights`
- `TravelManager`
- `createTravelManager`
- `async`

### ğŸ”§ Functions

#### `createTravelManager`

**íŠ¹ì„±:** `exported`

#### `getUserTravelSummary`

**íŠ¹ì„±:** `exported`, `async`

#### `validateUserTrip`

**íŠ¹ì„±:** `exported`, `async`

### ğŸ“¦ Classes

#### `TravelManager`

**íŠ¹ì„±:** `exported`

### ğŸ”— Interfaces

#### `TravelManagerOptions`

**íŠ¹ì„±:** `exported`

#### `TripSummary`

**íŠ¹ì„±:** `exported`

#### `TravelInsights`

**íŠ¹ì„±:** `exported`

## utils.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/utils.ts`

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 165 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 6
- ğŸ”§ í•¨ìˆ˜: 1ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 0ê°œ

**Exports:**

- `cn`

### ğŸ”§ Functions

#### `cn`

**íŠ¹ì„±:** `exported`

## visa-requirements.ts

**íŒŒì¼ ê²½ë¡œ:** `lib/visa-requirements.ts`

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 4318 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 107
- ğŸ”§ í•¨ìˆ˜: 1ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 1ê°œ

**Exports:**

- `getVisaRequirements`
- `POPULAR_DESTINATIONS`

### ğŸ”§ Functions

#### `getVisaRequirements`

**íŠ¹ì„±:** `exported`

### ğŸ”— Interfaces

#### `VisaRequirement`

## email.ts

**íŒŒì¼ ê²½ë¡œ:** `types/email.ts`

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 3529 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 113
- ğŸ”§ í•¨ìˆ˜: 0ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 6ê°œ

**Exports:**

- `EmailProvider`
- `EmailPattern`
- `ParsedEmailData`
- `EmailParserResult`
- `EmailParserOptions`
- `KOREAN_AIRLINES`
- `AirportInfo`
- `MAJOR_AIRPORTS`

### ğŸ”— Interfaces

#### `EmailProvider`

**íŠ¹ì„±:** `exported`

#### `EmailPattern`

**íŠ¹ì„±:** `exported`

#### `ParsedEmailData`

**íŠ¹ì„±:** `exported`

#### `EmailParserResult`

**íŠ¹ì„±:** `exported`

#### `EmailParserOptions`

**íŠ¹ì„±:** `exported`

#### `AirportInfo`

**íŠ¹ì„±:** `exported`

## global.ts

**íŒŒì¼ ê²½ë¡œ:** `types/global.ts`

**ì„¤ëª…:** Global type definitions for DiNoCal

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 1356 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 69
- ğŸ”§ í•¨ìˆ˜: 0ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 2ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 5ê°œ

**Exports:**

- `VisaType`
- `PassportCountry`
- `CountryVisit`
- `User`
- `SchengenStatus`
- `SchengenViolation`
- `NotificationSettings`

### ğŸ”— Interfaces

#### `CountryVisit`

**íŠ¹ì„±:** `exported`

#### `User`

**íŠ¹ì„±:** `exported`

#### `SchengenStatus`

**íŠ¹ì„±:** `exported`

#### `SchengenViolation`

**íŠ¹ì„±:** `exported`

#### `NotificationSettings`

**íŠ¹ì„±:** `exported`

### ğŸ·ï¸ Types

- `VisaType` (exported)
- `PassportCountry` (exported)

## gmail.ts

**íŒŒì¼ ê²½ë¡œ:** `types/gmail.ts`

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 1812 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 100
- ğŸ”§ í•¨ìˆ˜: 0ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 11ê°œ

**Exports:**

- `GmailMessage`
- `GmailPayload`
- `GmailHeader`
- `GmailBody`
- `ParsedEmail`
- `ExtractedTravelInfo`
- `GmailSearchOptions`
- `GmailConnectionStatus`
- `TravelEmailPattern`
- `GmailError`
- `EmailParsingConfig`

### ğŸ”— Interfaces

#### `GmailMessage`

**íŠ¹ì„±:** `exported`

#### `GmailPayload`

**íŠ¹ì„±:** `exported`

#### `GmailHeader`

**íŠ¹ì„±:** `exported`

#### `GmailBody`

**íŠ¹ì„±:** `exported`

#### `ParsedEmail`

**íŠ¹ì„±:** `exported`

#### `ExtractedTravelInfo`

**íŠ¹ì„±:** `exported`

#### `GmailSearchOptions`

**íŠ¹ì„±:** `exported`

#### `GmailConnectionStatus`

**íŠ¹ì„±:** `exported`

#### `TravelEmailPattern`

**íŠ¹ì„±:** `exported`

#### `GmailError`

**íŠ¹ì„±:** `exported`

#### `EmailParsingConfig`

**íŠ¹ì„±:** `exported`

## gtag.d.ts

**íŒŒì¼ ê²½ë¡œ:** `types/gtag.d.ts`

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 233 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 12
- ğŸ”§ í•¨ìˆ˜: 0ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 1ê°œ

### ğŸ”— Interfaces

#### `Window`

## next-auth.d.ts

**íŒŒì¼ ê²½ë¡œ:** `types/next-auth.d.ts`

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 574 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 33
- ğŸ”§ í•¨ìˆ˜: 0ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 3ê°œ

### ğŸ”— Interfaces

#### `Session`

#### `User`

#### `JWT`

## notification.ts

**íŒŒì¼ ê²½ë¡œ:** `types/notification.ts`

**íŒŒì¼ ì •ë³´:**

- ğŸ“ í¬ê¸°: 982 bytes
- ğŸ“„ ë¼ì¸ ìˆ˜: 41
- ğŸ”§ í•¨ìˆ˜: 0ê°œ
- ğŸ“¦ í´ë˜ìŠ¤: 0ê°œ
- ğŸ·ï¸ íƒ€ì…: 0ê°œ
- ğŸ”— ì¸í„°í˜ì´ìŠ¤: 3ê°œ

**Exports:**

- `Notification`
- `NotificationPreferences`
- `NotificationSchedule`

### ğŸ”— Interfaces

#### `Notification`

**íŠ¹ì„±:** `exported`

#### `NotificationPreferences`

**íŠ¹ì„±:** `exported`

#### `NotificationSchedule`

**íŠ¹ì„±:** `exported`

---

_ğŸ“… ìƒì„±ì¼: 2025. 7. 29. ì˜¤í›„ 5:23:13_
_ğŸ“Š ì´ 101ê°œ íŒŒì¼ ë¬¸ì„œí™”_
